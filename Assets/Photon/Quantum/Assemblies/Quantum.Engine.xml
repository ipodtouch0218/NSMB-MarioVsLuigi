<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Quantum.Engine</name>
    </assembly>
    <members>
        <member name="T:Quantum.Allocator.Heap">
            <summary>
            The Quantum heap is a custom memory allocator that contains rollback-able memory allocations by Quantum user or internal systems.
            It implements the <see cref="T:Quantum.Allocator.ITrackableFrameHeap"/> interface for memory leak tracking.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.AllocatePtr``1(System.Int32,``0)">
            <summary>
            Allocate a Ptr with a given size.
            </summary>
            <typeparam name="T">Tracker type</typeparam>
            <param name="size">Allocation size</param>
            <param name="allocTracker">Alloc tracker instance</param>
            <returns>Ptr to Quantum heap memory</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.AllocateAndClearPtr``1(System.Int32,``0)">
            <summary>
            Allocate a Ptr with a given size and clear the memory.
            </summary>
            <typeparam name="T">Tracker type</typeparam>
            <param name="size">Allocation size</param>
            <param name="allocTracker">Alloc tracker instance</param>
            <returns>Ptr to Quantum heap memory</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.AllocateAndClear``1(System.Int32,``0)">
            <summary>
            Allocate a void* with a given size and clear the memory.
            </summary>
            <typeparam name="T">Tracker type</typeparam>
            <param name="size">Allocation size</param>
            <param name="allocTracker">Alloc tracker instance</param>
            <returns>Ptr to Quantum heap memory</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.ExpandArray``2(``0*,System.Int32,System.Int32,``1)">
            <summary>
            Grow an allocated array of type T. The content is copied to the new array.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <typeparam name="TTracker">Tracker type</typeparam>
            <param name="buffer">Array</param>
            <param name="currentSize">Current array size</param>
            <param name="newSize">New array size</param>
            <param name="allocTracker">Allocation tracker</param>
            <returns>New array</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Expand``1(System.Void*,System.Int32,System.Int32,``0)">
            <summary>
            Grow an allocated array of type T. The content is copied to the new array.
            </summary>
            <typeparam name="T">Tacker type</typeparam>
            <param name="buffer">Array</param>
            <param name="currentSize">Current array size</param>
            <param name="newSize">New array size</param>
            <param name="allocTracker">Allocation tracker</param>
            <returns>New array</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Allocate``1(System.Int32,``0)">
            <summary>
            Allocate memory on the heap.
            </summary>
            <typeparam name="T">Tracker type</typeparam>
            <param name="size">Allocation size</param>
            <param name="allocTracker">Alloc tracker</param>
            <returns>Allocated memory</returns>
            <exception cref="T:System.ArgumentException">Allocated size is larger than the max size defined by the SimulationConfig.</exception>
        </member>
        <member name="M:Quantum.Allocator.Heap.Allocate(System.Int32)">
            <summary>
            Allocate memory on the heap with a given size.
            </summary>
            <param name="size">Size in bytes</param>
            <returns>Allocated memory.</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.AllocatePtr(System.Int32)">
            <summary>
            Allocate a Ptr of a given size.
            </summary>
            <param name="size">Size</param>
            <returns>Allocated Ptr</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.AllocateAndClear(System.Int32)">
            <summary>
            Allocate memory on the heap with a given size and clear the memory.
            </summary>
            <param name="size">Size</param>
            <returns>Allocated memory</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.AllocateAndClearPtr(System.Int32)">
            <summary>
            Allocate a Ptr of a given size and clear the memory.
            </summary>
            <param name="size">Size</param>
            <returns>Allocated Ptr</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.ExpandArray``1(``0*,System.Int32,System.Int32)">
            <summary>
            Grow an allocated array of type T and copy the content to the new array.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="buffer">Array</param>
            <param name="currentSize">Current array size</param>
            <param name="newSize">New array size</param>
            <returns>New array</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Expand(System.Void*,System.Int32,System.Int32)">
            <summary>
            Grow an allocated array and copy the content to the new array.
            </summary>
            <param name="buffer">Array</param>
            <param name="currentSize">Current array size</param>
            <param name="newSize">New array size</param>
            <returns>New array</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.AllocationTracker.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="P:Quantum.Allocator.Heap.Reserved">
            <summary>
            Set and get the reserved flag.
            </summary>
        </member>
        <member name="P:Quantum.Allocator.Heap.Memory">
            <summary>
            Get direct access to the memory of the heap.
            </summary>
        </member>
        <member name="P:Quantum.Allocator.Heap.Size">
            <summary>
            Returns the heap size set by the <see cref="F:Quantum.Allocator.Heap.Config.HEAP_SIZE"/>.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.Blit(Quantum.Allocator.Heap*)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.Blit(Quantum.Allocator.Heap*,System.Byte[],Photon.Deterministic.Native.Allocator)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.CRC(System.UInt64,Quantum.Allocator.Heap*)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.GetStats(Quantum.Allocator.Heap*)">
            <summary>
            Generates a compact statistic report about the memory usage.
            </summary>
            <param name="heap">Pointer to heap to analyze.</param>
            <returns>Memory statistics</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Copy(Photon.Deterministic.Native.Allocator,Quantum.Allocator.Heap*,Quantum.Allocator.Heap*)">
            <summary>
            Copies the complete frame heap from one heap to another.
            </summary>
            <param name="allocator">Allocator instance</param>
            <param name="to">Destination heap</param>
            <param name="from">Source heap</param>
            <exception cref="T:System.InvalidOperationException">Is thrown when the heaps have different configurations.</exception>
        </member>
        <member name="M:Quantum.Allocator.Heap.Print(Quantum.Allocator.Heap*,Quantum.FramePrinter)">
            <summary>
            Prints the frame heap using a <see cref="T:Quantum.FramePrinter"/>.
            </summary>
            <param name="heap">Pointer to heap instance</param>
            <param name="printer">Printer object</param>
        </member>
        <member name="M:Quantum.Allocator.Heap.Free``1(Quantum.Ptr,``0)">
            <summary>
            Free a ptr from the heap memory.
            </summary>
            <typeparam name="T">Type of allocation tracker</typeparam>
            <param name="ptr">Ptr</param>
            <param name="allocTracker">Allocation tracker instance</param>
        </member>
        <member name="M:Quantum.Allocator.Heap.Free``1(System.Void*,``0)">
            <summary>
            Free a block of memory from the heap.
            </summary>
            <typeparam name="T">Type of allocation tracker</typeparam>
            <param name="ptr">Memory to free</param>
            <param name="allocTracker">Allocation tracker instance</param>
        </member>
        <member name="M:Quantum.Allocator.Heap.Free(System.Void*)">
            <summary>
            Free a block of memory from the heap.
            </summary>
            <param name="ptr">Memory block</param>
        </member>
        <member name="M:Quantum.Allocator.Heap.Free(Quantum.Ptr)">
            <summary>
            Free a Ptr from the heap memory.
            </summary>
            <param name="ptr">Ptr</param>
        </member>
        <member name="M:Quantum.Allocator.Heap.Reset">
            <summary>
            Reset the heap.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.Void(System.Void*)">
            <summary>
            Converts a pointer to a Ptr.
            </summary>
            <param name="ptr">Void pointer</param>
            <returns>Ptr</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Void(Quantum.Ptr)">
            <summary>
            Converts a Ptr to a void pointer.
            </summary>
            <param name="p">Ptr</param>
            <returns>Pointer</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Void``1(Quantum.Ptr)">
            <summary>
            Converts a Ptr to a typed pointer.
            </summary>
            <typeparam name="T">Type of pointer</typeparam>
            <param name="p">Ptr</param>
            <returns>Pointer of type</returns>
        </member>
        <member name="T:Quantum.Allocator.Heap.Config">
            <summary>
            The configuration of the frame heap.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.PAGE_SHIFT">
            <summary>
            Define the max heap size for one page of memory the frame class uses for custom allocations like QList for example.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.PAGE_COUNT">
            <summary>
            Define the max heap page count for memory the frame class uses for custom allocations like QList for example.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.PAGE_SIZE">
            <summary>
            Using the <see cref="F:Quantum.Allocator.Heap.Config.PAGE_SHIFT"/> resulting size.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.HEAP_SIZE">
            <summary>
            Heap size defined by <see cref="F:Quantum.Allocator.Heap.Config.PAGE_SIZE"/> times <see cref="F:Quantum.Allocator.Heap.Config.PAGE_COUNT"/>.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.HEAP_COUNT">
            <summary>
            Sets extra heaps to allocate for a session in case you need to create 'auxiliary' frames than actually required for the simulation itself.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.SMALL_BIN_SIZE">
            <summary>
            The threshold for small objects.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.SMALL_BIN_COUNT">
            <summary>
            The number of small bins.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Config.SMALL_BIN_ARRAY_SIZE">
            <summary>
            Small bin array size.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.Allocator.Heap.Config"/> struct.
            </summary>
            <param name="pageShift">The page shift value.</param>
            <param name="pageCount">The page count value.</param>
            <param name="heapCount">The heap count value.</param>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.Default(System.Int32)">
            <summary>
            Gets the default configuration.
            </summary>
            <param name="heapCount">The heap count value.</param>
            <returns>The default configuration.</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.Equals(Quantum.Allocator.Heap.Config)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="other">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.GetHashCode">
            <summary>
            Serves as the default hash function.
            </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.op_Equality(Quantum.Allocator.Heap.Config,Quantum.Allocator.Heap.Config)">
            <summary>
            Determines whether two instances of <see cref="T:Quantum.Allocator.Heap.Config"/> are equal.
            </summary>
            <param name="a">The first instance to compare.</param>
            <param name="b">The second instance to compare.</param>
            <returns><see langword="true"/> if the instances are equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.op_Inequality(Quantum.Allocator.Heap.Config,Quantum.Allocator.Heap.Config)">
            <summary>
            Determines whether two instances of <see cref="T:Quantum.Allocator.Heap.Config"/> are not equal.
            </summary>
            <param name="a">The first instance to compare.</param>
            <param name="b">The second instance to compare.</param>
            <returns><see langword="true"/> if the instances are not equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Allocator.Heap.Config.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Quantum.Allocator.Heap.Stats">
            <summary>
            Statistics of the heap.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.TotalMemory">
            <summary>
            Total heap size.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.TotalPages">
            <summary>
            Total page count.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.PagesFree">
            <summary>
            Free pages.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.PagesFull">
            <summary>
            Pages full.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.PagesUsed">
            <summary>
            Pages in use.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.BytesAllocated">
            <summary>
            Total bytes allocated.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.BytesReserved">
            <summary>
            Total bytes reserved.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.Heap.Stats.BytesCommited">
            <summary>
            Totoal bytes commited.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.Heap.Stats.ToString">
            <summary>
            Create a debug string of the stats content.
            </summary>
            <returns>Debug string</returns>
        </member>
        <member name="T:Quantum.Allocator.SimpleHeapAllocTracker">
            <summary>
            An allocation tracker for the frame <see cref="T:Quantum.Allocator.Heap"/>.
            This implemention is used when <see cref="F:Quantum.Allocator.HeapTrackingMode.DetectLeaks"/> mode is selected.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.SimpleHeapAllocTracker.Reset">
            <summary>
            Reset the tracker.
            </summary>
        </member>
        <member name="T:Quantum.Allocator.TracedHeapAllocTracker">
            <summary>
            An allocation tracker for the frame <see cref="T:Quantum.Allocator.Heap"/>.
            This implementation is used when <see cref="F:Quantum.Allocator.HeapTrackingMode.TraceAllocations"/> mode is selected.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.TracedHeapAllocTracker.Reset">
            <summary>
            Reset the tracker.
            </summary>
        </member>
        <member name="T:Quantum.Allocator.HeapTrackingMode">
            <summary>
            To which extent Frame Heap allocations should be tracked.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.HeapTrackingMode.Disabled">
            <summary>
            Allocations are not tracked.
            </summary>
        </member>
        <member name="F:Quantum.Allocator.HeapTrackingMode.DetectLeaks">
            <summary>
            Allocations have their Ptrs tracked.
            A comparison between tracked and serialized Ptrs can detect memory leaks. 
            </summary>
        </member>
        <member name="F:Quantum.Allocator.HeapTrackingMode.TraceAllocations">
            <summary>
            Allocations are tracked, including the stack trace of each allocation.
            This mode can detect memory leaks and report the exact point in the code where the leaked memory was allocated from.
            WARNING: tracing allocations can be VERY slow. This mode is not recommended unless a memory leak is being actively debugged.
            </summary>
        </member>
        <member name="T:Quantum.Allocator.FrameHeap">
            <summary>
            Managed frame heap type that wraps a unmanaged <see cref="T:Quantum.Allocator.Heap"/> instance.
            </summary>
        </member>
        <member name="P:Quantum.Allocator.FrameHeap.HeapUnsafe">
            <summary>
            Access the unmanaged <see cref="T:Quantum.Allocator.Heap"/> instance.
            </summary>
        </member>
        <member name="P:Quantum.Allocator.FrameHeap.Tracker">
            <summary>
            Access the allocation tracker.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.FrameHeap.#ctor(Quantum.Allocator.Heap*,Quantum.Allocator.IHeapAllocationTracker)">
            <summary>
            Creates a new instance of <see cref="T:Quantum.Allocator.FrameHeap"/>.
            </summary>
            <param name="heapUnsafe">The unmanaged heap instance</param>
            <param name="tracker">The tracker instance</param>
        </member>
        <member name="T:Quantum.Allocator.IFrameHeap">
            <summary>
            Custom heap interface for allocating memory on the frame.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.Allocate(System.Int32)">
            <summary>
            Allocates a block of memory of the specified size.
            </summary>
            <param name="size">The size of the memory block to allocate.</param>
            <returns>A pointer to the allocated memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.AllocatePtr(System.Int32)">
            <summary>
            Allocates a Ptr for a block of memory of the specified size.
            </summary>
            <param name="size">The size of the memory block to allocate.</param>
            <returns>A Ptr for the allocated memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.AllocateAndClear(System.Int32)">
            <summary>
            Allocates a block of memory of the specified size and clears it.
            </summary>
            <param name="size">The size of the memory block to allocate.</param>
            <returns>A pointer to the allocated and cleared memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.AllocateAndClearPtr(System.Int32)">
            <summary>
            Allocates a Ptr for a block of memory of the specified size and clears it.
            </summary>
            <param name="size">The size of the memory block to allocate.</param>
            <returns>A Ptr for the allocated and cleared memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.ExpandArray``1(``0*,System.Int32,System.Int32)">
            <summary>
            Expands an array in the given buffer to the specified new size.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <param name="buffer">The buffer containing the array.</param>
            <param name="currentSize">The current size of the array.</param>
            <param name="newSize">The new size of the array.</param>
            <returns>A pointer to the expanded array.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.Expand(System.Void*,System.Int32,System.Int32)">
            <summary>
            Expands a memory block in the given buffer to the specified new size.
            </summary>
            <param name="buffer">The buffer containing the memory block.</param>
            <param name="currentSize">The current size of the memory block.</param>
            <param name="newSize">The new size of the memory block.</param>
            <returns>A pointer to the expanded memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.Free(System.Void*)">
            <summary>
            Frees a block of memory.
            </summary>
            <param name="ptr">A pointer to the memory block to free.</param>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.Free(Quantum.Ptr)">
            <summary>
            Frees a Ptr for a block of memory.
            </summary>
            <param name="ptr">A Ptr for the memory block to free.</param>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.Void(System.Void*)">
            <summary>
            Converts a pointer to a void pointer.
            </summary>
            <param name="ptr">A pointer to convert.</param>
            <returns>A void pointer.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.Void(Quantum.Ptr)">
            <summary>
            Converts a Ptr to a void pointer.
            </summary>
            <param name="p">A Ptr to convert.</param>
            <returns>A void pointer.</returns>
        </member>
        <member name="M:Quantum.Allocator.IFrameHeap.Void``1(Quantum.Ptr)">
            <summary>
            Converts a Ptr to a typed pointer.
            </summary>
            <typeparam name="TPtr">The type of the pointer to convert to.</typeparam>
            <param name="p">A Ptr to convert.</param>
            <returns>A typed pointer.</returns>
        </member>
        <member name="T:Quantum.Allocator.ITrackableFrameHeap">
            <summary>
            Adds memory allocation tracking to the <see cref="T:Quantum.Allocator.IFrameHeap"/>.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.Allocate``1(System.Int32,``0)">
            <summary>
            Allocates a block of memory of the specified size with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the allocation tracker.</typeparam>
            <param name="size">The size of the memory block to allocate.</param>
            <param name="allocTracker">The allocation tracker.</param>
            <returns>A pointer to the allocated memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.AllocatePtr``1(System.Int32,``0)">
            <summary>
            Allocates a Ptr for a block of memory of the specified size with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the allocation tracker.</typeparam>
            <param name="size">The size of the memory block to allocate.</param>
            <param name="allocTracker">The allocation tracker.</param>
            <returns>A Ptr for the allocated memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.AllocateAndClear``1(System.Int32,``0)">
            <summary>
            Allocates a block of memory of the specified size and clears it with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the allocation tracker.</typeparam>
            <param name="size">The size of the memory block to allocate.</param>
            <param name="allocTracker">The allocation tracker.</param>
            <returns>A pointer to the allocated and cleared memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.AllocateAndClearPtr``1(System.Int32,``0)">
            <summary>
            Allocates a Ptr for a block of memory of the specified size and clears it with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the allocation tracker.</typeparam>
            <param name="size">The size of the memory block to allocate.</param>
            <param name="allocTracker">The allocation tracker.</param>
            <returns>A Ptr for the allocated and cleared memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.ExpandArray``2(``0*,System.Int32,System.Int32,``1)">
            <summary>
            Expands an array in the given buffer to the specified new size with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <typeparam name="TTracker">The type of the allocation tracker.</typeparam>
            <param name="buffer">The buffer containing the array.</param>
            <param name="currentSize">The current size of the array.</param>
            <param name="newSize">The new size of the array.</param>
            <param name="allocTracker">The allocation tracker.</param>
            <returns>A pointer to the expanded array.</returns>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.Expand``1(System.Void*,System.Int32,System.Int32,``0)">
            <summary>
            Expands a memory block in the given buffer to the specified new size with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the allocation tracker.</typeparam>
            <param name="buffer">The buffer containing the memory block.</param>
            <param name="currentSize">The current size of the memory block.</param>
            <param name="newSize">The new size of the memory block.</param>
            <param name="allocTracker">The allocation tracker.</param>
            <returns>A pointer to the expanded memory block.</returns>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.Free``1(System.Void*,``0)">
            <summary>
            Frees a block of memory with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the allocation tracker.</typeparam>
            <param name="ptr">A pointer to the memory block to free.</param>
            <param name="allocTracker">The allocation tracker.</param>
        </member>
        <member name="M:Quantum.Allocator.ITrackableFrameHeap.Free``1(Quantum.Ptr,``0)">
            <summary>
            Frees a Ptr for a block of memory with an allocation tracker.
            </summary>
            <typeparam name="T">The type of the allocation tracker.</typeparam>
            <param name="ptr">A Ptr for the memory block to free.</param>
            <param name="allocTracker">The allocation tracker.</param>
        </member>
        <member name="T:Quantum.Allocator.IHeapAllocationTracker">
            <summary>
            Interface of the heap allocation tracker.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.IHeapAllocationTracker.Reset">
            <summary>
            Reset the tracker.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.IHeapAllocationTracker.TrackAlloc(Quantum.Ptr)">
            <summary>
            Track an allocation.
            </summary>
            <param name="ptr">Ptr</param>
        </member>
        <member name="M:Quantum.Allocator.IHeapAllocationTracker.TrackFree(Quantum.Ptr)">
            <summary>
            Track a deallocation.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Allocator.IHeapAllocationTracker.CheckAllocations(System.Collections.Generic.ICollection{Quantum.Ptr})">
            <summary>
            Evaulate all allocations and check for leaks.
            </summary>
            <param name="ptrs">Ptr collection to check</param>
            <returns>Returns <see langword="true"/>, if there are no leaks.</returns>
        </member>
        <member name="T:Quantum.Allocator.HeapAllocationTrackerExt">
            <summary>
            Extension methods for the <see cref="T:Quantum.Allocator.IHeapAllocationTracker"/>.
            </summary>
        </member>
        <member name="M:Quantum.Allocator.HeapAllocationTrackerExt.TrackAllocDebug``1(``0,Quantum.Ptr)">
            <summary>
            Wrap tracking allocations around the DEBUG define.
            </summary>
            <typeparam name="T">Type of allocation tracker</typeparam>
            <param name="t">Tracker instance</param>
            <param name="ptr">Ptr to track</param>
        </member>
        <member name="M:Quantum.Allocator.HeapAllocationTrackerExt.TrackFreeDebug``1(``0,Quantum.Ptr)">
            <summary>
            Wrap tracking deallocations around the DEBUG define.
            </summary>
            <typeparam name="T">Type of allocation tracker</typeparam>
            <param name="t">Tracker instance</param>
            <param name="ptr">Ptr to track</param>
        </member>
        <member name="M:Quantum.Allocator.HeapAllocationTrackerExt.CheckAllocationsDebug``1(``0,System.Collections.Generic.ICollection{Quantum.Ptr})">
            <summary>
            Wrap the leak detection around DEBUG define.
            </summary>
            <typeparam name="T">Type of allocation tracker</typeparam>
            <param name="t">Tracker instance</param>
            <param name="ptrs">Ptrs to validate</param>
        </member>
        <member name="T:Quantum.Ptr">
            <summary>
            The Ptr is a pointer wrapper to a memory location inside the frame heap.
            </summary>
        </member>
        <member name="P:Quantum.Ptr.Null">
            <summary>
            Null pointer
            </summary>
        </member>
        <member name="F:Quantum.Ptr.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Ptr.Offset">
            <summary>
            Represents the memory location.
            </summary>
        </member>
        <member name="M:Quantum.Ptr.#ctor(System.Int32)">
            <summary>
            Create a new Ptr with the offset.
            </summary>
            <param name="offset">Memory location</param>
        </member>
        <member name="M:Quantum.Ptr.Equals(Quantum.Ptr)">
            <summary>
            Equality check.
            </summary>
            <param name="other">Other Ptr</param>
            <returns><see langword="true"/>, if Ptrs are identical</returns>
        </member>
        <member name="M:Quantum.Ptr.Equals(System.Object)">
            <summary>
            Equality check.
            </summary>
            <param name="obj">Other Ptr</param>
            <returns><see langword="true"/>, if Ptrs are identical</returns>
        </member>
        <member name="M:Quantum.Ptr.GetHashCode">
            <summary>
            Calculate the hash code.
            </summary>
            <returns>Ptr hashcode</returns>
        </member>
        <member name="M:Quantum.Ptr.ToString">
            <summary>
            ToString override.
            </summary>
            <returns>Debug representation of the Ptr</returns>
        </member>
        <member name="M:Quantum.Ptr.op_Implicit(Quantum.Ptr)~System.Boolean">
            <summary>
            Cast to bool, check if the Ptr is valid.
            </summary>
            <param name="a">Ptr</param>
        </member>
        <member name="M:Quantum.Ptr.op_Equality(Quantum.Ptr,Quantum.Ptr)">
            <summary>
            Equality check.
            </summary>
            <param name="a">a</param>
            <param name="b">b</param>
            <returns><see langword="true"/> if a equals b</returns>
        </member>
        <member name="M:Quantum.Ptr.op_Inequality(Quantum.Ptr,Quantum.Ptr)">
            <summary>
            Un-equals check.
            </summary>
            <param name="a">a</param>
            <param name="b">b</param>
            <returns><see langword="true"/> if a is not equal to b</returns>
        </member>
        <member name="M:Quantum.Ptr.op_Addition(Quantum.Ptr,System.Int32)">
            <summary>
            Plus operator, adds v to the offset.
            </summary>
            <param name="p">Ptr</param>
            <param name="v">Offset to add</param>
            <returns>A new Ptr with the resulting offset</returns>
        </member>
        <member name="M:Quantum.Ptr.op_Subtraction(Quantum.Ptr,System.Int32)">
            <summary>
            Minus operator, subtracts v from the offset.
            </summary>
            <param name="p">Ptr</param>
            <param name="v">Offset to subtract</param>
            <returns>A new Ptr with the resulting offset</returns>
        </member>
        <member name="M:Quantum.Ptr.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serialize the Ptr to a snapshot of the game state.
            </summary>
            <param name="ptr">Ptr</param>
            <param name="serializer">Serializer</param>
        </member>
        <member name="M:Quantum.Ptr.SerializePtrAndData(Quantum.Ptr*,Quantum.FrameSerializer,System.Int32)">
            <summary>
            Serialize the Ptr and its data to a snapshot of the game state.
            </summary>
            <param name="ptr">Ptr</param>
            <param name="serializer">Serializer</param>
            <param name="dataSize">Data size</param>
        </member>
        <member name="T:Quantum.DefaultAssetGuids">
            <summary>
            Obsolete: Don't use hard-coded asset guids instead use the configs registered in the SimulationConfig.
            </summary>
        </member>
        <member name="T:Quantum.AssetGuid">
            <summary>
            Represents a unique identifier for an asset.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuid.SIZE">
            <summary>
            The size of the AssetGuid in bytes.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuid.DynamicBit">
            <summary>
            The bit that indicates that the AssetGuid is dynamic (reserved for DynamicAssetDB assets).
            </summary>
        </member>
        <member name="F:Quantum.AssetGuid.RuntimeBit">
            <summary>
            The bit that indicates that the AssetGuid is runtime generated.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuid.ReservedBits">
            <summary>
            The reserved bits of the AssetGuid.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuid.Invalid">
            <summary>
            Invalid value of the AssetGuid.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuid.None">
            <summary>
            None value of the AssetGuid.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuid.Value">
            <summary>
            Raw value of the AssetGuid.
            </summary>
        </member>
        <member name="P:Quantum.AssetGuid.IsValid">
            <summary>
            Returns <see langword="true"/> if the AssetGuid is valid (non-zero).
            </summary>
        </member>
        <member name="P:Quantum.AssetGuid.IsDynamic">
            <summary>
            Returns <see langword="true"/> if the AssetGuid is valid and dynamic (reserved for DynamicAssetDB assets).
            </summary>
        </member>
        <member name="P:Quantum.AssetGuid.IsRuntimeGenerated">
            <summary>
            Returns <see langword="true"/> if the AssetGuid is valid and runtime generated.
            </summary>
        </member>
        <member name="P:Quantum.AssetGuid.Type">
            <summary>
            Type of the guid.
            </summary>
        </member>
        <member name="M:Quantum.AssetGuid.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the AssetGuid struct.
            </summary>
            <param name="value">The value of the AssetGuid.</param>
        </member>
        <member name="M:Quantum.AssetGuid.NewGuid">
            <summary>
            Generates a new random AssetGuid.
            </summary>
            <returns>A new random AssetGuid.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes the AssetGuid.
            </summary>
            <param name="ptr">A pointer to the AssetGuid.</param>
            <param name="serializer">The serializer to use.</param>
        </member>
        <member name="M:Quantum.AssetGuid.Print(System.Void*,Quantum.FramePrinter)">
            <summary>
            Prints the AssetGuid.
            </summary>
            <param name="ptr">A pointer to the AssetGuid.</param>
            <param name="printer">The printer to use.</param>
        </member>
        <member name="M:Quantum.AssetGuid.Equals(Quantum.AssetGuid)">
            <summary>
            Determines whether the specified AssetGuid is equal to the current AssetGuid.
            </summary>
            <param name="other">The AssetGuid to compare with the current AssetGuid.</param>
            <returns><see langword="true"/> if the specified AssetGuid is equal to the current AssetGuid; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.CompareTo(Quantum.AssetGuid)">
            <summary>
            Compares the current AssetGuid with another AssetGuid and returns an integer that indicates whether the current AssetGuid is less than, equal to, or greater than the other AssetGuid.
            </summary>
            <param name="other">The AssetGuid to compare with the current AssetGuid.</param>
            <returns>A value that indicates the relative order of the AssetGuids being compared.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current AssetGuid.
            </summary>
            <param name="obj">The object to compare with the current AssetGuid.</param>
            <returns><see langword="true"/> if the specified object is equal to the current AssetGuid; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.GetHashCode">
            <summary>
            Returns the hash code for this AssetGuid.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.op_Equality(Quantum.AssetGuid,Quantum.AssetGuid)">
            <summary>
            Determines whether two AssetGuids are equal.
            </summary>
            <param name="a">The first AssetGuid to compare.</param>
            <param name="b">The second AssetGuid to compare.</param>
            <returns><see langword="true"/> if the AssetGuids are equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.op_Inequality(Quantum.AssetGuid,Quantum.AssetGuid)">
            <summary>
            Determines whether two AssetGuids are not equal.
            </summary>
            <param name="a">The first AssetGuid to compare.</param>
            <param name="b">The second AssetGuid to compare.</param>
            <returns><see langword="true"/> if the AssetGuids are not equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.op_Implicit(System.Int64)~Quantum.AssetGuid">
            <summary>
            Implicitly converts a long value to an AssetGuid.
            </summary>
            <param name="value">The long value to convert.</param>
            <returns>An AssetGuid with the specified value.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.ToString">
            <summary>
            Returns a string representation of the AssetGuid.
            </summary>
            <returns>A string representation of the AssetGuid.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.ToString(System.Boolean)">
            <summary>
            Returns a string representation of the AssetGuid.
            </summary>
            <param name="includeBrackets">Indicates whether to include brackets in the string representation.</param>
            <returns>A string representation of the AssetGuid.</returns>
        </member>
        <member name="M:Quantum.AssetGuid.TryParse(System.String,Quantum.AssetGuid@,System.Boolean)">
            <summary>
            Tries to parse a string representation of an AssetGuid.
            </summary>
            <param name="str">The string representation of the AssetGuid.</param>
            <param name="result">When this method returns, contains the parsed AssetGuid if the parsing succeeded, or default if the parsing failed.</param>
            <param name="includeBrackets">Indicates whether the string representation includes brackets.</param>
            <returns><see langword="true"/> if the parsing succeeded; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:Quantum.AssetGuidType">
            <summary>
            Type of <see cref="T:Quantum.AssetGuid"/>.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuidType.Default">
            <summary>
            Static asset, guid is known before simulation starts. 
            </summary>
        </member>
        <member name="F:Quantum.AssetGuidType.RuntimeGenerated">
            <summary>
            Static asset, guid is generated at runtime.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuidType.DynamicSequential">
            <summary>
            Dynamic asset, value has been sequentially generated. Not meant to be used directly.
            </summary>
        </member>
        <member name="F:Quantum.AssetGuidType.DynamicExplicit">
            <summary>
            Dynamic asset, value has been precalculated.
            </summary>
        </member>
        <member name="T:Quantum.AssetObject">
            <summary>
            A base class for all Quantum asset objects.
            </summary>
        </member>
        <member name="F:Quantum.AssetObject.Identifier">
            <summary>
            The identifier of the asset object.
            </summary>
        </member>
        <member name="P:Quantum.AssetObject.Guid">
            <summary>
            The GUID of the asset object.
            </summary>
        </member>
        <member name="P:Quantum.AssetObject.Path">
            <summary>
            The path of the asset object. Optional.
            </summary>
        </member>
        <member name="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Called when the asset object is loaded.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="M:Quantum.AssetObject.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Called when the asset object is disposed.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="P:Quantum.AssetObject.HasPath">
            <summary>
            Determines whether the asset object has a path.
            </summary>
            <returns><see langword="true"/> if the asset object has a path; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetObject.Create``1">
            <summary>
            Creates a new instance of the specified type.
            </summary>
            <typeparam name="T">The type of the asset object.</typeparam>
            <returns>A new instance of the specified type.</returns>
        </member>
        <member name="M:Quantum.AssetObject.Create(System.Type)">
            <summary>
            Creates a new instance of the specified type.
            </summary>
            <param name="t">The type of the asset object.</param>
            <returns>A new instance of the specified type.</returns>
        </member>
        <member name="M:Quantum.AssetObject.Create``1(System.Action{``0})">
            <summary>
            Creates a new instance of the specified type and initializes it.
            </summary>
            <typeparam name="T">The type of the asset object.</typeparam>
            <param name="init">The initialization action.</param>
            <returns>A new instance of the specified type.</returns>
        </member>
        <member name="M:Quantum.AssetObject.Reset">
            <summary>
            Resets the asset object.
            </summary>
        </member>
        <member name="P:Quantum.AssetObject.Settings">
            <summary>
            Gets the asset object settings.
            </summary>
        </member>
        <member name="T:Quantum.AssetObjectIdentifier">
            <summary>
            A struct that identifies an asset object by either its GUID and (optionally) path.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectIdentifier.Path">
            <summary>
            Asset path, for when assets are queried by path. Optional.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectIdentifier.Guid">
            <summary>
            Asset GUID, for when assets are queried by GUID. Mandatory.
            </summary>
        </member>
        <member name="P:Quantum.AssetObjectIdentifier.HasPath">
            <summary>
            Is the path set?
            </summary>
        </member>
        <member name="M:Quantum.AssetObjectIdentifier.ToString">
            <summary>
            Returns a string representation of the object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.AssetObjectUtils.IsNull(Quantum.AssetObject)">
            <summary>
            Checks if the specified AssetObject is <see langword="null"/>.
            </summary>
            <param name="obj">The AssetObject to check.</param>
            <returns><see langword="true"/> if the specified AssetObject is <see langword="null"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetObjectUtils.IsNotNull(Quantum.AssetObject)">
            <summary>
            Checks if the specified AssetObject is not <see langword="null"/>.
            </summary>
            <param name="obj">The AssetObject to check.</param>
            <returns><see langword="true"/> if the specified AssetObject is not <see langword="null"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetObjectUtils.AreSame(Quantum.AssetObject,Quantum.AssetObject)">
            <summary>
            Checks if the specified AssetObjects are the same.
            </summary>
            <param name="a">The first AssetObject.</param>
            <param name="b">The second AssetObject.</param>
            <returns><see langword="true"/> if the specified AssetObjects are the same; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetObjectUtils.AreNotSame(Quantum.AssetObject,Quantum.AssetObject)">
            <summary>
            Checks if the specified AssetObject is not the same as another AssetObject.
            </summary>
            <param name="a">The first AssetObject to compare.</param>
            <param name="b">The second AssetObject to compare.</param>
            <returns><see langword="true"/> if the specified AssetObject is not the same as the other AssetObject; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetObjectUtils.AreSameNotNull(Quantum.AssetObject,Quantum.AssetObject)">
            <summary>
            Checks if the specified AssetObject is not <see langword="null"/> and is the same as the specified AssetObject b.
            </summary>
            <param name="a">The first AssetObject to compare.</param>
            <param name="b">The second AssetObject to compare.</param>
        </member>
        <member name="T:Quantum.AssetRef">
            <summary>
            An indirect reference to an <see cref="T:Quantum.AssetObject"/>.
            </summary>
        </member>
        <member name="F:Quantum.AssetRef.SIZE">
            <summary>
            The size of the AssetRef struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.AssetRef.Id">
            <summary>
            The AssetGuid of the asset pointed to by the AssetRef.
            </summary>
        </member>
        <member name="M:Quantum.AssetRef.#ctor(Quantum.AssetGuid)">
            <summary>
            Initializes a new instance of the AssetRef struct with the specified AssetGuid.
            </summary>
            <param name="guid">The AssetGuid to assign to the AssetRef.</param>
        </member>
        <member name="P:Quantum.AssetRef.IsValid">
            <summary>
            Gets a value indicating whether the AssetRef is valid (non-zero).
            </summary>
        </member>
        <member name="M:Quantum.AssetRef.op_Implicit(Quantum.AssetObject)~Quantum.AssetRef">
            <summary>
            Implicitly converts an AssetObject to an AssetRef.
            </summary>
            <param name="value">The AssetObject to convert.</param>
            <returns>The converted AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef.op_Implicit(Quantum.AssetGuid)~Quantum.AssetRef">
            <summary>
            Implicitly converts an AssetGuid to an AssetRef.
            </summary>
            <param name="value">The AssetGuid to convert.</param>
            <returns>The converted AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes the AssetRef using the specified FrameSerializer.
            </summary>
            <param name="ptr">A pointer to the AssetRef to serialize.</param>
            <param name="serializer">The FrameSerializer to use for serialization.</param>
        </member>
        <member name="M:Quantum.AssetRef.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes the AssetRef using the specified IDeterministicFrameSerializer.
            </summary>
            <param name="ptr">A pointer to the AssetRef to serialize.</param>
            <param name="serializer">The IDeterministicFrameSerializer to use for serialization.</param>
        </member>
        <member name="M:Quantum.AssetRef.ToString">
            <summary>
            Returns a string representation of the AssetRef.
            </summary>
            <returns>A string representation of the AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef.ToString(Quantum.AssetGuid)">
            <summary>
            Returns a string representation of the specified AssetGuid.
            </summary>
            <param name="Id">The AssetGuid to convert to a string.</param>
            <returns>A string representation of the AssetGuid.</returns>
        </member>
        <member name="M:Quantum.AssetRef.GetHashCode">
            <summary>
            Returns the hash code for the AssetRef.
            </summary>
            <returns>The hash code for the AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef.Equals(Quantum.AssetRef)">
            <summary>
            Determines whether the specified AssetRef is equal to the current AssetRef.
            </summary>
            <param name="other">The AssetRef to compare with the current AssetRef.</param>
            <returns><see langword="true"/> if the specified AssetRef is equal to the current AssetRef; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetRef.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current AssetRef.
            </summary>
            <param name="obj">The object to compare with the current AssetRef.</param>
            <returns><see langword="true"/> if the specified object is equal to the current AssetRef; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetRef.op_Equality(Quantum.AssetRef,Quantum.AssetRef)">
            <summary>
            Implements the equality operator for AssetRef.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.AssetRef.op_Inequality(Quantum.AssetRef,Quantum.AssetRef)">
            <summary>
            Implements the inequality operator for AssetRef.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.AssetRef`1">
            <summary>
            An indirect reference to an <see cref="T:Quantum.AssetObject"/> of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.AssetRef`1.SIZE">
            <summary>
            The size of the AssetRef struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.AssetRef`1.Id">
            <summary>
            The AssetGuid of the asset pointed to by the AssetRef.
            </summary>
        </member>
        <member name="M:Quantum.AssetRef`1.#ctor(Quantum.AssetGuid)">
            <summary>
            Initializes a new instance of the AssetRef struct with the specified AssetGuid.
            </summary>
            <param name="guid">The AssetGuid to assign to the AssetRef.</param>
        </member>
        <member name="M:Quantum.AssetRef`1.#ctor(Quantum.AssetRef)">
            <summary>
            Initializes a new instance of the AssetRef struct with the specified AssetRef.
            </summary>
            <param name="assetRef">The AssetRef to assign to the AssetRef.</param>
        </member>
        <member name="P:Quantum.AssetRef`1.IsValid">
            <summary>
            Gets a value indicating whether the AssetRef is valid (non-zero).
            </summary>
        </member>
        <member name="M:Quantum.AssetRef`1.op_Implicit(`0)~Quantum.AssetRef{`0}">
            <summary>
            Implicitly converts an AssetObject to an AssetRef.
            </summary>
            <param name="value">The AssetObject to convert.</param>
            <returns>The converted AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef`1.op_Implicit(Quantum.AssetGuid)~Quantum.AssetRef{`0}">
            <summary>
            Implicitly converts an AssetGuid to an AssetRef.
            </summary>
            <param name="value">The AssetGuid to convert.</param>
            <returns>The converted AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef`1.ToString">
            <summary>
            Returns a string representation of the AssetRef.
            </summary>
            <returns>A string representation of the AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef`1.ToString(Quantum.AssetGuid)">
            <summary>
            Returns a string representation of the specified AssetGuid.
            </summary>
            <param name="Id">The AssetGuid to convert to a string.</param>
            <returns>A string representation of the AssetGuid.</returns>
        </member>
        <member name="M:Quantum.AssetRef`1.GetHashCode">
            <summary>
            Returns the hash code for the AssetRef.
            </summary>
            <returns>The hash code for the AssetRef.</returns>
        </member>
        <member name="M:Quantum.AssetRef`1.Equals(Quantum.AssetRef{`0})">
            <summary>
            Determines whether the specified AssetRef is equal to the current AssetRef.
            </summary>
            <param name="other">The AssetRef to compare with the current AssetRef.</param>
            <returns><see langword="true"/> if the specified AssetRef is equal to the current AssetRef; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetRef`1.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current AssetRef.
            </summary>
            <param name="obj">The object to compare with the current AssetRef.</param>
            <returns><see langword="true"/> if the specified object is equal to the current AssetRef; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.AssetRef`1.op_Equality(Quantum.AssetRef{`0},Quantum.AssetRef{`0})">
            <summary>
            Implements the equality operator for AssetRef.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.AssetRef`1.op_Inequality(Quantum.AssetRef{`0},Quantum.AssetRef{`0})">
            <summary>
            Implements the inequality operator for AssetRef.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.BinaryData">
            <summary>
            An asset containing raw binary data. Use <see cref="M:Quantum.BinaryData.CreateByteStream"/> to access contents safely
            and auto-decompress, if compressed.
            </summary>
        </member>
        <member name="F:Quantum.BinaryData.Data">
            <summary>
            If <see cref="F:Quantum.BinaryData.IsCompressed"/> is <see langword="true"/>, this needs decompressing before use.
            </summary>
        </member>
        <member name="F:Quantum.BinaryData.IsCompressed">
            <summary>
            If <see langword="true"/>, then <see cref="F:Quantum.BinaryData.Data"/> has been compressed with GZipStream.
            </summary>
        </member>
        <member name="M:Quantum.BinaryData.CreateByteStream">
            <summary>
            Create a ByteStream from the data in this asset. If <see cref="F:Quantum.BinaryData.IsCompressed"/> is <see langword="true"/>, the data will be decompressed.
            </summary>
            <returns>Ready to read stream</returns>
        </member>
        <member name="M:Quantum.BinaryData.SetData(System.Byte[],System.Boolean)">
            <summary>
            Set the data for this asset. If <paramref name="compress"/> is <see langword="true"/>, the data will be compressed with GZipStream.
            </summary>
            <param name="data"></param>
            <param name="compress"></param>
        </member>
        <member name="M:Quantum.BinaryData.Store(System.IO.Stream)">
            <summary>
            Store the data in this asset to a stream. If <see cref="F:Quantum.BinaryData.IsCompressed"/> is <see langword="true"/>, the data will be decompressed.
            </summary>
            <param name="stream">Stream to write to</param>
        </member>
        <member name="M:Quantum.BinaryData.Compress">
            <summary>
            Compress the data in this asset.
            </summary>
            <returns><see langword="true"/> is data was compressed, otherwise <see langword="false"/> if the data was already compressed</returns>
        </member>
        <member name="M:Quantum.BinaryData.Decompress">
            <summary>
            Decompress the data in this asset.
            </summary>
            <returns><see langword="true"/> is the data was decompressed, otherwise <see langword="false"/> if the data was not compressed</returns>
        </member>
        <member name="T:Quantum.CharacterController2DConfig">
            <summary>
            The configuration values of the <see cref="T:Quantum.CharacterController2D"/>. Use this to setup the kcc shape size and tune its movement and collision detection.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.DEFAULT_ID">
            <summary>
            Obsolete. Use the default asset that is set inside the SimulationConfig instead.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.Offset">
            <summary>
            The offset position of the character controller in relation to its transform position.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.Radius">
            <summary>
            The radius of the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.MaxPenetration">
            <summary>
            The maximum allowed penetration distance for the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.PenetrationCorrection">
            <summary>
            The amount of correction applied to the penetration of a character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.Extent">
            <summary>
            The extent value used for the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.MaxContacts">
            <summary>
            The maximum number of contacts considered during character controller movement.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.LayerMask">
            <summary>
            Represents a bitmask for determining which layers an object is on or interacts with.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.UseManifoldNormal">
            <summary>
            Whether the character controller should use the manifold normal for collision resolution.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.AirControl">
            <summary>
            Whether the character controller should be controllable while not grounded.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.Acceleration">
            <summary>
            How fast the character controller accelerates.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.Braking">
            <summary>
            How fast the character controller decelerates.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.BaseJumpImpulse">
            <summary>
            The default jump impulse for the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.MaxSpeed">
            <summary>
            The maximum speed the character controller can move.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.Gravity">
            <summary>
            The gravity applied to the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.MaxSlope">
            <summary>
            The maximum slope the character controller can walk on.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DConfig.MaxSlopeSpeed">
            <summary>
            The maximum speed the character controller can move on a slope.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2DConfig.GravityStrength">
            <summary>
            Magnitude of the config <see cref="F:Quantum.CharacterController2DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2DConfig.GravityNormalized">
            <summary>
            Normalized <see cref="F:Quantum.CharacterController2DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="M:Quantum.CharacterController2DConfig.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <inheritdoc cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>
        </member>
        <member name="T:Quantum.CharacterController3DConfig">
            <summary>
            The configuration values of the <see cref="T:Quantum.CharacterController3D"/>. Use this to setup the kcc shape size and tune its movement and collision detection.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.DEFAULT_ID">
            <summary>
            Obsolete. Use the default asset that is set inside the SimulationConfig instead.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.Offset">
            <summary>
            The offset position of the character controller in relation to its transform position.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.Radius">
            <summary>
            The radius of the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.MaxPenetration">
            <summary>
            The maximum allowed penetration distance for the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.PenetrationCorrection">
            <summary>
            The amount of correction applied to the penetration of a character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.Extent">
            <summary>
            The extent value used for the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.MaxContacts">
            <summary>
            The maximum number of contacts considered during character controller movement.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.LayerMask">
            <summary>
            Represents a bitmask for determining which layers an object is on or interacts with.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.UseManifoldNormal">
            <summary>
            Whether the character controller should use the manifold normal for collision resolution.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.AirControl">
            <summary>
            Whether the character controller should be controllable while not grounded.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.Acceleration">
            <summary>
            How fast the character controller accelerates.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.Braking">
            <summary>
            How fast the character controller decelerates.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.BaseJumpImpulse">
            <summary>
            The default jump impulse for the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.MaxSpeed">
            <summary>
            The maximum speed the character controller can move.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.Gravity">
            <summary>
            The gravity applied to the character controller.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.MaxSlope">
            <summary>
            The maximum slope the character controller can walk on.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DConfig.MaxSlopeSpeed">
            <summary>
            The maximum speed the character controller can move on a slope.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3DConfig.GravityStrength">
            <summary>
            Magnitude of the config <see cref="F:Quantum.CharacterController3DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3DConfig.GravityNormalized">
            <summary>
            Normalized <see cref="F:Quantum.CharacterController3DConfig.Gravity"/>, cached when the asset is loaded.
            </summary>
        </member>
        <member name="M:Quantum.CharacterController3DConfig.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <inheritdoc cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>
        </member>
        <member name="T:Quantum.EntityPrototype">
            <summary>
            An asset that represents a prototype for an entity. Prototypes are a convenient way to define a set of components that can be
            instantiated at runtime using <see cref="M:Quantum.Core.FrameBase.Create(Quantum.AssetRef{Quantum.EntityPrototype})"/> or <see cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/>
            methods.
            </summary>
        </member>
        <member name="F:Quantum.EntityPrototype.Container">
            <summary>
            Container for the components.
            </summary>
        </member>
        <member name="M:Quantum.EntityPrototype.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Ensures contents of <see cref="F:Quantum.EntityPrototype.Container"/> are sorted upon loading.
            </summary>
            <param name="resourceManager"></param>
            <param name="allocator"></param>
        </member>
        <member name="T:Quantum.Map">
            <summary>
            The Quantum map is a Quantum asset that contains information about the level and is used by the deterministic simulation to drive gameplay.
            Only one map can be loaded at a time.
            </summary>
        </member>
        <member name="F:Quantum.Map.UserAsset">
            <summary>
            An optional generic asset reference that the map can be associated with.
            </summary>
        </member>
        <member name="F:Quantum.Map.Scene">
            <summary>
            The Unity scene name is baked into the map. It's loaded automatically if Simulation.AutoLoadSceneFromMap is enabled.
            </summary>
        </member>
        <member name="F:Quantum.Map.ScenePath">
            <summary>
            The Unity scene path is baked into the map for convenience.
            </summary>
        </member>
        <member name="F:Quantum.Map.SceneGuid">
            <summary>
            The Unity scene guid is baked into the map for convenience.
            </summary>
        </member>
        <member name="F:Quantum.Map.WorldSize">
            <summary>
            The physics scene size in the bucketing axis.
            The broad phase is clamped by a bounding box of all physics entries between -WorldSize/2 to WorldSize/2.
            It is therefore crucial to ensure the world is big enough to encompass all entities.
            If an entity is outside the world, it will cost you performance as it is added to either the first or last bucket.
            Everything outside the bounding box is considered to be at the world's edge, from the physics engine perspective,
            which will result in <see langword="false"/> collision candidates.
            In the non bucketing axis, the physics world is only limited by the value range of FP.UsableMin to FP.UsableMax.
            </summary>
        </member>
        <member name="F:Quantum.Map.BucketsCount">
            <summary>The amount of buckets used in the broad phase, which are resolved in parallel.
            Use a reasonable amount according to how many physics entries (colliders) you have. Too many buckets and the handling overhead increases without any performance gain because there are only few entries in each one; too few buckets and there will be an excessive amount of entries in each, slowing down the broad phase performance.
            </summary>
        </member>
        <member name="F:Quantum.Map.BucketsSubdivisions">
            <summary>Regular queries (overlaps and raycasts) use a stabbing approach for checking as few entries as possible in the buckets subdivisions.
            Tweak the number in accordance with the expected amount of entries and regular queries you perform.
            Too many subdivisions will add overhead without performance, while too few will result in queries taking longer to resolve,
            because they will have to check too many entries.
            </summary>
        </member>
        <member name="F:Quantum.Map.BucketingAxis">
            <summary>
            Physics entries are put into buckets according to their position in the bucketing axis.
            </summary>
        </member>
        <member name="F:Quantum.Map.SortingAxis">
            <summary>
            The queries in a bucket are sorted according to their position in the sorting axis.
            </summary>
        </member>
        <member name="F:Quantum.Map.SceneMeshCellSize">
            <summary>Defines the size of the cells into which the 3D triangle soup is divided. 
            This number should be adapted based on how dense the meshes' triangles density to get a reasonable amount of triangles per cell. 
            For better visualization enable related fields in the QuantumEditorSettings asset's Collider gizmos section.
            This will affect the performance of both the broad phase and regular queries.
            Use the Task Profiler to analyse the performance and find the most suitable number for your game. 
            </summary>
        </member>
        <member name="F:Quantum.Map.TriangleMeshCellSize">
            <summary>
            Obsolete. Use <see cref="F:Quantum.Map.SceneMeshCellSize"/> instead for representing the cell size with an FP value.
            </summary>
        </member>
        <member name="F:Quantum.Map.StaticColliders3DTrianglesData">
            <summary>Binary 3D triangle data is saved on an addition Quantum asset.
            </summary>
        </member>
        <member name="F:Quantum.Map.SerializeTrianglesMetadata">
            <summary>If triangles metadata should be serialized (true) or recomputed (false)
            </summary>
        </member>
        <member name="F:Quantum.Map.GridSizeX">
            <summary>
            Number of navmesh grid cells in x-dimension. Toggle Navmesh Grid or Navmesh Area gizmos to preview.
            </summary>
        </member>
        <member name="F:Quantum.Map.GridSizeY">
            <summary>
            Number of navmesh grid cells in y-dimension. Toggle Navmesh Grid or Navmesh Area gizmos to preview.
            </summary>
        </member>
        <member name="F:Quantum.Map.GridNodeSize">
            <summary>
            The number of Unity units per navmesh grid cell. Must be multiple of 2.
            </summary>
        </member>
        <member name="F:Quantum.Map.NavMeshLinks">
            <summary>
            The list of navmesh assets baked into this map.
            </summary>
        </member>
        <member name="F:Quantum.Map.Regions">
            <summary>
            The list of navmesh region names baked into this map.
            </summary>
        </member>
        <member name="F:Quantum.Map.StaticColliders2D">
            <summary>
            All static 2D colliders baked into this map.
            </summary>
        </member>
        <member name="F:Quantum.Map.StaticColliders3D">
            <summary>
            All static 3D colliders baked into this map.
            </summary>
        </member>
        <member name="F:Quantum.Map.MapEntities">
            <summary>
            The list of entities baked into this map.
            </summary>
        </member>
        <member name="F:Quantum.Map.SerializedTriangleDataUncompressedSize">
            <summary>
            How big the serialized triangle data is in uncompressed form.
            </summary>
        </member>
        <member name="F:Quantum.Map.CollidersManagedTriangles">
            <summary>
            The edit-time lookup for 3D static collider triangles.
            </summary>
        </member>
        <member name="F:Quantum.Map.CollidersRuntimeTriangles">
            <summary>
            The runtime lookup for 3D static collider triangles.
            </summary>
        </member>
        <member name="F:Quantum.Map.AllRuntimeTriangles">
            <summary>
            The unmanaged buffer containing all static triangles for this map.
            </summary>
        </member>
        <member name="F:Quantum.Map.StaticPolygonColliderData">
            <summary>
            The list of static 2D polygon collider runtime data.
            </summary>
        </member>
        <member name="F:Quantum.Map.NavMeshes">
            <summary>
            The lookup table for navmeshes. Use navmesh names to find the navmesh object.
            The mapping is created during the asset <see cref="M:Quantum.Map.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> callback.
            </summary>
        </member>
        <member name="F:Quantum.Map.RegionMap">
            <summary>
            The region map lookup table. Use region names to find the region index.
            The mapping is created during the asset <see cref="M:Quantum.Map.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> callback.
            </summary>
        </member>
        <member name="P:Quantum.Map.StaticColliders3DTriangles">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Quantum.Map.WorldSizeX">
            <summary>
            The world size in X-dimension that is covered by the <see cref="F:Quantum.Map.GridSizeX"/>.
            Used by the navmesh system.
            </summary>
        </member>
        <member name="P:Quantum.Map.WorldSizeY">
            <summary>
            The world size in Y-dimension that is covered by the <see cref="F:Quantum.Map.GridSizeY"/>.
            Used by the navmesh system.
            </summary>
        </member>
        <member name="P:Quantum.Map.WorldExtentX">
            <summary>
            The world extent in X-dimension that is covered by the <see cref="F:Quantum.Map.GridSizeX"/>.
            Used by the navmesh system.
            </summary>
        </member>
        <member name="P:Quantum.Map.WorldExtentY">
            <summary>
            The world extent in Y-dimension that is covered by the <see cref="F:Quantum.Map.GridSizeY"/>.
            Used by the navmesh system.
            </summary>
        </member>
        <member name="P:Quantum.Map.WorldOffset">
            <summary>
            The world offset.
            Used by the navmesh system.
            </summary>
        </member>
        <member name="M:Quantum.Map.SerializeStaticColliderTriangles(Quantum.ByteStream,Photon.Deterministic.Native.Allocator,System.Boolean)">
            <summary>
            Serialize or deserialize the static collider triangles data.
            </summary>
            <param name="stream">Input stream</param>
            <param name="allocator">Allocator</param>
            <param name="write">Write or read</param>
        </member>
        <member name="M:Quantum.Map.WriteTrianglesFromBakeData(Quantum.ByteStream)">
            <summary>
            Serialize the static collider triangles data.
            </summary>
            <param name="stream">The stream to write to.</param>
        </member>
        <member name="M:Quantum.Map.ReadTrianglesFromBakeData(Quantum.ByteStream,Photon.Deterministic.Native.Allocator)">
            <summary>
            Deserialize the static collider triangles data.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="allocator">The <see cref="T:Photon.Deterministic.Native.Allocator"/> for this asset.</param>
        </member>
        <member name="M:Quantum.Map.GetStaticColliderTrianglesSerializedSize(System.Boolean)">
            <summary>
            Get the serialized size of the static collider triangles data.
            </summary>
            <param name="isWriting">If the stream is writing.</param>
            <returns>The amount of bytes the triangles occupy.</returns>
        </member>
        <member name="M:Quantum.Map.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Called by the resource manager when the map asset was disposed to release memory.
            </summary>
            <param name="resourceManager">Resource manager</param>
            <param name="allocator">Allocator</param>
        </member>
        <member name="M:Quantum.Map.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Called by the resource manager when the map asset was loaded.
            Used to deserialize map data allocate memory and initialize map data structures.
            </summary>
            <param name="resourceManager">Resource manager</param>
            <param name="allocator">Allocator</param>
        </member>
        <member name="M:Quantum.Map.InitializeStaticTriangles(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Initialize static 3D triangles.
            </summary>
            <param name="resourceManager">The resource manager for this asset.</param>
            <param name="allocator">The <see cref="T:Photon.Deterministic.Native.Allocator"/> for this asset.</param>
        </member>
        <member name="M:Quantum.Map.GetNavMesh(System.String)">
            <summary>
            Get namvesh by name.
            </summary>
            <param name="name">Navmesh name</param>
            <returns>Navmesh asset or <see langword="null"/>.</returns>
        </member>
        <member name="M:Quantum.Map.EnsurePhysicsWorldSizeInValidRange">
            <summary>
            Post-process and clamp the physics world size.
            </summary>
        </member>
        <member name="T:Quantum.NavMesh">
            <summary>
            The asset object that contains a Quantum navigation mesh.
            The object loads an additional data file during the <see cref="M:Quantum.NavMesh.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>.
            This is because of size limitations when loading the data with Unity serialization.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Name">
            <summary>
            Name of the navmesh. Access the navmesh by name through <see cref="F:Quantum.Map.NavMeshes"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.SerializeType">
            <summary>
            How the NavMesh should be serialized.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.RegionMaskBlockCount">
            <summary>
            Used to migrate to a higher max region count. This number will limit the amount of regions blocks serialized.
            Default is 2 to migrate old projects. Should be set to <see cref="F:Quantum.NavMeshRegionMask.BLOCK_COUNT"/> to enable max region count.
            Navmesh must be re-baked after changing.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.DataAsset">
            <summary>
            Asset that contains the actual binary navmesh data.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.GridSizeX">
            <summary>
            The navmesh triangles are partitioned by simple 2D grid. This is the number of all cells on the x-axis. Derived from the map values during baking.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.GridSizeY">
            <summary>
            The number of all grid cells on the y-axis. Derived from the map values during baking.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.GridNodeSize">
            <summary>
            The number of units one grid cell has in both dimensions. Minimum 2. Must be an even number. Derived from the map values during baking.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.WorldOffset">
            <summary>
            The center of the map is the origin. The world offset represents the lower left corner and is copied from <see cref="T:Quantum.Map"/> during the navmesh baking.
            </summary>
            <remarks>WorldOffset.X = -(GridSizeX * GridNodeSize) / 2</remarks>
        </member>
        <member name="F:Quantum.NavMesh.MinAgentRadius">
            <summary>
            The smallest agent radius that the navmesh was created for (to pass visually nicely around the corners).
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Triangles">
            <summary>
            Navmesh triangles.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.TrianglesGrid">
            <summary>
            Per grid cell data structure that holds all indices to triangles inside this cell.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Vertices">
            <summary>
            Navmesh vertices referenced by triangles.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.BorderGrid">
            <summary>
            Per grid cell data structure that holds all indices to borders inside this cell.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.TrianglesCenterGrid">
            <summary>
            Per grid cell data structure that holds one (multiple if regions are used) triangle that is somewhat closest to the grid center as a fallback triangle lookup. 
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Borders">
            <summary>
            Navmesh borders.
            </summary>
        </member>
        <member name="P:Quantum.NavMesh.BorderCount">
            <summary>
            Gets the number of borders.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.Links">
            <summary>
            All extra triangle connections on the navmesh called links.
            </summary>
        </member>
        <member name="F:Quantum.NavMesh.BakeData">
            <summary>
            The BakeData of this navmesh, only used when serialization type is <see cref="F:Quantum.NavMeshSerializeType.BakeDataOnly"/>.
            </summary>
        </member>
        <member name="M:Quantum.NavMesh.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Checks the <see cref="F:Quantum.NavMesh.DataAsset"/> to load the additional data and runs <see cref="M:Quantum.NavMesh.Serialize(Quantum.ByteStream,System.Boolean)"/> to deserialize the navmesh data.
            </summary>
            <param name="assets">The resource manager to access other assets</param>
            <param name="allocator">The allocator to allocate additional memory for this asset</param>
        </member>
        <member name="M:Quantum.NavMesh.ClampToGrid(Photon.Deterministic.FPVector2@)">
            <summary>
            Clamps the position to be on the grid.
            </summary>
            <param name="position">World position</param>
        </member>
        <member name="M:Quantum.NavMesh.ClampToGrid(Photon.Deterministic.FPVector3@)">
            <summary>
            Clamps the position to be on the grid.
            </summary>
            <param name="position">World position</param>
        </member>
        <member name="M:Quantum.NavMesh.GetHeightAtTriangleRaw(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Returns the y-component of the triangle at point p. Does not check if the point is actually on the XZ-dimensions of the triangle.
            Projects the exact XZ position and does not find the closet position inside the triangle.
            </summary>
            <param name="p">Point to project to triangle</param>
            <param name="normal">Triangle normal</param>
            <param name="v0">Point in triangle</param>
            <returns>Height at point in triangle as raw value.</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangle(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,System.Int32@,Photon.Deterministic.FPVector3@)">
            <summary>
            Finds the closest navmesh triangle at the position plus radius. Works in 2D and 3D. 
            This method sets the mailboxing optimization internally which requires the frame object. Otherwise it's identical to <see cref="M:Quantum.NavMesh.FindClosestTriangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,System.Int32@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)"/>.
            Caveat: The result is only a heuristic and not 100% accurate due to simplified calculations to reduce precision issues. 
            For example: in 3D the input position is projected down instead of finding the correct closest position.
            The search can be performance heavy so carefully choose the radius.
            </summary>
            <param name="frame">Frame object to locate mailbox memory</param>
            <param name="sourcePosition">Position to start looking</param>
            <param name="radius">Search radius around starting position. Use FP.0 to only search at the exact input position.</param>
            <param name="regionMask">Region mask</param>
            <param name="triangle">The resulting triangle id</param>
            <param name="closestPosition">The corrected source position on the navmesh</param>
            <returns><see langword="true"/> when a triangle was found</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangle(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,System.Int32@,Photon.Deterministic.FPVector3@)">
            <summary>
            Finds the closest navmesh triangle at the position plus radius. Works in 2D and 3D. 
            This method sets the mailboxing optimization internally which requires the frame object. Otherwise it's identical to <see cref="M:Quantum.NavMesh.FindClosestTriangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,System.Int32@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)"/>.
            Caveat: The result is only a heuristic and not 100% accurate due to simplified calculations to reduce precision issues. 
            For example: in 3D the input position is projected down instead of finding the correct closest position.
            The search can be performance heavy so carefully choose the radius.
            </summary>
            <param name="frame">Frame object to locate mailbox memory</param>
            <param name="sourcePosition">Position to start looking</param>
            <param name="radius">Search radius around starting position. Use FP.0 to only search at the exact input position.</param>
            <param name="regionMask">Region mask</param>
            <param name="triangle">The resulting triangle id</param>
            <param name="closestPosition">The corrected source position on the navmesh</param>
            <returns><see langword="true"/> when a triangle was found</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,System.Int32@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)">
            <summary>
            Finds the closest navmesh triangle at the position plus radius. Works in 2D and 3D.
            Caveat: The result is only a heuristic and not 100% accurate due to simplified calculations to reduce precision issues. 
            For example: in 3D the input position is projected down instead of finding the correct closest position.
            The search can be performance heavy so carefully choose the radius.
            </summary>
            <param name="sourcePosition">Position to start looking</param>
            <param name="radius">Search radius around starting position. Use FP.0 to only search at the exact input position (don't use for 3D).</param>
            <param name="regionMask">Region mask</param>
            <param name="triangle">The resulting triangle id</param>
            <param name="closestPosition">The corrected source position on the navmesh</param>
            <param name="mailbox">Optionally add a mailbox data structure to optimize the performance of search by filtering out already checked triangles.</param>
            <returns><see langword="true"/> when a triangle was found</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindTriangle2D(Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask@,System.Boolean)">
            <summary>
            Finds the triangle at position (X,Z). This will not work in 3D as overlapping triangles may occur. Always use FindClosestTriangle() in 3D.
            </summary>
            <param name="position">Sample position</param>
            <param name="regionMask">Region mask</param>
            <param name="inclusive">Use inclusive <see langword="true"/> when you want include the border and the vertices of the triangle</param>
            <returns>Triangle id or -1</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindClosestTriangleFast(Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask@)">
            <summary>
            Searches the closest triangle to the input position by using the fallback triangle saved for each grid cell. Result is quite inaccurate.
            To use this API the navmesh generation must generate fallback triangles enabled by setting to something else than <see cref="F:Quantum.NavMeshBakeDataFindClosestTriangle.None"/>.
            </summary>
            <param name="position">Input position</param>
            <param name="regionMask">Triangle regions are checked if they are active</param>
            <remarks>This is only available if the NavMesh has been baked with the option to calculate the center grid.</remarks>
            <returns><see langword="true"/> if a triangle was found </returns>
        </member>
        <member name="M:Quantum.NavMesh.FindRandomPointOnTriangle(System.Int32,Photon.Deterministic.RNGSession*,Photon.Deterministic.FPVector3@)">
            <summary>
            Generates a random point on the triangle.
            </summary>
            <param name="triangle">Triangle index. Use FindTriangle() to find the triangle at a position.</param>
            <param name="rngSession">Random number generator usually f->RNG.</param>
            <param name="result">Random position on the triangle or Zero if the triangle does not exists.</param>
        </member>
        <member name="M:Quantum.NavMesh.FindRandomPointOnNavmesh(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.RNGSession*,Quantum.NavMeshRegionMask@,Photon.Deterministic.FPVector3@)">
            <summary>
            Tries to find a random position on the navmesh using the input position and radius. This can fail when there is no navmesh in range.
            Using this method instead of <see cref="M:Quantum.NavMesh.FindRandomPointOnNavmesh(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.RNGSession*,Quantum.NavMeshRegionMask@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)"/>
            will be more costly, but the result is more reliable as it checks more triangles.
            </summary>
            <param name="frame">Frame object to use the multi-threaded mailbox optimization</param>
            <param name="position">Center of random position circle</param>
            <param name="radius">Search a random position inside this radius</param>
            <param name="rngSession">The randomization session</param>
            <param name="regionMask">The region mask to check</param>
            <param name="result">The resulting randomized position</param>
            <returns><see langword="true"/> if a position has been found, <see langword="false"/> if the search failed.</returns>
            <remarks>Creates a randomized position first, then tries validate it by finding the closest triangle around the random position, then tries to find any valid near position inside the radius</remarks>
            <remarks>Creating random points during edit more leads to more efficient and reliable results.</remarks>
        </member>
        <member name="M:Quantum.NavMesh.FindRandomPointOnNavmesh(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.RNGSession*,Quantum.NavMeshRegionMask@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)">
            <summary>
            Tries to find a random position on the navmesh using the input position and radius.
            This can fail when there is no navmesh in range.
            Consider using <see cref="M:Quantum.NavMesh.FindRandomPointOnNavmesh(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.RNGSession*,Quantum.NavMeshRegionMask@,Photon.Deterministic.FPVector3@)"/> for more reliable results but less performant.
            </summary>
            <param name="position">Center of random position circle</param>
            <param name="radius">Search a random position inside this radius</param>
            <param name="rngSession">The randomization session</param>
            <param name="regionMask">The region mask to check</param>
            <param name="result">The resulting randomized position</param>
            <param name="mailbox">Mailbox to improve reliability while adding performance overhead</param>
            <returns><see langword="true"/> if a position has been found, <see langword="false"/> if the search failed.</returns>
            <remarks>Creates a randomized position first, then tries validate it by finding the closest triangle around the random position.</remarks>
            <remarks>Creating random points during edit more leads to more efficient and reliable results.</remarks>
        </member>
        <member name="M:Quantum.NavMesh.FindAnyRandomPointOnNavmesh(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.RNGSession*,Quantum.NavMeshRegionMask@,Photon.Deterministic.FPVector3@)">
            <summary>
            Will return a random point on the navmesh on any of the triangles that intersect the circle weighted by the triangle area.
            The point can be outside of the radius.
            It's a good choice to find any point on the navmesh, when it's not important that the point is inside the defined circle.
            </summary>
            <param name="frame">Frame object to use the multi-threaded mailbox optimization</param>
            <param name="position">Circle position</param>
            <param name="radius">Circle radius</param>
            <param name="rngSession">Rng session from Frame</param>
            <param name="regionMask">Regions to ignore</param>
            <param name="result">Resulting position</param>
            <returns>Returns <see langword="true"/> when a random position was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.NavMesh.FindAnyRandomPointOnNavmesh(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.RNGSession*,Quantum.NavMeshRegionMask@,Photon.Deterministic.FPVector3@,Quantum.MailboxSet8)">
            <summary>
            Will return a random point on the navmesh on any of the triangles that intersect the circle weighted by the triangle area.
            The point can be outside of the radius.
            It's a good choice to find any point on the navmesh, when it's not important that the point is inside the defined circle.
            Becomes more accurate (uniform) and performant when setting a mailbox.
            </summary>
            <param name="position">Circle position</param>
            <param name="radius">Circle radius</param>
            <param name="rngSession">Rng session from Frame</param>
            <param name="regionMask">Regions to ignore</param>
            <param name="result">Resulting position</param>
            <param name="mailbox">Mailbox to improve performance</param>
            <returns>Returns <see langword="true"/> when a random position was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.NavMesh.IsBorderActive(System.Int32,Quantum.NavMeshRegionMask@)">
            <summary>
            Test if the region of the border at index is enabled.
            </summary>
            <param name="borderIndex">Border index</param>
            <param name="regionMask">Region mask</param>
            <returns><see langword="true"/> if region that the border belongs to is active</returns>
        </member>
        <member name="M:Quantum.NavMesh.Contains(Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask@,System.Boolean)">
            <summary>
            Checks if the position is on a navmesh triangle. Does only check the 2D coordinates.
            </summary>
            <param name="position">Position</param>
            <param name="regionMask">Triangle regions are checked if they are active</param>
            <param name="inclusive">Set to <see langword="true"/> if positions exactly on a triangle edge or border are considered to be inside (default is <see langword="false"/>)</param>
            <returns><see langword="true"/> if the position is on the navmesh</returns>
        </member>
        <member name="M:Quantum.NavMesh.LineOfSight(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask@,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Check line of sight inside the navmesh. This also works in 3D and creates a funnel through the navmesh triangles. Start and destination must be inside the navmesh.
            </summary>
            <param name="positionStart">Start position</param>
            <param name="positionDestination">Target position</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="triangleStart">Optionally provide the triangle that the start position is on</param>
            <param name="triangleDestination">Optionally provide the triangle that the destination position is on</param>
            <param name="considerCost">If the cost changes from triangle to triangle consider this non-line of sight</param>
            <returns><see langword="true"/> if there is a unobstructed line of sight on the navmesh</returns>
        </member>
        <member name="M:Quantum.NavMesh.Raycast2D(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.MailboxSet8,Photon.Deterministic.FPVector2@,System.Int32@)">
            <summary>
            Raycast through the navmesh. Only works 2D, even when the navmesh is 3D. The ray is tested against navmesh borders.
            </summary>
            <param name="origin">Ray origin</param>
            <param name="direction">Ray direction</param>
            <param name="distance">Ray length</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="mailbox">Mailbox instance for caching already checked borders, can be <see langword="null"/>, but then the optimization is not used.</param>
            <param name="hit">Position of the closest hit</param>
            <param name="borderIndex">The index of the border that was hit</param>
            <returns><see langword="true"/> is a hit was generated.</returns>
        </member>
        <member name="M:Quantum.NavMesh.MovePositionIntoNavmesh(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@)">
            <summary>
            This performs a correction of the agent movement against the navmesh borders much like solving physics contacts. This works only in 2D for now.
            Used internally if <see cref="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmesh"/> is set.
            </summary>
            <param name="frame">Frame</param>
            <param name="position">Agent current position</param>
            <param name="newPosition">Agent future position</param>
            <param name="correction">The amount of correction in percent (0..1)</param>
            <param name="regionMask">Region mask to check for active borders</param>
            <returns>Corrected position</returns>
        </member>
        <member name="M:Quantum.NavMesh.MovePositionIntoNavmesh(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@)">
            <summary>
            This performs a correction of the agent movement against the navmesh borders much like solving physics contacts. This works only in 2D for now.
            Used internally if <see cref="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmesh"/> is set.
            </summary>
            <param name="frame">Frame</param>
            <param name="position">Agent current position</param>
            <param name="newPosition">Agent future position</param>
            <param name="correction">The amount of correction in percent (0..1)</param>
            <param name="regionMask">Region mask to check for active borders</param>
            <returns>Corrected position</returns>
        </member>
        <member name="M:Quantum.NavMesh.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Serializes internal data structures (Triangles, TrianglesGrid, Vertices, BorderGrid, TrianglesCenterGrid, Regions, Borders) from the byte stream.
            Called during <see cref="M:Quantum.NavMesh.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">.</see>
            </summary>
            <param name="stream">Byte stream</param>
            <param name="write">Write or read</param>
        </member>
        <member name="T:Quantum.NavMeshAgentConfig">
            <summary>
            The configuration file for navmesh agent components.
            </summary>
            See <see cref="T:Quantum.NavMeshSteeringAgent"/>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DEFAULT_ID">
            <summary>
            The asset id of the default agent config all agents use when no explicit config is set.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.UpdateInterval">
            <summary>
            The tick interval in which the agent is updated with. The entity index will influence the exact tick the update will happen for each individual entity.
            1 = every tick, 
            2 = every other tick, ..
            For performance reasons different agents will update at different times although they have the same UpdateInterval.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.PathQuality">
            <summary>
            The quality of the A* heuristic function.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.CachedWaypointCount">
            <summary>
            The number of waypoints stored on the agent. Default is 6.
            </summary>
            <remarks>The first waypoint is generated at the position of the agent. The last waypoint is only used during the re-pathing transition as soon as the one before the last waypoint is reached.</remarks>
            <remarks>The value is clamped to a minimum of 3 and a maximum of <see cref="F:Quantum.Navigation.Constants.MaxWaypoints"/></remarks>.
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.MaxRepathTimeout">
            <summary>
            The agent automatically performs path finding again when not having reaching the current waypoint in the given time frame (sec). Set to 0 to disable.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.LineOfSightFunneling">
            <summary>
            This option makes sure that unnecessary waypoints (mostly due to region edges in the proximity) are removed when they are applied to the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DynamicLineOfSight">
            <summary>
            This setting will make the agent perform a line cast each tick to skip unnecessary waypoints.
            This is rather expensive try <see cref="F:Quantum.NavMeshAgentConfig.DynamicLineOfSightWaypointRange"/> and <see cref="F:Quantum.NavMeshAgentConfig.LineOfSightFunneling"/> first.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DynamicLineOfSightWaypointRange">
            <summary>
            This is similar to the DynamicLineOfSight option but only triggers when the agent is in a certain range of the waypoint.\n
            Disabled when set to 0.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutomaticTargetCorrection">
            <summary>
            When an agent destination is selected that is outside the navmesh and if this option is enabled the target position will automatically tried to be corrected and moved to the inside of the navmesh.\n Don't deactive this if using 3D navmeshes.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutomaticTargetCorrectionRadius">
            <summary>
            When setting a target off the navmesh this value defines the radius that is searched to find a valid position. 
            0 = only at the target position
            >1 = all cells in radius direction around the target position
            Careful: Searching too many cells can greatly impact the performance.
            If the search fails or the offline generated fallback triangle is used.
            This value is also used to correct the start position which otherwise uses a radius of 0.25 for tolerance.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.EnableWaypointDetectionAxis">
            <summary>
            When using agent rotation speed the agent sometimes will struggle to detect if a waypoint is reached. Use this value to create an perpendicular testing axis in front of the waypoint.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.WaypointDetectionAxisExtend">
            <summary>
            The extend of the perpendicular axis is WaypointDetectionAxisExtend. Should be something around the double radius of the agent.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.WaypointDetectionAxisOffset">
            <summary>
            The offset toward the previous waypoint set by WaypointDetectionAxisOffset.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.DefaultWaypointDetectionDistance">
            <summary>
            Only required when no steering agent is used. The value used to detect if the agent has reached a waypoint in the beginning of the tick. Set this value to agent max speed * delta time.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.MovementType">
            <summary>
            Select how velocity is applied to the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.VerticalPositioning">
            <summary>
            Only valid when the agents uses 3D transforms. This defines how it's y-position is calculated. Navmesh is default but it has drawbacks because the navmesh geometry might be too simplified and custom tailored.
            For 3D physics the ground has be created by Quantum colliders.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.Speed">
            <summary>
            The maximum speed of the agent.\n
            The value can be changed during run-time via the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AngularSpeed">
            <summary>
            The angular speed of the agent (in Radian/sec).\n
            Set to 0 to disable agent rotation.\n
            Set to 200 or more to make its rotation instant-like.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.Acceleration">
            <summary>
            The acceleration of the agent.\n
            When set to 0 no acceleration is used.\n
            The value can be changed during run-time via the agent component.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.StoppingDistance">
            <summary>
            The stopping distance of the agent when approaching the target position.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutoBraking">
            <summary>
            If active the agent will start breaking when approaching the target.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AutoBrakingDistance">
            <summary>
            The distance from the target when the agents starts to brake. Cannot be changed during run-time because the value is cached.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmesh">
            <summary>
            Only selectable when <see cref="F:Quantum.NavMeshAgentConfig.MovementType"/> is set to Transform.\n
            The setting makes sure that agents are pushed out of invalid navmesh areas similar to what happens with colliders.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ClampAgentToNavmeshCorrection">
            <summary>
            This is a percentage how much the agent is corrected each tick.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceType">
            <summary>
            Select what type of avoidance procedures are applied to the agent. None will disable the active avoidance but other will still be able to avoid the agent. Remove AvoidanceAgent component to completely disable avoidance.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceQuality">
            <summary>
            Quality settings for agent avoidance.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.Priority">
            <summary>
            The avoidance priority level.
            </summary>
            <remarks>Most important = 0. Least important = 99. Default = 50.</remarks>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceRadius">
            <summary>
            Radius used for avoidance calculation.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceLayer">
            <summary>
            Mark agent with a layer to prevent agents from avoiding each other.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceMask">
            <summary>
            Other agents whose layer is no in the this mask are ignored.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.MaxAvoidanceCandidates">
            <summary>
            Depending on the quality and number of agents that are influencing each other this value needs to be increased to maintain smooth avoidance.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ReduceAvoidanceAtWaypoints">
            <summary>
            Activate this to reduce the agent avoidance when getting close to waypoints.
            Use this only if you have kinematic agents to mitigate agents going off the navmesh. 
            An alternative to this is still under development. 
            Try <see cref="F:Quantum.NavMeshAgentConfig.DynamicLineOfSight"/> when using DynamicBodies to mitigate stuck agents on waypoints.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ReduceAvoidanceFactor">
            <summary>
            This value is multiplied with the agent radius and represents the distance in which the avoidance influence is reduced quadratically.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.AvoidanceCanReduceSpeed">
            <summary>
            This option enables velocity candidates that decrease the agents speed, to make the avoidance maneuvers a bit more natural.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentConfig.ShowDebugAvoidance">
            <summary>
            Show avoidance information of velocity obstacles and candidates.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshAgentConfig.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            This callback is called after the asset has been loaded. A few values are clamped or calculated and cached.
            </summary>
            <param name="assets">Resource manager</param>
            <param name="allocator">Allocator</param>
        </member>
        <member name="M:Quantum.NavMeshAgentConfig.OnValidate">
            <summary>
            Validation and clamping is performed by the Unity editor.
            </summary>
        </member>
        <member name="T:Quantum.PhysicsMaterial">
            <summary>
            The Quantum's asset with the definitions for a <see cref="T:Quantum.PhysicsMaterialData"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterial.DEFAULT_ID">
            <summary>
            Obsolete. Use the default asset that is set inside the SimulationConfig instead.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterial.Restitution">
            <inheritdoc cref="F:Quantum.PhysicsMaterialData.Restitution"/>
        </member>
        <member name="F:Quantum.PhysicsMaterial.RestitutionCombineFunction">
            <inheritdoc cref="F:Quantum.PhysicsMaterialData.RestitutionCombineFunction"/>
        </member>
        <member name="F:Quantum.PhysicsMaterial.FrictionStatic">
            <inheritdoc cref="F:Quantum.PhysicsMaterialData.FrictionStatic"/>
        </member>
        <member name="F:Quantum.PhysicsMaterial.FrictionDynamic">
            <inheritdoc cref="F:Quantum.PhysicsMaterialData.FrictionDynamic"/>
        </member>
        <member name="F:Quantum.PhysicsMaterial.FrictionCombineFunction">
            <inheritdoc cref="F:Quantum.PhysicsMaterialData.FrictionCombineFunction"/>
        </member>
        <member name="P:Quantum.PhysicsMaterial.MaterialData">
            <summary>
            The pointer to an instance of the physics material in Quantum memory.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsMaterial.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <inheritdoc cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>
        </member>
        <member name="M:Quantum.PhysicsMaterial.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <inheritdoc cref="M:Quantum.AssetObject.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>
        </member>
        <member name="T:Quantum.PolygonCollider">
            <summary>
            The asset that contains data of a convex polygon. 
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.PolygonCollider.Vertices">
            <summary>
            The position of each vertex relative to the physics collider position. 
            </summary>
        </member>
        <member name="F:Quantum.PolygonCollider.Normals">
            <summary>
            The normal of each edge of the polygon. It is automatically computed based on the vertices. 
            </summary>
        </member>
        <member name="M:Quantum.PolygonCollider.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <inheritdoc cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>
        </member>
        <member name="M:Quantum.PolygonCollider.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <inheritdoc cref="M:Quantum.AssetObject.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>
        </member>
        <member name="T:Quantum.AssetDB">
            <summary>
            Represents an asset database.
            </summary>
        </member>
        <member name="M:Quantum.AssetDB.#ctor(Quantum.IResourceManager)">
            <summary>
            Represents an asset database.
            </summary>
            <remarks>
            This class is obsolete. Use the <see cref="T:Quantum.IResourceManager"/> interface instead.
            </remarks>
        </member>
        <member name="M:Quantum.AssetDB.FindAsset(Quantum.AssetGuid)">
            <summary>
            Finds an asset based on its GUID.
            </summary>
            <param name="guid">The GUID of the asset to find.</param>
            <returns>The asset object with the specified GUID, or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:Quantum.AssetDB.FindAsset(System.String)">
            <summary>
            Finds an asset with the given path.
            </summary>
            <param name="path">The path of the asset.</param>
            <returns>The asset object with the given path. Returns <see langword="null"/> if the asset was not found.</returns>
            <remarks>
            This method is obsolete. Use the <see cref="M:Quantum.IResourceManager.GetAsset(Quantum.AssetGuid)"/> method instead.
            </remarks>
        </member>
        <member name="M:Quantum.AssetDB.LoadAsset(Quantum.AssetGuid)">
            <summary>
            Loads the specified asset asynchronously.
            </summary>
            <param name="guid">The unique identifier of the asset to load.</param>
            <returns>A boolean indicating whether the asset was loaded successfully.</returns>
            <remarks>
            This method is obsolete. Use the <see cref="M:Quantum.IResourceManager.LoadAssetAsync(Quantum.AssetGuid)"/> method instead.
            </remarks>
        </member>
        <member name="M:Quantum.AssetDB.DisposeAsset(Quantum.AssetGuid)">
            <summary>
            Disposes the asset with the specified <paramref name="guid"/>.
            </summary>
            <param name="guid">The GUID of the asset to dispose.</param>
            <returns><see langword="true"/> if the asset was disposed successfully; otherwise, <see langword="false"/>.</returns>
            <seealso cref="M:Quantum.IResourceManager.DisposeAsset(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.AssetDB.DisposeAsset(System.String)">
            <summary>
            Disposes an asset based on its path.
            </summary>
            <param name="path">The path of the asset to dispose.</param>
            <returns><see langword="true"/> if the asset is disposed successfully; otherwise, <see langword="false"/>.</returns>
            <remarks>This method is obsolete. Use the <see cref="M:Quantum.IResourceManager.DisposeAsset(Quantum.AssetGuid)"/> method instead.</remarks>
        </member>
        <member name="P:Quantum.AssetDB.LoadedAssets">
            <summary>
            Returns all loaded assets.
            </summary>
        </member>
        <member name="T:Quantum.AssetObjectQuery">
            <summary>
            Represents a query for asset objects in the resource manager.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectQuery.Loaded">
            <summary>
            Indicates whether the asset is loaded.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectQuery.Type">
            <summary>
            The type of the asset.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectQuery.ResourceManagerStateValue">
            <summary>
            The state value of the asset. This is used internally by the resource manager.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectQuery.ResourceManagerStateObj">
            <summary>
            The state object of the asset. This is used internally by the resource manager.
            </summary>
        </member>
        <member name="P:Quantum.AssetObjectQuery.IsUsed">
            <summary>
            Indicates whether the query is used.
            </summary>
        </member>
        <member name="M:Quantum.AssetObjectQuery.#ctor(System.Type,System.Nullable{System.Boolean})">
            <summary>
            Initializes a new instance of the AssetObjectQuery struct.
            </summary>
        </member>
        <member name="M:Quantum.AssetObjectQuery.op_Implicit(System.Type)~Quantum.AssetObjectQuery">
            <summary>
            Implicitly converts a Type to an AssetObjectQuery.
            </summary>
        </member>
        <member name="M:Quantum.AssetObjectQuery.IsMatch(Quantum.AssetObjectState)">
            <summary>
            Checks if the asset object state matches the query.
            </summary>
        </member>
        <member name="M:Quantum.AssetObjectQuery.IsMatch(System.Type)">
            <summary>
            Checks if the asset type matches the query.
            </summary>
        </member>
        <member name="M:Quantum.AssetObjectQuery.IsMatch(Quantum.AssetObject)">
            <summary>
            Checks if the asset object matches the query.
            </summary>
        </member>
        <member name="M:Quantum.AssetObjectQuery.Dispose">
            <summary>
            Disposes the AssetObjectQuery, releasing any resources it was holding.
            </summary>
        </member>
        <member name="T:Quantum.AssetObjectState">
            <summary>
            State of an asset object.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectState.NotLoaded">
            <summary>
            Asset is not loaded.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectState.NotFound">
            <summary>
            Asset not found.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectState.Error">
            <summary>
            There has been an error loading the asset.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectState.Loading">
            <summary>
            Asset is being loaded.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectState.Loaded">
            <summary>
            Asset is loaded.
            </summary>
        </member>
        <member name="F:Quantum.AssetObjectState.Disposing">
            <summary>
            Asset is marked for disposing or undergoes disposal.
            </summary>
        </member>
        <member name="T:Quantum.DynamicAssetDB">
             <summary>
             A DynamicAssetDB is a database of assets that can be added and removed at runtime. 
             For late joiners, contents are serialized and deserialized using an IAssetSerializer.
            
             All the <see cref="T:Quantum.DynamicAssetDB"/> instances share ownership over assets due to <see cref="M:Quantum.DynamicAssetDB.CopyFrom(Quantum.DynamicAssetDB)"/>
             sharing reference counts.
             <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> is called when an asset is added or replaced, <see cref="M:Quantum.AssetObject.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> is called
             when assets' reference count reaches zero due to <see cref="M:Quantum.DynamicAssetDB.DisposeAsset(Quantum.AssetGuid)"/>, <see cref="M:Quantum.DynamicAssetDB.CopyFrom(Quantum.DynamicAssetDB)"/>, <see cref="M:Quantum.DynamicAssetDB.ReplaceAsset(Quantum.AssetGuid,Quantum.AssetObject)"/>
             or <see cref="M:Quantum.DynamicAssetDB.Dispose"/>.
             </summary>
             <seealso cref="F:Quantum.DynamicAssetDB.IsLegacyModeEnabled"/>
        </member>
        <member name="F:Quantum.DynamicAssetDB.Allocator">
            <summary>
            The allocator to use when adding assets, for their <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> callback.
            </summary>
        </member>
        <member name="F:Quantum.DynamicAssetDB.IsLegacyModeEnabled">
            <summary>
            If <see langword="true"/>, the legacy dynamic DB behaviour will be used:
            <list type="bullet">
            <item><description><see cref="M:Quantum.DynamicAssetDB.AddAsset(Quantum.AssetObject)"/> and <see cref="M:Quantum.DynamicAssetDB.ReplaceAsset(Quantum.AssetGuid,Quantum.AssetObject)"/> do not invoke <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/></description></item>
            <item><description><see cref="M:Quantum.DynamicAssetDB.DisposeAsset(Quantum.AssetGuid)"/> and <see cref="M:Quantum.DynamicAssetDB.ReplaceAsset(Quantum.AssetGuid,Quantum.AssetObject)"/> do not invoke <see cref="M:Quantum.AssetObject.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/></description></item>
            <item><description><see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> is invoked only by <see cref="M:Quantum.Core.FrameBase.AddAsset(Quantum.AssetObject)"/>, <see cref="M:Quantum.Core.FrameBase.ReplaceAsset(Quantum.AssetGuid,Quantum.AssetObject)"/> and <see cref="M:Quantum.DynamicAssetDB.Deserialize(System.Byte[],Quantum.IAssetSerializer)"/></description></item>
            <item><description><see cref="M:Quantum.DynamicAssetDB.Dispose"/> is a no-op</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Quantum.DynamicAssetDB.FormatVersion">
            <summary>
            The format version of the DynamicAssetDB serialization.
            </summary>
        </member>
        <member name="M:Quantum.DynamicAssetDB.#ctor(Photon.Deterministic.Native.Allocator,System.Boolean,System.Nullable{Quantum.AssetGuid})">
            <summary>
            Initializes a new instance of the DynamicAssetDB class.
            </summary>
            <param name="allocator"></param>
            <param name="lastGuid">The lastGuid value to set.</param>
            <param name="isLegacyMode"></param>
        </member>
        <member name="M:Quantum.DynamicAssetDB.#ctor(Quantum.DynamicAssetDB)">
            <summary>
            Initializes a new instance of the DynamicAssetDB class with the same state as another DynamicAssetDB instance.
            </summary>
            <param name="other">The DynamicAssetDB instance to copy from.</param>
        </member>
        <member name="P:Quantum.DynamicAssetDB.IsEmpty">
            <summary>
            Gets a value indicating whether the DynamicAssetDB is empty.
            </summary>
        </member>
        <member name="P:Quantum.DynamicAssetDB.NextGuid">
            <summary>
            Gets the next available AssetGuid.
            </summary>
        </member>
        <member name="M:Quantum.DynamicAssetDB.AddAsset(Quantum.AssetObject)">
            <summary>
            Adds an asset to the DynamicAssetDB and assigns it a new AssetGuid.
            </summary>
            <param name="asset">The asset to add.</param>
            <returns>The AssetGuid assigned to the added asset.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.AddAsset(Quantum.AssetObject,Quantum.AssetGuid)">
            <summary>
            Adds an asset to the DynamicAssetDB and assigns it a passed AssetGuid.
            </summary>
            <param name="asset">The asset to add.</param>
            <param name="guid">The AssetGuid to be assigned to the added asset. Needs to be of <see cref="F:Quantum.AssetGuidType.DynamicExplicit"/> type.</param>
        </member>
        <member name="M:Quantum.DynamicAssetDB.AddAssetWithValidDynamicGuid(Quantum.AssetObject)">
            <summary>
            Adds an asset to the DynamicAssetDB with a valid dynamic AssetGuid. Does
            not call <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>
            </summary>
            <param name="asset">The asset to add.</param>
        </member>
        <member name="M:Quantum.DynamicAssetDB.ReplaceAsset(Quantum.AssetGuid,Quantum.AssetObject)">
            <summary>
            Replaces an asset with the specified AssetGuid with a new asset.
            </summary>
            <param name="guid">The AssetGuid of the asset to replace.</param>
            <param name="asset">The new asset to replace with.</param>
            <returns>Replaced asset or <c>null</c>, if there was no asset with <paramref name="guid"/></returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.DisposeAsset(Quantum.AssetGuid)">
            <summary>
            Disposes the asset with the specified AssetGuid from the DynamicAssetDB.
            </summary>
            <param name="guid">The AssetGuid of the asset to dispose.</param>
            <returns><see langword="true"/> if the asset was successfully disposed, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.CopyFrom(Quantum.DynamicAssetDB)">
            <summary>
            Copies the state of another DynamicAssetDB instance to this instance.
            </summary>
            <param name="other">The DynamicAssetDB instance to copy from.</param>
        </member>
        <member name="M:Quantum.DynamicAssetDB.Deserialize(System.Byte[],Quantum.IAssetSerializer)">
            <summary>
            Deserializes the DynamicAssetDB from a byte array using the specified assetSerializer and allocator.
            </summary>
            <param name="bytes">The byte array containing the serialized DynamicAssetDB.</param>
            <param name="assetSerializer">The asset serializer to use for deserialization.</param>
        </member>
        <member name="M:Quantum.DynamicAssetDB.Serialize(Quantum.IAssetSerializer)">
            <summary>
            Serializes the DynamicAssetDB using the specified serializer and returns the serialized byte array.
            </summary>
            <param name="serializer">The serializer to use for serialization.</param>
            <returns>The serialized byte array.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.Serialize(Quantum.IAssetSerializer,System.Byte[]@,System.Byte[]@)">
            <summary>
            Serializes the DynamicAssetDB using the specified serializer and assigns the serialized header and assets byte arrays.
            </summary>
            <param name="serializer">The serializer to use for serialization.</param>
            <param name="header">The serialized header byte array.</param>
            <param name="assets">The serialized assets byte array.</param>
        </member>
        <member name="P:Quantum.DynamicAssetDB.Assets">
            <summary>
            Gets all the assets in the DynamicAssetDB.
            </summary>
        </member>
        <member name="M:Quantum.DynamicAssetDB.FindAsset``1(Quantum.AssetGuid)">
            <summary>
            Finds an asset of type T with the specified AssetGuid.
            </summary>
            <typeparam name="T">The type of asset to find.</typeparam>
            <param name="guid">The AssetGuid of the asset to find.</param>
            <returns>The asset of type T with the specified AssetGuid, or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.FindAsset(Quantum.AssetGuid)">
            <summary>
            Finds an asset of type AssetObject with the specified AssetGuid.
            </summary>
            <param name="guid">The AssetGuid of the asset to find.</param>
            <returns>The asset of type AssetObject with the specified AssetGuid, or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.FindAsset``1(System.String)">
            <summary>
            Finds an asset of type T with the specified path.
            </summary>
            <typeparam name="T">The type of asset to find.</typeparam>
            <param name="path">The path of the asset to find.</param>
            <returns>The asset of type T with the specified path, or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.FindAsset(System.String)">
            <summary>
            Finds an asset of type AssetObject with the specified path.
            </summary>
            <param name="path">The path of the asset to find.</param>
            <returns>The asset of type AssetObject with the specified path, or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.GetAssetState(Quantum.AssetGuid)">
            <summary>
            Gets the state of the asset with the specified AssetGuid.
            </summary>
            <param name="guid">The AssetGuid of the asset to get the state of.</param>
            <returns>The state of the asset with the specified AssetGuid.</returns>
        </member>
        <member name="M:Quantum.DynamicAssetDB.Dispose">
            <summary>
            If <see cref="F:Quantum.DynamicAssetDB.IsLegacyModeEnabled"/> is disabled, invokes <see cref="M:Quantum.AssetObject.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> on all assets.
            </summary>
        </member>
        <member name="T:Quantum.IResourceManager">
            <summary>
            Represents an asset manager that can load, unload, and dispose <see cref="T:Quantum.AssetObject"/>.
            </summary>
        </member>
        <member name="M:Quantum.IResourceManager.DisposeAsset(Quantum.AssetGuid)">
            <summary>
            Schedules an asset for disposal or disposes it immediately.
            </summary>
            <param name="guid">The GUID of the asset to dispose.</param>
            <returns><see langword="true"/> if the asset exists.</returns>
        </member>
        <member name="M:Quantum.IResourceManager.GetAsset(Quantum.AssetGuid)">
            <summary>
            Loads an asset synchronously, blocking until it returns. Before the asset gets returned for the first time,
            the manager needs to have called <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>. 
            </summary>
            <param name="guid">The GUID of the asset to load.</param>
            <returns>The loaded asset object.</returns>
        </member>
        <member name="M:Quantum.IResourceManager.LoadAssetAsync(Quantum.AssetGuid)">
            <summary>
            Preloads an asset. The asset will be loaded asynchronously and will be available for use after the next call to one
            of the GetAsset methods.
            </summary>
            <param name="guid">The GUID of the asset to preload.</param>
            <returns><see langword="true"/> if the asset exists.</returns>
        </member>
        <member name="M:Quantum.IResourceManager.GetAssetGuid(System.String)">
            <summary>
            Converts a path to an asset GUID.
            </summary>
            <param name="path">The path of the asset.</param>
            <returns>The GUID of the asset.</returns>
        </member>
        <member name="M:Quantum.IResourceManager.GetAssetState(Quantum.AssetGuid)">
            <summary>
            Gets the state of an asset.
            </summary>
            <param name="guid">The GUID of the asset.</param>
            <returns>The state of the asset.</returns>
        </member>
        <member name="M:Quantum.IResourceManager.GetAssetType(Quantum.AssetGuid)">
            <summary>
            Gets the type of an asset.
            </summary>
            <param name="guid">The GUID of the asset.</param>
            <returns>The type of the asset.</returns>
        </member>
        <member name="M:Quantum.IResourceManager.FindNextAssetGuid(Quantum.AssetObjectQuery@,Quantum.AssetGuid@)">
            <summary>
            Finds the next asset GUID based on the provided query.
            </summary>
            <param name="query">The query to filter the assets.</param>
            <param name="guid">The GUID of the next asset.</param>
            <returns><see langword="true"/> if there is a next asset.</returns>
        </member>
        <member name="E:Quantum.IResourceManager.AssetObjectDisposing">
            <summary>
            Invoked before <see cref="M:Quantum.AssetObject.Disposed(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>. Exposed as an event, because
            assets may be disposed externally. Any code using any form of asset caching
            needs to be aware of that happening.
            </summary>
        </member>
        <member name="M:Quantum.IResourceManager.Update(System.Boolean,Quantum.Profiling.Profiler@)">
            <summary>
            Called after the simulation has run and all tasks have finished. Always executed by the main Quantum thread.
            </summary>
            <param name="inSimulation"><see langword="true"/> if the update is happening during a simulation.</param>
            <param name="profiler">The profiler used for profiling.</param>
        </member>
        <member name="T:Quantum.AssetObjectDisposingDelegate">
            <summary>
            A delegate that is invoked before an <see cref="T:Quantum.AssetObject"/> is disposed.
            </summary>
            <param name="guid"></param>
        </member>
        <member name="T:Quantum.IResourceManagerExtensions">
            <summary>
            Extension methods for <see cref="T:Quantum.IResourceManager"/>.
            </summary>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.GetAsset``1(``0,Quantum.AssetRef)">
            <summary>
            Returns the asset object of the provided asset reference.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetRef">The asset reference.</param>
            <returns>The loaded asset object or <c>null</c>, if not found.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.TryGetAsset``2(``0,Quantum.AssetGuid,``1@)">
            <summary>
            Tries to get an asset of type T from the resource manager. Note that if type T is not the same as the asset type,
            the asset will remain loaded in the memory until it is disposed.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetGuid">The guid of the asset.</param>
            <param name="result">The result asset object.</param>
            <returns><see langword="true"/> if the asset of type T exists.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.TryGetAsset``2(``0,Quantum.AssetRef,``1@)">
            <summary>
            Tries to get an asset of type T from the resource manager. Note that if type T is not the same as the asset type,
            the asset will remain loaded in the memory until it is disposed.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetRef">The asset reference.</param>
            <param name="result">The result asset object.</param>
            <returns><see langword="true"/> if the asset of type T exists.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.TryGetAsset``2(``0,Quantum.AssetRef{``1},``1@)">
            <summary>
            Tries to get an asset of type T from the resource manager. Note that if type T is not the same as the asset type,
            the asset will remain loaded in the memory until it is disposed.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetRef">The asset reference.</param>
            <param name="result">The result asset object.</param>
            <returns><see langword="true"/> if the asset of type T exists.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.TryGetAsset``2(``0,System.String,``1@)">
            <summary>
            Tries to get an asset of type T from the resource manager. Note that if type T is not the same as the asset type,
            the asset will remain loaded in the memory until it is disposed.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetPath">The path of the asset.</param>
            <param name="result">The result asset object.</param>
            <returns><see langword="true"/> if the asset of type T exists.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.DisposeAsset``1(``0,System.String)">
            <summary>
            Disposes an asset based on its path.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetPath">The path of the asset.</param>
            <returns><see langword="true"/> if the asset is disposed successfully.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.GetAsset``1(``0,System.String)">
            <summary>
            Gets an asset based on its path.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetPath">The path of the asset.</param>
            <returns>The asset object.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.LoadAssetAsync``1(``0,System.String)">
            <summary>
            Loads an asset asynchronously based on its path.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="assetPath">The path of the asset.</param>
            <returns><see langword="true"/> if the asset is loaded successfully.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.FindAssetGuid``1(``0,Quantum.AssetObjectQuery)">
            <summary>
            Finds the asset GUID based on the provided query.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="query">The query to filter the assets.</param>
            <returns>The asset GUID.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.FindAssetGuids``1(``0,Quantum.AssetObjectQuery,System.Collections.Generic.List{Quantum.AssetGuid})">
            <summary>
            Finds the asset GUIDs based on the provided query.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="query">The query to filter the assets.</param>
            <param name="result">The list to store the asset GUIDs.</param>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.FindAssetGuids``1(``0,Quantum.AssetObjectQuery)">
            <summary>
            Finds the asset GUIDs based on the provided query.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="query">The query to filter the assets.</param>
            <returns>The list of asset GUIDs.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.GetAssets``1(``0,Quantum.AssetObjectQuery)">
            <summary>
            Gets the assets based on the provided query.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="query">The query to filter the assets.</param>
            <returns>The list of asset objects.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.GetAssets``1(``0,Quantum.AssetObjectQuery,System.Collections.Generic.List{Quantum.AssetObject})">
            <summary>
            Gets the assets based on the provided query.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <param name="query">The query to filter the assets.</param>
            <param name="result">The list to store the asset objects.</param>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.LoadAllAssets``1(``0)">
            <summary>
            Loads all assets from the resource manager.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <returns>The list of loaded asset objects.</returns>
        </member>
        <member name="M:Quantum.IResourceManagerExtensions.GetAllLoadedAssets``1(``0)">
            <summary>
            Gets all loaded assets from the resource manager.
            </summary>
            <param name="resourceManager">The resource manager.</param>
            <returns>The list of loaded asset objects.</returns>
        </member>
        <member name="T:Quantum.ResourceManagerStatic">
            <summary>
            A static resource manager that can be used to manage assets in a deterministic context. 
            All the assets are known and instantiated ahead of time.
            </summary>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.#ctor(Photon.Deterministic.Native.Allocator,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.ResourceManagerStatic"/> class.
            </summary>
            <param name="allocator">The allocator to use for managing memory.</param>
            <param name="allowDisposals">Whether asset disposals are allowed.</param>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.#ctor(Quantum.AssetObject[],Photon.Deterministic.Native.Allocator,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.ResourceManagerStatic"/> class with assets.
            </summary>
            <param name="assets">The array of assets. Each asset is not considered loaded yet, so accessing them for the first
            time will result with <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> being called</param>
            <param name="allocator">The allocator to use for managing memory.</param>
            <param name="allowDisposals">Whether asset disposals are allowed.</param>
        </member>
        <member name="P:Quantum.ResourceManagerStatic.FallbackResourceManager">
            <summary>
            Gets or sets the fallback resource manager.
            </summary>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.AddAssets(System.Collections.Generic.IEnumerable{Quantum.AssetObject},System.Boolean)">
            <summary>
            Adds a collection of assets to the resource manager.
            </summary>
            <param name="assets">The collection of assets to add.</param>
            <param name="areLoaded">Whether the assets are already loaded. If <see langword="false"/>, accessing them for the first time
            will result with <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> being called</param>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.AddAsset(Quantum.AssetObject,System.Boolean)">
            <summary>
            Adds an asset to the resource manager.
            </summary>
            <param name="asset">The asset to add.</param>
            <param name="isLoaded">Whether the asset is already loaded. If <see langword="false"/>, accessing it for the first time
            will result with <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> being called</param>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.Dispose">
            <summary>
            Disposes the resource manager and all its assets.
            </summary>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.DisposeAsset(Quantum.AssetGuid)">
            <summary>
            Enqueues the asset with the specified GUID for disposal. The actual disposal will happen in the next call to <see cref="M:Quantum.ResourceManagerStatic.Update(System.Boolean,Quantum.Profiling.Profiler@)"/> from the main thread.
            </summary>
            <param name="guid">The GUID of the asset to dispose.</param>
            <returns><see langword="true"/> if the asset was enqueued for disposal.</returns>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.GetAsset(Quantum.AssetGuid)">
            <summary>
            Gets the asset with the specified GUID.
            </summary>
            <param name="guid">The GUID of the asset to get.</param>
            <returns>The asset with the specified GUID, or <c>null</c> if the asset does not exist.</returns>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.LoadAssetAsync(Quantum.AssetGuid)">
            <summary>
            Loads the asset with the specified GUID asynchronously.
            </summary>
            <param name="guid">The GUID of the asset to load.</param>
            <returns><see langword="true"/> if the asset exists; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.GetAssetGuid(System.String)">
            <summary>
            Gets the GUID of the asset with the specified path.
            </summary>
            <param name="path">The path of the asset.</param>
            <returns>The GUID of the asset with the specified path, or <see cref="F:Quantum.AssetGuid.Invalid"/> if the asset does not exist.</returns>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.GetAssetType(Quantum.AssetGuid)">
            <summary>
            Gets the type of the asset with the specified GUID.
            </summary>
            <param name="guid">The GUID of the asset.</param>
            <returns>The type of the asset with the specified GUID, or <c>null</c> if the asset does not exist.</returns>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.FindNextAssetGuid(Quantum.AssetObjectQuery@,Quantum.AssetGuid@)">
            <summary>
            Finds the next asset GUID that matches the specified query.
            </summary>
            <param name="query">The query to match.</param>
            <param name="guid">The GUID of the next matching asset.</param>
            <returns><see langword="true"/> if a matching asset was found; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.Update(System.Boolean,Quantum.Profiling.Profiler@)">
            <summary>
            Updates the resource manager.
            </summary>
            <param name="inSimulation">Whether the update is happening in a simulation context.</param>
            <param name="profiler">The profiler to use for profiling.</param>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.GetAssetState(Quantum.AssetGuid)">
            <summary>
            Gets the state of the asset with the specified GUID.
            </summary>
            <param name="guid">The GUID of the asset.</param>
            <returns>The state of the asset with the specified GUID, or <see cref="F:Quantum.AssetObjectState.NotFound"/> if the asset does not exist.</returns>
        </member>
        <member name="M:Quantum.ResourceManagerStatic.ProcessDisposals">
            <summary>
            Processes asset disposals.
            </summary>
        </member>
        <member name="T:Quantum.IAssetSerializer">
            <summary>
            Represents a serializer that handles assets and various configuration objects.
            </summary>
        </member>
        <member name="M:Quantum.IAssetSerializer.SerializeConfig(System.IO.Stream,Quantum.IRuntimeConfig)">
            <summary>
            Serializes the runtime configuration to the specified stream.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="config">The runtime configuration to serialize.</param>
        </member>
        <member name="M:Quantum.IAssetSerializer.SerializePlayer(System.IO.Stream,Quantum.IRuntimePlayer)">
            <summary>
            Serializes the runtime player to the specified stream.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="player">The runtime player to serialize.</param>
        </member>
        <member name="M:Quantum.IAssetSerializer.SerializeAssets(System.IO.Stream,Quantum.AssetObject[])">
            <summary>
            Serializes an array of asset objects to the specified stream.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="assets">The array of asset objects to serialize.</param>
        </member>
        <member name="M:Quantum.IAssetSerializer.SerializeResult(System.IO.Stream,Quantum.IGameResult)">
            <summary>
            Serializes the game result to the specified stream.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="result">The game result to serialize.</param>
        </member>
        <member name="M:Quantum.IAssetSerializer.DeserializeConfig(System.IO.Stream)">
            <summary>
            Deserializes the runtime configuration from the specified stream.
            </summary>
            <param name="stream">The stream to deserialize from.</param>
            <returns>The deserialized runtime configuration.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializer.DeserializePlayer(System.IO.Stream)">
            <summary>
            Deserializes the runtime player from the specified stream.
            </summary>
            <param name="stream">The stream to deserialize from.</param>
            <returns>The deserialized runtime player.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializer.DeserializeAssets(System.IO.Stream)">
            <summary>
            Deserializes an array of asset objects from the specified stream.
            </summary>
            <param name="stream">The stream to deserialize from.</param>
            <returns>The deserialized array of asset objects.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializer.DeserializeResult(System.IO.Stream)">
            <summary>
            Deserializes the game result from the specified stream.
            </summary>
            <param name="stream">The stream to deserialize from.</param>
            <returns>The deserialized game result.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializer.PrintObject(System.Object)">
            <summary>
            Prints the string representation of an object.
            </summary>
            <param name="obj">The object to print.</param>
            <returns>The string representation of the object.</returns>
        </member>
        <member name="T:Quantum.IAssetSerializerExtensions">
            <summary>
            An extension class for <see cref="T:Quantum.IAssetSerializer"/>.
            </summary>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.SerializeConfig``1(Quantum.IAssetSerializer,Photon.Deterministic.BitStream,``0)">
            <summary>
            Serializes the runtime configuration to a <see cref="T:Photon.Deterministic.BitStream"/>. Handles <see langword="null"/> values.
            </summary>
            <typeparam name="T">The type of the runtime configuration.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="bitStream">The bit stream to serialize to.</param>
            <param name="config">The runtime configuration to serialize.</param>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.DeserializeConfig``1(Quantum.IAssetSerializer,Photon.Deterministic.BitStream)">
            <summary>
            Deserializes the runtime configuration from a <see cref="T:Photon.Deterministic.BitStream"/>. May return <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the runtime configuration.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="bitStream">The bit stream to deserialize from.</param>
            <returns>The deserialized runtime configuration.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.CloneConfig``1(Quantum.IAssetSerializer,``0)">
            <summary>
            Clones the runtime configuration.
            </summary>
            <typeparam name="T">The type of the runtime configuration.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="obj">The runtime configuration to clone.</param>
            <returns>A cloned instance of the runtime configuration.</returns>
            <remarks>
            This method clones the specified runtime configuration by serializing it to a memory stream and then deserializing it back.
            </remarks>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.ConfigToByteArray``1(Quantum.IAssetSerializer,``0,System.Boolean)">
            <summary>
            Converts the runtime configuration to a byte array.
            </summary>
            <typeparam name="T">The type of the runtime configuration.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="obj">The runtime configuration to convert.</param>
            <param name="compress">Specifies whether to compress the byte array.</param>
            <returns>A byte array representation of the runtime configuration.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.ConfigFromByteArray``1(Quantum.IAssetSerializer,System.Byte[],System.Boolean)">
            <summary>
            Deserializes the runtime configuration from a byte array. May return <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the runtime configuration.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <param name="compressed">Specifies whether the byte array is compressed.</param>
            <returns>The deserialized runtime configuration.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.ConfigFromByteArray``1(Quantum.IAssetSerializer,System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Deserializes the runtime configuration from a byte array with specified offset and length.
            </summary>
            <typeparam name="T">The type of the runtime configuration.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <param name="offset">The starting offset in the byte array.</param>
            <param name="length">The length of the data to deserialize.</param>
            <param name="compressed">Specifies whether the byte array is compressed.</param>
            <returns>The deserialized runtime configuration.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.SerializePlayer``1(Quantum.IAssetSerializer,Photon.Deterministic.BitStream,``0)">
            <summary>
            Serializes the runtime player to a <see cref="T:Photon.Deterministic.BitStream"/>. Handles <see langword="null"/> values.
            </summary>
            <typeparam name="T">The type of the runtime player.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="bitStream">The bit stream to serialize to.</param>
            <param name="player">The runtime player to serialize.</param>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.DeserializePlayer``1(Quantum.IAssetSerializer,Photon.Deterministic.BitStream)">
            <summary>
            Deserializes the runtime player from a <see cref="T:Photon.Deterministic.BitStream"/>. May return <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the runtime player.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="bitStream">The bit stream to deserialize from.</param>
            <returns>The deserialized runtime player.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.ClonePlayer``1(Quantum.IAssetSerializer,``0)">
            <summary>
            Clones the runtime player.
            </summary>
            <typeparam name="T">The type of the runtime player.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="obj">The runtime player to clone.</param>
            <returns>A cloned instance of the runtime player.</returns>
            <remarks>
            This method clones the specified runtime player by serializing it to a memory stream and then deserializing it back.
            </remarks>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.PlayerToByteArray``1(Quantum.IAssetSerializer,``0,System.Boolean)">
            <summary>
            Converts the runtime player to a byte array.
            </summary>
            <typeparam name="T">The type of the runtime player.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="obj">The runtime player to convert.</param>
            <param name="compress">Specifies whether to compress the byte array.</param>
            <returns>A byte array representation of the runtime player.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.PlayerFromByteArray``1(Quantum.IAssetSerializer,System.Byte[],System.Boolean)">
            <summary>
            Deserializes the runtime player from a byte array. May return <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the runtime player.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <param name="compressed">Specifies whether the byte array is compressed.</param>
            <returns>The deserialized runtime player.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.PlayerFromByteArray``1(Quantum.IAssetSerializer,System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Deserializes the runtime player from a byte array with specified offset and length.
            </summary>
            <typeparam name="T">The type of the runtime player.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <param name="offset">The starting offset in the byte array.</param>
            <param name="length">The length of the data to deserialize.</param>
            <param name="compressed">Specifies whether the byte array is compressed.</param>
            <returns>The deserialized runtime player.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.ResultToByteArray``1(Quantum.IAssetSerializer,``0,System.Boolean)">
            <summary>
            Converts the game result to a byte array.
            </summary>
            <typeparam name="T">The type of the game result.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="obj">The game result to convert.</param>
            <param name="compress">Specifies whether to compress the byte array.</param>
            <returns>A byte array representation of the game result.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.ResultFromByteArray``1(Quantum.IAssetSerializer,System.Byte[],System.Boolean)">
            <summary>
            Deserializes the game result from a byte array. May return <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the game result.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <param name="compressed">Specifies whether the byte array is compressed.</param>
            <returns>The deserialized game result.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.ResultFromByteArray``1(Quantum.IAssetSerializer,System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Deserializes the game result from a byte array with specified offset and length.
            </summary>
            <typeparam name="T">The type of the game result.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <param name="offset">The starting offset in the byte array.</param>
            <param name="length">The length of the data to deserialize.</param>
            <param name="compressed">Specifies whether the byte array is compressed.</param>
            <returns>The deserialized game result.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.AssetsFromByteArray(Quantum.IAssetSerializer,System.Byte[])">
            <summary>
            Deserializes an array of asset objects from the specified byte array.
            </summary>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <returns>An array of asset objects.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.AssetsToByteArray(Quantum.IAssetSerializer,Quantum.AssetObject[])">
            <summary>
            Converts an array of assets to a byte array.
            </summary>
            <param name="serializer">The asset serializer.</param>
            <param name="assets">The array of asset objects to serialize.</param>
            <returns>A byte array representation ofthe asset array.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.AssetFromByteArray``1(Quantum.IAssetSerializer,System.Byte[])">
            <summary>
            Deserializes a single asset from the specified byte array.
            </summary>
            <typeparam name="T">The type of the asset object.</typeparam>
            <param name="serializer">The asset serializer.</param>
            <param name="data">The byte array to deserialize from.</param>
            <returns>The deserialized asset object.</returns>
        </member>
        <member name="M:Quantum.IAssetSerializerExtensions.AssetToByteArray(Quantum.IAssetSerializer,Quantum.AssetObject)">
            <summary>
            Converts an asset object to a byte array.
            </summary>
            <param name="serializer">The asset serializer.</param>
            <param name="asset">The asset object to serialize.</param>
            <returns>A byte array representation of the asset.</returns>
        </member>
        <member name="T:Quantum.IGameResult">
            <summary>
            Represents the result of a game.
            </summary>
        </member>
        <member name="T:Quantum.IRuntimeConfig">
            <summary>
            Represents the runtime configuration for the Quantum engine.
            </summary>
        </member>
        <member name="T:Quantum.IRuntimePlayer">
            <summary>
            Represents a runtime player.
            </summary>
        </member>
        <member name="T:Quantum.DictionaryAttribute">
            <summary>
            Represents an attribute that can be applied to a field to indicate that it is a dictionary property.
            </summary>
        </member>
        <member name="T:Quantum.DynamicCollectionAttribute">
            <summary>
            Marks a collection field as source for a Quantum heap-based collection. Automatically applied by CodeGen.
            </summary>
        </member>
        <member name="T:Quantum.LastSupportedVersionAttribute">
            <summary>
            Marks the last Quantum version that supports the attributed type/method/property/field.
            </summary>
        </member>
        <member name="M:Quantum.LastSupportedVersionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.LastSupportedVersionAttribute"/> class with the specified version.
            </summary>
            <param name="version">The last supported version.</param>
        </member>
        <member name="T:Quantum.LocalReferenceAttribute">
            <summary>
            Marks a field as a reference to a local object. In Unity, a local object is an object from the same scene or prefab. 
            Automatically applied by CodeGen.
            </summary>
        </member>
        <member name="T:Quantum.OptionalAttribute">
            <summary>
            Marks a field as optional. In Unity, the path passed will serve as the toggle to enable/disable.
            </summary>
        </member>
        <member name="M:Quantum.OptionalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.OptionalAttribute"/> class.
            </summary>
            <param name="enabledPropertyPath">The path to the property that serves as the toggle to enable/disable.</param>
        </member>
        <member name="P:Quantum.OptionalAttribute.EnabledPropertyPath">
            <summary>
            Gets the path to the property that serves as the toggle to enable/disable.
            </summary>
        </member>
        <member name="T:Quantum.Rotation2DAttribute">
            <summary>
            Marks a FP/NullableFP field as a 2D rotation angle.
            </summary>
        </member>
        <member name="T:Quantum.Core.FieldOverlapAttribute">
            <summary>
            Marks fields that overlap with other fields in the same struct. Used during memory verification.
            Applied automatically in unions.
            </summary>
            <param name="offset">Offset of the overlapping field</param>
        </member>
        <member name="M:Quantum.Core.FieldOverlapAttribute.#ctor(System.Int32)">
            <summary>
            Marks fields that overlap with other fields in the same struct. Used during memory verification.
            Applied automatically in unions.
            </summary>
            <param name="offset">Offset of the overlapping field</param>
        </member>
        <member name="P:Quantum.Core.FieldOverlapAttribute.Offset">
            <summary>
            Offset of the overlapping field.
            </summary>
        </member>
        <member name="T:Quantum.Core.PreserveInPrototypeAttribute">
            <summary>
            Instructs the CodeGen to keep a field/type/enum AS IS in the generated prototype.
            Can be used to avoid extra proxy types if the simulation type is already Unity-serializable.
            </summary>
        </member>
        <member name="T:Quantum.Core.ExcludeFromPrototypeAttribute">
            <summary>
            Instructs the CodeGen to exclude a field/type/enum from the generated prototype. If applied to a type,
            none of the fields that use this type will be included in the prototype.
            </summary>
        </member>
        <member name="T:Quantum.Core.OnlyInPrototypeAttribute">
            <summary>
            Applied on a field prevents it being emit into state object.
            </summary>
        </member>
        <member name="T:Quantum.Core.FixedBufferDynamicLengthAttribute">
            <summary>
            Points to a field that contains the length of a fixed buffer in bytes. If used, the CodeGen will generate
            serialization code that reads/writes the buffer using the specified length, not the entire capacity of the buffer.
            </summary>
            <param name="lengthSource">Field that will be used as the buffer's length</param>
        </member>
        <member name="M:Quantum.Core.FixedBufferDynamicLengthAttribute.#ctor(System.String)">
            <summary>
            Points to a field that contains the length of a fixed buffer in bytes. If used, the CodeGen will generate
            serialization code that reads/writes the buffer using the specified length, not the entire capacity of the buffer.
            </summary>
            <param name="lengthSource">Field that will be used as the buffer's length</param>
        </member>
        <member name="P:Quantum.Core.FixedBufferDynamicLengthAttribute.LengthSource">
            <summary>
            Name of the field that contains the buffer's length.
            </summary>
        </member>
        <member name="T:Quantum.Core.ReplaceTypeHintAttribute">
            <summary>
            Instructs the CodeGen to replace a type in the generated prototype with a different type.
            </summary>
            <param name="hint">Replacement type</param>
            <param name="generator"></param>
        </member>
        <member name="M:Quantum.Core.ReplaceTypeHintAttribute.#ctor(System.String,System.String)">
            <summary>
            Instructs the CodeGen to replace a type in the generated prototype with a different type.
            </summary>
            <param name="hint">Replacement type</param>
            <param name="generator"></param>
        </member>
        <member name="P:Quantum.Core.ReplaceTypeHintAttribute.Hint">
            <summary>
            Replacement type.
            </summary>
        </member>
        <member name="T:Quantum.Core.RequireComponentAttribute">
            <summary>
            If applied on a component type, instructs the CodeGen to emit UnityEngine.RequireComponent attribute on the QPrototype wrapper.
            If applied on `entity_ref` field, instructs the CodeGen to emit QPrototype wrapper reference instead of QuantumEntityPrototype reference.
            </summary>
            <param name="types">Types of required components</param>
        </member>
        <member name="M:Quantum.Core.RequireComponentAttribute.#ctor(System.Type[])">
            <summary>
            If applied on a component type, instructs the CodeGen to emit UnityEngine.RequireComponent attribute on the QPrototype wrapper.
            If applied on `entity_ref` field, instructs the CodeGen to emit QPrototype wrapper reference instead of QuantumEntityPrototype reference.
            </summary>
            <param name="types">Types of required components</param>
        </member>
        <member name="P:Quantum.Core.RequireComponentAttribute.Types">
            <summary>
            Types of required components.
            </summary>
        </member>
        <member name="T:Quantum.Core.UnionAttribute">
            <summary>
            Automatically applied to all union types.
            </summary>
        </member>
        <member name="T:Quantum.Core.AllocateOnComponentAddedAttribute">
            <summary>
            If applied on a collection field, instructs the CodeGen to allocate the collection when the owning component is added to an entity.
            The field can belong to the component or to any struct or union nested within (both as a regular field or as a collection's element).
            </summary>
            <remarks>
            Use together with <seealso cref="T:Quantum.Core.FreeOnComponentRemovedAttribute"/> to avoid memory leaks.
            </remarks>
            <param name="capacity">The initial capacity of the allocated collection.</param>
        </member>
        <member name="M:Quantum.Core.AllocateOnComponentAddedAttribute.#ctor(System.Int32)">
            <summary>
            If applied on a collection field, instructs the CodeGen to allocate the collection when the owning component is added to an entity.
            The field can belong to the component or to any struct or union nested within (both as a regular field or as a collection's element).
            </summary>
            <remarks>
            Use together with <seealso cref="T:Quantum.Core.FreeOnComponentRemovedAttribute"/> to avoid memory leaks.
            </remarks>
            <param name="capacity">The initial capacity of the allocated collection.</param>
        </member>
        <member name="P:Quantum.Core.AllocateOnComponentAddedAttribute.Capacity">
            <summary>
            The initial capacity of the allocated collection.
            </summary>
        </member>
        <member name="T:Quantum.Core.FreeOnComponentRemovedAttribute">
            <summary>
            If applied on a collection field, instructs the CodeGen to free the collection when the owning component is removed from an entity.
            The field can belong to the component or to any struct or union nested within (both as a regular field or as a collection's element).
            </summary>
            <seealso cref="T:Quantum.Core.AllocateOnComponentAddedAttribute"/>
        </member>
        <member name="T:Quantum.Core.DontClearOnComponentRemovedAttribute">
            <summary>
            If applied on a collection field, instructs the CodeGen to not nullify it when the owning component is removed from an entity. By default
            all collection fields are cleared upon component being removed.
            </summary>
            <seealso cref="T:Quantum.Core.AllocateOnComponentAddedAttribute"/>
            <seealso cref="T:Quantum.Core.FreeOnComponentRemovedAttribute"/>
        </member>
        <member name="T:Quantum.Core.EmitFixedArrayAttribute">
            <summary>
            By default, arrays of integer types are emit as fixed-size buffers, whereas arrays of other types are emitted as <see cref="T:Quantum.FixedArray`1"/>.
            Using this attribute, he CodeGen will emit the array as <see cref="T:Quantum.FixedArray`1"/> regardless of the element type.
            </summary>
        </member>
        <member name="T:Quantum.Core.DerivedStructAttribute">
            <summary>
            Automatically applied to a struct that uses CodeGen-based inheritance.
            </summary>
            <param name="types">Types from which this the current type is derived from</param>
        </member>
        <member name="M:Quantum.Core.DerivedStructAttribute.#ctor(System.Type[])">
            <summary>
            Automatically applied to a struct that uses CodeGen-based inheritance.
            </summary>
            <param name="types">Types from which this the current type is derived from</param>
        </member>
        <member name="P:Quantum.Core.DerivedStructAttribute.Types">
            <summary>
            Types from which this the current type is derived from.
            </summary>
        </member>
        <member name="T:Quantum.Core.PtrSizeAttribute">
            <summary>
            Indicates that the field is a pointer to a memory block of a specific size. This enables the CodeGen to generate appropriate serialization code.
            Without it, only the pointer itself is serialized.
            </summary>
        </member>
        <member name="M:Quantum.Core.PtrSizeAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="size">Size in bytes</param>
        </member>
        <member name="M:Quantum.Core.PtrSizeAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="snippet">Code snippet used to get the size in bytes</param>
        </member>
        <member name="P:Quantum.Core.PtrSizeAttribute.Size">
            <summary>
            Size in bytes.
            </summary>
        </member>
        <member name="P:Quantum.Core.PtrSizeAttribute.Snippet">
            <summary>
            Code snippet used to get the size in bytes.
            </summary>
        </member>
        <member name="T:Quantum.Core.FormerlyNamedAttribute">
            <summary>
            Applies UnityEngine.Scripting.APIUpdating.MovedFromAttribute attribute to the type.  This can preserve value of [SerializeReference] fields
            that reference an instance of the type. Additionally, if applied on a component, CodeGen will try to reuse the previous .meta file.
            Note that this attribute can only be applied once, unlike UnityEngine.Serialization.FormerlySerializedAsAttribute.
            </summary>
            <param name="name">Former name of the field</param>
        </member>
        <member name="M:Quantum.Core.FormerlyNamedAttribute.#ctor(System.String)">
            <summary>
            Applies UnityEngine.Scripting.APIUpdating.MovedFromAttribute attribute to the type.  This can preserve value of [SerializeReference] fields
            that reference an instance of the type. Additionally, if applied on a component, CodeGen will try to reuse the previous .meta file.
            Note that this attribute can only be applied once, unlike UnityEngine.Serialization.FormerlySerializedAsAttribute.
            </summary>
            <param name="name">Former name of the field</param>
        </member>
        <member name="P:Quantum.Core.FormerlyNamedAttribute.Name">
            <summary>
            Former name of the type.
            </summary>
        </member>
        <member name="T:Quantum.Core.FrameBase">
            <summary>
             The Frame class is the container for all the transient and static game state data, including the API for entities, physics, assets and others.
            </summary>
            The reason for this is that Systems must be stateless to comply with Quantum's predict/rollback model. Quantum only guarantees determinism if all game state data is fully contained in the Frame class.
            \ingroup FrameClass
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``1(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``2(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <typeparam name="T1">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``3(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <typeparam name="T1">Filter component type</typeparam>
            <typeparam name="T2">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``4(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <typeparam name="T1">Filter component type</typeparam>
            <typeparam name="T2">Filter component type</typeparam>
            <typeparam name="T3">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``5(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <typeparam name="T1">Filter component type</typeparam>
            <typeparam name="T2">Filter component type</typeparam>
            <typeparam name="T3">Filter component type</typeparam>
            <typeparam name="T4">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``6(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <typeparam name="T1">Filter component type</typeparam>
            <typeparam name="T2">Filter component type</typeparam>
            <typeparam name="T3">Filter component type</typeparam>
            <typeparam name="T4">Filter component type</typeparam>
            <typeparam name="T5">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``7(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <typeparam name="T1">Filter component type</typeparam>
            <typeparam name="T2">Filter component type</typeparam>
            <typeparam name="T3">Filter component type</typeparam>
            <typeparam name="T4">Filter component type</typeparam>
            <typeparam name="T5">Filter component type</typeparam>
            <typeparam name="T6">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Filter``8(Quantum.ComponentSet,Quantum.ComponentSet)">
            <summary>
            Filter entities by component types.
            </summary> 
            <typeparam name="T0">Filter component type</typeparam>
            <typeparam name="T1">Filter component type</typeparam>
            <typeparam name="T2">Filter component type</typeparam>
            <typeparam name="T3">Filter component type</typeparam>
            <typeparam name="T4">Filter component type</typeparam>
            <typeparam name="T5">Filter component type</typeparam>
            <typeparam name="T6">Filter component type</typeparam>
            <typeparam name="T7">Filter component type</typeparam>
            <param name="without">Components that should not be present</param>
            <param name="any">Components that should be present</param>
        </member>
        <member name="T:Quantum.Core.FrameBase.EntitiesConfig">
            <summary>
            Global entities configuration
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.CommitCommandsMode">
            <summary>
            When "remove component" and "destroy entity" commands should be committed, effectively cleaning and freeing the data from components' buffers.
            <remarks>Both commands still take immediate effect from a semantic perspective, e.g.: checking if the entity exists will return <see langword="false"/> as soon as the "destroy entity" method is called.</remarks>
            <remarks>Commiting commands on <see cref="F:Quantum.CommitCommandsModes.OnFrameSimulationBegin"/> will ensure that performing Physics Queries is safe, even after the frame simulation ends (from Unity),
            but might result in a larger total amount of memory reserved in case many entities are destroyed AND created in the same frame (analogous for "component removal").</remarks>
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.DefaultEntityCapacity">
            <summary>
            The starting capacity of internal entity and component buffers. Default is 1024.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.DefaultComponentBlockCapacity">
            <summary>
            Default value for how many components are stored together in a continuous block of memory. Default is 128.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.EntitiesConfig.ComponentTypeConfiguration">
            <summary>
            Allows overriding config values on a per-component level
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.PhysicsSceneSettings">
            <summary>
            Represents the current physics scene settings.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.Map">
            <summary>
            The current loaded map asset.
            <seealso cref="T:Quantum.Map"/>
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.NavMeshRegionMask">
            <summary>
            Represents a mask used to define regions on a NavMesh.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.DynamicAssetDB">
            <summary>
            The Asset Database for Dynamic Assets.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.Unsafe">
            <inheritdoc cref="T:Quantum.Core.FrameBase.FrameBaseUnsafe"/>
        </member>
        <member name="F:Quantum.Core.FrameBase.Physics2D">
            <summary>
            Access to the Physics2D API.
            </summary>
            \ingroup FrameClass
        </member>
        <member name="F:Quantum.Core.FrameBase.Physics3D">
            <summary>
            Access to the Physics3D API.
            </summary>
            \ingroup FrameClass
        </member>
        <member name="P:Quantum.Core.FrameBase.Navigation">
            <summary>
            Access to the Navigation API.
            </summary>
            \ingroup FrameClass
        </member>
        <member name="P:Quantum.Core.FrameBase.Layers">
            <summary>
            Access to the Layer API.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.UpdateRate">
            <summary>
            The current frame update rate.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.DeltaTime">
            <summary>
            Gets or sets the delta time of the frame.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.Context">
            <summary>
            Access to the FrameContext.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameBase.Heap">
            <summary>
            Gets the heap used by the frame.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameBase.IsPlayerVerifiedOrLocal(Quantum.PlayerRef)">
            <summary>
            Returns information to deterministically cull simulation code (e.g. commands).
            </summary>
            <param name="player">Player ref</param>
            <returns><see langword="true"/> on every verified frame or when the player is a local player.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.GetMemoryStats">
            <summary>
            Calculates the memory statistics for the current frame.
            </summary>
            <returns>A structure containing the heap stats, entity count, and entity total memory.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.OnFrameSimulateBegin">
            <summary>
            Executes the necessary operations at the beginning of simulating a frame.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameBase.OnFrameSimulateEnd">
            <summary>
            Performs actions at the end of frame simulation.
            </summary>
            <remarks>
            If the <see cref="P:Quantum.Core.FrameBase.CommitCommandsMode"/> is set to <see cref="F:Quantum.CommitCommandsModes.OnFrameSimulationEnd"/>, this method commits all commands.
            </remarks>
        </member>
        <member name="M:Quantum.Core.FrameBase.IsPredictionCulled(Quantum.EntityRef)">
            <summary>
            If the entity is prediction-culled.
            </summary>
            <param name="entityRef">The reference of the entity being checked.</param>
            <returns><see langword="true"/> if the frame <see cref="P:Photon.Deterministic.DeterministicFrame.IsPredicted">is predicted</see>
            and the entity <see cref="M:Quantum.Core.FrameBase.IsCulled(Quantum.EntityRef)">is culled</see>. <see langword="false"/> otherwise.</returns>
            \ingroup Culling
        </member>
        <member name="M:Quantum.Core.FrameBase.ComponentCount``1(System.Boolean)">
            <summary>
            Gets the total count of T components
            </summary>
            <param name="includePendingRemoval">
            If the component entries that were removed but are not yet committed in memory should be considered.
            </param>
            <typeparam name="T">The component type</typeparam>
            <returns>Total count</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.ComponentCount(System.Int32,System.Boolean)">
            <summary>
            Gets the total count of components of a given index.
            See <see cref="T:Quantum.ComponentTypeId"/> and <see cref="T:Quantum.ComponentTypeId`1"/> to have access to component types metadata.
            </summary>
            <param name="includePendingRemoval">
            If the component entries that were removed but are not yet committed in memory should be considered.
            </param>
            <param name="componentIndex">The index of the component type</param>
            <returns>Total count</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef)">
            <summary>
            Adds a default component to an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when entity already has a component of the given type</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Has(Quantum.EntityRef,Quantum.ComponentSet)">
            <summary>
            Checks if the entity contains a whole set of components.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="set">Set of component types</param>
            <returns><see langword="true"/> if the entity has all component types</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.AddAsset(Quantum.AssetObject)">
            <summary>
            Adds a dynamic asset to the frame. 
            Dynamic Asset DB generates and assigns Guids for dynamic assets, so <paramref name="asset"/> can not
            have <see cref="P:Quantum.AssetObject.Guid"/> set before calling this method.
            </summary>
            <param name="asset">Asset object</param>
            <returns>Asset id</returns>
            <example><code>
            PhysicsMaterial material = new PhysicsMaterial {
              Restitution = 1,
              FrictionCombineFunction = PhysicsCombineFunction.Average,
              RestitutionCombineFunction = PhysicsCombineFunction.Average };
            var assetId = f.AddAsset(material);
            </code></example>
        </member>
        <member name="M:Quantum.Core.FrameBase.AddAsset(Quantum.AssetObject,Quantum.AssetGuid)">
            <summary>
            Adds a dynamic asset to the frame with a guid know ahead of time.
            Dynamic Asset DB assigns Guids for dynamic assets, so <paramref name="asset"/> can not
            have <see cref="P:Quantum.AssetObject.Guid"/> set before calling this method.
            </summary>
            <param name="asset">Asset object</param>
            <param name="guid">A guid to be assigned. Needs to be of <see cref="F:Quantum.AssetGuidType.DynamicExplicit"/> type</param>
            <example><code>
            PhysicsMaterial material = new PhysicsMaterial {
              Restitution = 1,
              FrictionCombineFunction = PhysicsCombineFunction.Average,
              RestitutionCombineFunction = PhysicsCombineFunction.Average };
            f.AddAsset(material, new AssetGuid(1234, AssetGuidType.DynamicExplicit));
            </code></example>
        </member>
        <member name="M:Quantum.Core.FrameBase.ReplaceAsset(Quantum.AssetGuid,Quantum.AssetObject)">
            <summary>
            Replaces a dynamic asset in the frame. 
            Asset <paramref name="asset"/> can not have <see cref="P:Quantum.AssetObject.Path"/> or <see cref="P:Quantum.AssetObject.Guid"/>
            set as it inherits both from the original asset.
            </summary>
            <param name="guid">Guid of an asset to be replaced</param>
            <param name="asset">Asset object</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.LoadAsset(Quantum.AssetGuid)">
            <summary>
            Loads an asset asynchronously into memory.
            </summary>
            <param name="guid">Asset guid</param>
            Typically assets are loaded on demand. Use this method to preload assets.
        </member>
        <member name="M:Quantum.Core.FrameBase.DisposeAsset(Quantum.AssetGuid)">
            <summary>
            Disposes an asset.
            </summary>
            <param name="guid">Asset guid</param>
            The actual releasing of the asset is postponed and usually is triggered from the main thread at a later time.
        </member>
        <member name="M:Quantum.Core.FrameBase.DisposeAsset(System.String,Quantum.DatabaseType)">
            <summary>
            Disposes an asset.
            </summary>
            <param name="path">Unique asset path</param>
            <param name="dbType"></param>
            The actual releasing of the asset is postponed and usually is triggered from the main thread at a later time.
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetGuid)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="guid">Asset guid</param>
            <returns>Null if guid is not valid or not found, otherwise the requested asset object</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetRef)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <returns>Null if reference is not valid or not found, otherwise the requested asset object</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetRef,``0@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <param name="asset">Null if reference is not valid or not found, otherwise the requested asset object.</param>
            <returns><see langword="true"/> if guid is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetRef{``0})">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <returns>Null if reference is not valid or not found, otherwise the requested asset object</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetGuid,``0@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="guid">Asset guid</param>
            <param name="asset">Null if guid is not valid or not found, otherwise the requested asset object</param>
            <returns><see langword="true"/> if guid is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetRef,``0@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <param name="asset">Null if reference is not valid or not found, otherwise the requested asset object</param>
            <returns><see langword="true"/> if reference is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetRef{``0},``0@)">
            <summary>
            Retrieves an asset either from the asset database or as an dynamic asset.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="assetRef">Asset reference</param>
            <param name="asset">Null if reference is not valid or not found, otherwise the requested asset object</param>
            <returns><see langword="true"/> if reference is valid and an asset is found</returns>    
        </member>
        <member name="M:Quantum.Core.FrameBase.FindAsset``1(System.String,Quantum.DatabaseType)">
            <summary>
            Retrieves an asset by path from selected databases. In case of a missing asset
            logs a warning.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="path">Unique asset path</param>
            <param name="dbType">Type of the database to look in (AssetDB by default)</param>
            <returns>Null if the asset path can not be found, otherwise the requested asset object</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFindAsset``1(System.String,``0@,Quantum.DatabaseType)">
            <summary>
            Retrieves an asset by path from selected databases.
            </summary>
            <typeparam name="T">Asset type</typeparam>
            <param name="path">Unique asset path</param>
            <param name="asset">Null if the path is not valid or not found, otherwise the requested asset object</param>
            <param name="dbType">Type of the database to look in (AssetDB by default)</param>
            <returns><see langword="true"/> if the path is valid and an asset is found</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindPrototype(Quantum.EntityPrototypeRef)">
            <summary>
            
            </summary>
            <param name="prototypeRef"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindPrototype(Quantum.ComponentPrototypeRef)">
            <summary>
            Finds the ComponentPrototype based on the given ComponentPrototypeRef.
            </summary>
            <param name="prototypeRef">The ComponentPrototypeRef to search for.</param>
            <returns>The ComponentPrototype if found; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindPrototype``1(Quantum.ComponentPrototypeRef)">
            <summary>
            Finds and retrieves a specific component prototype based on the given prototype reference.
            </summary>
            <param name="prototypeRef">The prototype reference of the component.</param>
            <typeparam name="T">The type of the component prototype.</typeparam>
            <returns>The matching component prototype.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the component type does not match the expected type.</exception>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindPrototype``2(``0)">
            <summary>
            Finds a component prototype of type TPrototype given a component prototype reference.
            </summary>
            <param name="prototypeRef">Reference to the component prototype</param>
            <returns>The component prototype of type TPrototype</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FindPrototype``2(``0,``1@)">
            <summary>
            Finds a component prototype using the given prototype reference.
            </summary>
            <typeparam name="TPrototypeRef">The type of the prototype reference.</typeparam>
            <typeparam name="TPrototype">The type of the component prototype.</typeparam>
            <param name="prototypeRef">The prototype reference.</param>
            <param name="prototype">The found component prototype.</param>
            <returns><see langword="true"/> if the component prototype is found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.ClearAllNavMeshRegions">
            <summary>
            If a navmesh region is toggled on/off is saved here. Call this method to reset every region state to be enabled again.
            </summary>
        </member>
        <member name="T:Quantum.Core.FrameBase.Culling">
            <summary>
            The Culling class handles the scheduling of culling tasks.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameBase.Culling.Schedule2D(Quantum.Core.FrameBase,Quantum.Task.TaskHandle)">
            <summary>
            Schedule the 2D culling task for the given frame and task handle.
            </summary>
            <param name="f">The frame to schedule the task for.</param>
            <param name="handle">The task handle to use for dependency tracking.</param>
            <returns>The task handle for the scheduled culling task.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.GetAllEntityRefs(System.Collections.Generic.List{Quantum.EntityRef})">
            <summary>
            Retrieves the references to all entities.
            </summary>
            <param name="result">The list to store the entity references.</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.ClearCulledState">
            <summary>
            Marks all entities as not culled.
            </summary>
            \ingroup Culling
        </member>
        <member name="M:Quantum.Core.FrameBase.Cull(Quantum.EntityRef)">
            <summary>
            Marks a cullable and existing entity as culled.
            If the entity does not <see cref="M:Quantum.Core.FrameBase.Exists(Quantum.EntityRef)">Exist</see> or is not cullable, nothing is done.
            </summary>
            <param name="entityRef">The reference of the entity being culled.</param>
            \ingroup Culling
        </member>
        <member name="M:Quantum.Core.FrameBase.IsCulled(Quantum.EntityRef)">
            <summary>
            If an entity is currently culled from the simulation, regardless of the frame state (Predicted or Verified).
            </summary>
            <param name="entityRef">The reference of the entity being checked.</param>
            <returns><see langword="true"/> if the entity is culled OR does NOT <see cref="M:Quantum.Core.FrameBase.Exists(Quantum.EntityRef)">Exist</see>. <see langword="false"/> otherwise.</returns>
            \ingroup Culling
        </member>
        <member name="M:Quantum.Core.FrameBase.SetCullable(Quantum.EntityRef,System.Boolean)">
            <summary>
            Sets if an existing entity is cullable or not.
            </summary>
            <param name="entityRef">The reference of the entity being set.</param>
            <param name="cullable">If the entity should be cullable (true) or not (false).</param>
            \ingroup Culling
        </member>
        <member name="M:Quantum.Core.FrameBase.IsCullable(Quantum.EntityRef)">
            <summary>
            If an entity can be culled during simulation.
            For instance, used by the prediction culling systems to cull entities outside of the prediction area.
            </summary>
            <param name="entity">The reference of the entity being checked.</param>
            <returns><see langword="true"/> if the entity exists and can be culled. <see langword="false"/> otherwise.</returns>
            \ingroup Culling
        </member>
        <member name="M:Quantum.Core.FrameBase.Exists(Quantum.EntityRef)">
            <summary>
            Checks if an entity is still valid.
            </summary>
            For example handy for when you store the entity as a reference inside other components.
            <param name="entityRef">Entity reference</param>
            <returns><see langword="true"/> if the entity exists</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.GetComponentIterator``1">
            <summary>
            Create a component iterator for all components of one type.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <returns>Component iterator</returns>
            <remarks>Changed components have to be <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/> back.</remarks>
            <remarks>Accessing the component array creates a copy of the component.</remarks>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef,``0)">
            <summary>
            Adds a component to an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            <param name="value">Value of the component to be added</param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of type <typeparamref name="T"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef,``0*@)">
            <summary>
            Adds a component of default value to an entity and returns a pointer to the added component.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            <param name="result">
            A pointer to the component added.
            <see langword="null"/> if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of type <typeparamref name="T"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add``1(Quantum.EntityRef,``0,``0*@)">
            <summary>
            Adds a component of defined value to an entity and returns a pointer to the added component.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity reference</param>
            <param name="value">Value of the component to be added</param>
            <param name="result">
            A pointer to the component added.
            <see langword="null"/> if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of type <typeparamref name="T"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add(Quantum.EntityRef,System.Int32,System.Void*)">
            <summary>
            Adds a component of defined value to an entity
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="value"
            >A pointer to data that should be copied as value to the component added.
            If <see langword="null"/>, the component is added with default value.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of index <paramref name="componentIndex"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add(Quantum.EntityRef,System.Int32,System.Void*@)">
            <summary>
            Adds a component of default value to an entity and returns a pointer to the added component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="result">
            A pointer to the component added.
            <see langword="null"/> if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of index <paramref name="componentIndex"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Add(Quantum.EntityRef,System.Int32,System.Void*,System.Void*@)">
            <summary>
            Adds a component of defined value to an entity and returns a pointer to the added component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="value"
            >A pointer to data that should be copied as value to the component added.
            If <see langword="null"/>, the component is added with default value.
            </param>
            <param name="result">
            A pointer to the component added.
            <see langword="null"/> if the result is not <see cref="F:Quantum.AddResult.ComponentAdded"/>.
            </param>
            <remarks>
            Internally calls <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> and <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns>
            <see cref="F:Quantum.AddResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.AddResult.ComponentAlreadyExists"/> if the <paramref name="entity"/> already has a component of index <paramref name="componentIndex"/>. The value is not set in this case.
            <see cref="F:Quantum.AddResult.ComponentAdded"/> Otherwise, indicating that the component was successfully added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.AddOrGet``1(Quantum.EntityRef,``0*@)">
            <summary>
            Adds a component of default value to an entity (if it does not have that component yet) and gets a pointer to the component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="result">
            A pointer to the component added or already existing.
            <see langword="null"/> if the <paramref name="entity"/> does not exist.
            </param>
            <returns><see langword="false"/> if the entity does not exist and <see langword="true"/> otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.AddOrGet(Quantum.EntityRef,System.Int32,System.Void*@)">
            <summary>
            Adds a component of default value to an entity (if it does not have that component yet) and gets a pointer to the component.
            </summary>
            <param name="entity">Entity reference</param>
            <param name="componentIndex">
            The index of the component to be added.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to retrieve the index of a component type.
            </param>
            <param name="result">A pointer to the component added or already existing. <see langword="null"/> if the <paramref name="entity"/> does not exist.</param>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns><see langword="false"/> if the entity does not exist and <see langword="true"/> otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)">
            <summary>
            Sets a component on an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entity">Entity ref</param>
            <param name="value">Value of the component to be added</param>
            <returns>
            <see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.SetResult.ComponentUpdated"/> if the <paramref name="entity"/> already had a component of type <typeparamref name="T"/> that had is value updated to <paramref name="value"/>.
            <see cref="F:Quantum.SetResult.ComponentAdded"/> Otherwise, indicating that a component with the defined value was added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,System.Int32,System.Void*)">
            <summary>
            Sets a component on an entity.
            </summary>
            <param name="entity">Entity ref</param>
            <param name="componentIndex">
            The index of the component being set.
            See also <see cref="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)"/> or <see cref="F:Quantum.ComponentTypeId`1.Id"/> to get the index of a component.
            </param>
            <param name="value">
            A pointer to data that should be copied as value to the component.
            If <see langword="null"/>, the component is set with default value.
            </param>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns>
            <see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if <paramref name="entity"/> does not exist.
            <see cref="F:Quantum.SetResult.ComponentUpdated"/> if the <paramref name="entity"/> already had a component of index <paramref name="componentIndex"/> that had is value updated to <paramref name="value"/>.
            <see cref="F:Quantum.SetResult.ComponentAdded"/> Otherwise, indicating that a component with the defined value was added to the entity.
            </returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Get``1(Quantum.EntityRef)">
            <summary>
            Gets a component from an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns>Requested component</returns>
            <para>Modified components need to be explicitly written back by using <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>.</para>
            <para>Use <see cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/> to quickly check the entity for component availability.</para>
            <example><code>
            var t = f.Get&lt;Transform2D&gt;(entity);
            t.Position = FPVector2.Zero;
            f.Set(entity, t);
            </code></example>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the component does not exists on entity</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Has(Quantum.EntityRef,System.Int32)">
            <summary>
            Determines whether an entity has a specific component.
            </summary>
            <param name="entityRef">The reference to the entity.</param>
            <param name="componentIndex">The index of the component.</param>
            <returns><see langword="true"/> if the entity has the component, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)">
            <summary>
            Checks if an entity has a component.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns><see langword="true"/> if the component type exists on the entity</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            \ingroup EntityApiT
        </member>
        <member name="M:Quantum.Core.FrameBase.TryGet``1(Quantum.EntityRef,``0@)">
            <summary>
            Gets a component from an entity. Does not throw when the component does not exist.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <param name="value">Requested component</param>
            <returns><see langword="true"/> if the component exists</returns>
            <example><code>
            if (f.TryGet&lt;Transform2D&gt;(entity, out Transform2D t)) {
              t.Position = FPVector2.Zero;
              f.Set(entity, t);
            }
            </code></example>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Remove``1(Quantum.EntityRef)">
            <summary>
            Removes a component from an entity.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns><see langword="false"/> if the <paramref name="entityRef"/> is not valid or the entity does not have a component of type <typeparamref name="T"/>. <see langword="true"/> otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Remove(Quantum.EntityRef,System.Type)">
            <summary>
            Removes a component from an entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="componentType">Component type</param>
            <returns><see langword="false"/> if the <paramref name="entityRef"/> is not valid or the entity does not have a component of type <paramref name="componentType"/>. <see langword="true"/> otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Remove(Quantum.EntityRef,System.Int32)">
            <summary>
            Removes a component from an entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="componentIndex">The index of the component to be removed.</param>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="componentIndex"/> does not identify a valid component.</exception>
            <returns><see langword="false"/> if the <paramref name="entityRef"/> is not valid or the entity does not have a component of index <paramref name="componentIndex"/>. <see langword="true"/> otherwise.</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.GetComponentSet(Quantum.EntityRef)">
            <summary>
            Gets a set of all component types that were added to the entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <returns>A set of all component types that are available on the entity</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.TryGetComponentSet(Quantum.EntityRef,Quantum.ComponentSet@)">
            <summary>
            Gets a set of all component types that were added to the entity.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="set"></param>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.DestroyPending(Quantum.EntityRef)">
            <summary>
            Check if a destroy is pending for this entity
            </summary>
            <param name="entityRef">Entity reference</param>
            <returns><see langword="true"/> of destroy is pending, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.Destroy(Quantum.EntityRef)">
            <summary>
            Destroys the entity and all components that were added to it.
            <remarks>
            The destruction takes immediate effect, i.e., <see cref="M:Quantum.Core.FrameBase.Exists(Quantum.EntityRef)"/> will start to return <see langword="false"/>.
            The old data, however, will remain in memory until destroy/remove commands are committed,
            according to the <see cref="P:Quantum.Core.FrameBase.CommitCommandsMode"/> or manually through <see cref="M:Quantum.Core.FrameBase.FrameBaseUnsafe.CommitAllCommands"/>.
            </remarks>
            </summary>
            <example><code>f.Destroy(entity);</code></example>
            <param name="entityRef"></param>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create(Quantum.AssetRef{Quantum.EntityPrototype})">
            <summary>
            Creates an entity from a prototype asset. This process is also referred to as "prototype materialization".
            </summary>
            <param name="prototype"></param>
            <seealso cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/>
            <returns></returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)">
            <summary>
            Creates an entity from a prototype. This process is also referred to as "prototype materialization". 
            </summary>
            The steps are following:
            1. An empty entity is created.
            2. For each component prototype:
              1. Component prototype is materialized.
              2. Component prototype has MaterializeUser invoked.
              3. Component prototype is added to the entity.
            3. <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/> is invoked.
            <param name="prototype"></param>
            <returns></returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create(Quantum.ComponentPrototypeSet[],Quantum.Map)">
            <summary>
            Creates (materializes) map prototypes. The difference between this method and calling 
            <see cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/> repeatedly is that <see cref="T:Quantum.EntityRef"/> fields 
            get resolved and that <see cref="T:Quantum.MapEntityLink"/> components are added implicitly.
            </summary>
            This is a multi-step process:
            1. An empty entity is created for each prototype
            2. For each entity-prototype pair:
              1. For each component prototype:
                1. Component prototype is materialized.
                2. Component prototype has MaterializeUser invoked.
                3. Component prototype is added to the entity.
              2. <see cref="T:Quantum.MapEntityLink"/> component is added to the entity.
            3. <see cref="!:ISignalOnEntityPrototypeMaterialized"/> is invoked for each entity-prototype pair.
            <param name="prototypes"></param>
            <param name="parentAsset"></param>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.AssetRef{Quantum.EntityPrototype})">
            <summary>
            Adds (materializes) components to an already existing entity.
            </summary>
            <param name="entity"></param>
            <param name="prototype"></param>
            <returns></returns>
            <see cref="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype)"/>
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype)">
            <summary>
            Adds (materializes) components to an already existing entity. If a component already exists,
            it will get completely overwritten, but an error message will be logged. To avoid errors in
            such case use <see cref="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype,Quantum.ComponentSet@)"/> instead.
            </summary>
            The steps are following:
            1. For each component prototype:
              1. Component prototype is materialized.
              2. Component prototype has MaterializeUser invoked.
              3. Component prototype is added to the entity.
            2. <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/> is invoked.
            <param name="entity"></param>
            <param name="prototype"></param>
            <returns><see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if entity does not exist. <see cref="F:Quantum.SetResult.ComponentUpdated"/> if any component has been overwritten, <see cref="F:Quantum.SetResult.ComponentAdded"/> otherwise.</returns>
            <seealso cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/>
            <seealso cref="!:Set(EntityRef, EntityPrototype, out ComponentSet, out ComponentSet)"/>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.AssetRef{Quantum.EntityPrototype},Quantum.ComponentSet@)">
            <summary>
            Adds (materializes) components to an already existing entity.
            </summary>
            <param name="entity"></param>
            <param name="prototype"></param>
            <param name="overwrittenComponents"></param>
            <returns></returns>
            <see cref="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype,Quantum.ComponentSet@)"/>
        </member>
        <member name="M:Quantum.Core.FrameBase.Set(Quantum.EntityRef,Quantum.EntityPrototype,Quantum.ComponentSet@)">
            <summary>
            Adds (materializes) components to an already existing entity. If a component already exists,
            it will get completely overwritten.
            </summary>
            The steps are following:
            1. For each component prototype:
              1. Component prototype is materialized.
              2. Component prototype has MaterializeUser invoked.
              3. Component prototype is added to the entity.
            2. <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/> is invoked.
            <param name="entity"></param>
            <param name="prototype"></param>
            <param name="overwrittenComponents">Components that have been overwritten.</param>
            <returns><see cref="F:Quantum.SetResult.EntityDoesNotExist"/> if entity does not exist. <see cref="F:Quantum.SetResult.ComponentUpdated"/> if any component has been overwritten, <see cref="F:Quantum.SetResult.ComponentAdded"/> otherwise.</returns>
            <seealso cref="M:Quantum.Core.FrameBase.Create(Quantum.EntityPrototype)"/>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.Create">
            <summary>
            Creates an entity that is saved in the game state.
            </summary>
            <returns>Entity reference</returns>
            <example><code>var entity = f.Create();</code></example>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.GetSingleton``1">
            <summary>
            Gets the instance of the specified singleton component.
            </summary>
            <typeparam name="T">The type of the singleton component.</typeparam>
            <returns>The instance of the specified singleton component.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the singleton component is not found.</exception>
        </member>
        <member name="M:Quantum.Core.FrameBase.GetSingletonEntityRef``1">
            <summary>
            Gets the EntityRef for the singleton component of the specified type.
            </summary>
            <typeparam name="T">The type of the singleton component.</typeparam>
            <returns>The EntityRef for the singleton component of the specified type.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the singleton component is not found.</exception>
        </member>
        <member name="M:Quantum.Core.FrameBase.GetSingletonEntityRef(System.Int32)">
            <summary>
            Gets the entity reference of the specified singleton component.
            </summary>
            <returns>The entity reference of the specified singleton component.</returns>
            <param name="componentIndex">The index of the component.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the singleton component is not found.</exception>
        </member>
        <member name="M:Quantum.Core.FrameBase.SetSingleton``1(``0,Quantum.EntityRef)">
            <summary>
            Sets the instance of the specified singleton component.
            </summary>
            <typeparam name="T">The type of the singleton component.</typeparam>
            <param name="component">The instance of the singleton component to set.</param>
            <param name="optionalAddTarget">The entity reference to add the singleton component to. If not specified, a new entity will be created.</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.SetSingleton(System.Int32,System.Void*,Quantum.EntityRef)">
            <summary>
            Sets the value of the specified singleton component.
            </summary>
            <param name="componentIndex">The index of the component.</param>
            <param name="value">The value to set.</param>
            <param name="optionalAddTarget">The entity reference where the singleton component should be added, defaults to default.</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.RemoveSingleton``1">
            <summary>
            Removes the singleton component of the specified type if it exists.
            </summary>
            <typeparam name="T">The type of the singleton component.</typeparam>
            <returns><see langword="true"/> if the singleton component was successfully removed, <see langword="false"/> if the singleton component does not exist.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if an error occurs while removing the singleton component.</exception>
        </member>
        <member name="M:Quantum.Core.FrameBase.RemoveSingleton(System.Type)">
            <summary>
            Removes the singleton component of the specified type.
            </summary>
            <returns><see langword="true"/> if the singleton component was successfully removed, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.RemoveSingleton(System.Int32)">
            <summary>
            Removes the singleton component of the specified type.
            </summary>
            <returns><see langword="true"/> if the singleton component was successfully removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the singleton component is not found.</exception>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryGetSingletonEntityRef``1(Quantum.EntityRef@)">
            <summary>
            Tries to get the <see cref="T:Quantum.EntityRef"/> of the specified singleton component.
            </summary>
            <typeparam name="T">The type of the singleton component.</typeparam>
            <param name="entityRef">The reference to store the entity.</param>
            <returns><see langword="true"/> if the singleton component is found and the <see cref="T:Quantum.EntityRef"/> is valid; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryGetSingletonEntityRef(System.Int32,Quantum.EntityRef@)">
            <summary>
            Tries to get the entity reference of the specified singleton component.
            </summary>
            <param name="componentIndex">The index of the component.</param>
            <param name="entityRef">The entity reference of the singleton component if it exists, otherwise default.</param>
            <returns><see langword="true"/> if the entity reference of the singleton component exists, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryGetSingleton``1(``0@)">
            <summary>
            Tries to get the instance of the specified singleton component.
            </summary>
            <typeparam name="T">The type of the singleton component.</typeparam>
            <param name="component">When this method returns, contains the instance of the specified singleton component if it is found; otherwise, the default value.</param>
            <returns><see langword="true"/> if the singleton component is found; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.GetOrAddSingleton``1(Quantum.EntityRef)">
            <summary>
            Gets the instance of the specified singleton component if it exists, otherwise adds the singleton component and returns the new instance.
            </summary>
            <typeparam name="T">The type of the singleton component.</typeparam>
            <param name="optionalAddTarget">The optional entity reference to add the singleton component to.</param>
            <returns>The instance of the specified singleton component.</returns>
        </member>
        <member name="T:Quantum.Core.FrameBase.Stats">
            <summary>
            Represents the memory statistics for a frame in the Quantum.Core namespace.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.Stats.HeapStats">
            <summary>
            Represents the memory statistics for a Heap.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.Stats.EntityCount">
            <summary>
            Represents the number of entities in the current frame.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameBase.Stats.EntityTotalMemory">
            <summary>
            Represents the total memory used by entities in a frame.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameBase.FreeList``1(Quantum.Collections.QListPtr{``0})">
            <summary>
            Frees a QList. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.FreeList``1(Quantum.Collections.QListPtr{``0}@)">
            <summary>
            Frees a QList and nullifies the <paramref name="ptr"/>. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFreeList``1(Quantum.Collections.QListPtr{``0})">
            <summary>
            Attempts to free a QList. If <paramref name="ptr"/> is <see langword="null"/> returns <see langword="false"/>. Otherwise, frees the collection and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFreeList``1(Quantum.Collections.QListPtr{``0}@)">
            <summary>
            Attempts to free a QList. If <paramref name="ptr"/> is <see langword="null"/> returns <see langword="false"/>. Otherwise, frees the collection, nullfies <paramref name="ptr"/> and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.ResolveList``1(Quantum.Collections.QListPtr{``0})">
            <summary>
            Resolves a QListPtr to a QList. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryResolveList``1(Quantum.Collections.QListPtr{``0},Quantum.Collections.QList{``0}@)">
            <summary>
            Resolves a QListPtr to a QList and stores the result in <paramref name="list"/>. If the pointer is invalid, assigns default and returns <see langword="false"/>. 
            Otherwise, assigns the resolved QList and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateList``1(System.Int32)">
            <summary>
            Allocates a QList with the specified capacity.
            </summary>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateList``1(Quantum.Collections.QListPtr{``0}@,System.Int32)">
            <summary>
            Allocates a QList with the specified capacity. <paramref name="ptr"/> is set to the allocated pointer.
            </summary>
            <param name="ptr">Allocated pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryAllocateList``1(Quantum.Collections.QListPtr{``0}@,System.Int32)">
            <summary>
            Allocates a QList with the specified capacity. If <paramref name="ptr"/> is already set, returns default. Otherwise, sets <paramref name="ptr"/> to the allocated pointer.
            </summary>
            <param name="ptr">Target pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FreeHashSet``1(Quantum.Collections.QHashSetPtr{``0})">
            <summary>
            Frees a QHashSet. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.FreeHashSet``1(Quantum.Collections.QHashSetPtr{``0}@)">
            <summary>
            Frees a QHashSet and nullifies the <paramref name="ptr"/>. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFreeHashSet``1(Quantum.Collections.QHashSetPtr{``0})">
            <summary>
            Attempts to free a QHashSet. If <paramref name="ptr"/> is <see langword="null"/> returns <see langword="false"/>. Otherwise, frees the collection and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFreeHashSet``1(Quantum.Collections.QHashSetPtr{``0}@)">
            <summary>
            Attempts to free a QHashSet. If <paramref name="ptr"/> is <see langword="null"/> returns <see langword="false"/>. Otherwise, frees the collection, nullfies <paramref name="ptr"/> and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.ResolveHashSet``1(Quantum.Collections.QHashSetPtr{``0})">
            <summary>
            Resolves a QHashSetPtr to a QHashSet. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryResolveHashSet``1(Quantum.Collections.QHashSetPtr{``0},Quantum.Collections.QHashSet{``0}@)">
            <summary>
            Resolves a QHashSetPtr to a QHashSet and stores the result in <paramref name="hashset"/>. If the pointer is invalid, assigns default and returns <see langword="false"/>. 
            Otherwise, assigns the resolved QHashSet and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
            <param name="hashset"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateHashSet``1(System.Int32)">
            <summary>
            Allocates a QHashSet with the specified capacity.
            </summary>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateHashSet``1(Quantum.Collections.QHashSetPtr{``0}@,System.Int32)">
            <summary>
            Allocates a QHashSet with the specified capacity. <paramref name="ptr"/> is set to the allocated pointer.
            </summary>
            <param name="ptr">Allocated pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryAllocateHashSet``1(Quantum.Collections.QHashSetPtr{``0}@,System.Int32)">
            <summary>
            Allocates a QHashSet with the specified capacity. If <paramref name="ptr"/> is already set, returns default. Otherwise, sets <paramref name="ptr"/> to the allocated pointer.
            </summary>
            <param name="ptr">Target pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FreeDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1})">
            <summary>
            Frees a QDictionary. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.FreeDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1}@)">
            <summary>
            Frees a QDictionary and nullifies the <paramref name="ptr"/>. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFreeDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1})">
            <summary>
            Attempts to free a QDictionary. If <paramref name="ptr"/> is <see langword="null"/> returns <see langword="false"/>. Otherwise, frees the collection and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryFreeDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1}@)">
            <summary>
            Attempts to free a QDictionary. If <paramref name="ptr"/> is <see langword="null"/> returns <see langword="false"/>. Otherwise, frees the collection, nullfies <paramref name="ptr"/> and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Quantum.Core.FrameBase.ResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1})">
            <summary>
            Resolves a QDictionaryPtr to a QDictionary. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.Collections.QDictionary{``0,``1}@)">
            <summary>
            Resolves a QDictionaryPtr to a QDictionary and stores the result in <paramref name="dictionary"/>. If the pointer is invalid, assigns default and returns <see langword="false"/>. 
            Otherwise, assigns the resolved QDictionary and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateDictionary``2(System.Int32)">
            <summary>
            Allocates a QDictionary with the specified capacity.
            </summary>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1}@,System.Int32)">
            <summary>
            Allocates a QDictionary with the specified capacity. <paramref name="ptr"/> is set to the allocated pointer.
            </summary>
            <param name="ptr">Allocated pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryAllocateDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1}@,System.Int32)">
            <summary>
            Allocates a QDictionary with the specified capacity. If <paramref name="ptr"/> is already set, returns default. Otherwise, sets <paramref name="ptr"/> to the allocated pointer.
            </summary>
            <param name="ptr">Target pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.ResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.EnumEqualityComparer.Tag)">
            <summary>
            Resolves a QDictionaryPtr to a QDictionary. In Debug builds assertions are made to ensure that the pointer is valid. In Release builds, no checks are made.
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.Collections.QEnumDictionary{``0,``1}@,Quantum.EnumEqualityComparer.Tag)">
            <summary>
            Resolves a QDictionaryPtr to a QDictionary and stores the result in <paramref name="dictionary"/>. If the pointer is invalid, assigns default and returns <see langword="false"/>. 
            Otherwise, assigns the resolved QDictionary and returns <see langword="true"/>.
            </summary>
            <param name="ptr"></param>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateDictionary``2(System.Int32,Quantum.EnumEqualityComparer.Tag)">
            <summary>
            Allocates a QDictionary with the specified capacity.
            </summary>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.AllocateDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1}@,System.Int32,Quantum.EnumEqualityComparer.Tag)">
            <summary>
            Allocates a QDictionary with the specified capacity. <paramref name="ptr"/> is set to the allocated pointer.
            </summary>
            <param name="ptr">Allocated pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.TryAllocateDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1}@,System.Int32,Quantum.EnumEqualityComparer.Tag)">
            <summary>
            Allocates a QDictionary with the specified capacity. If <paramref name="ptr"/> is already set, returns default. Otherwise, sets <paramref name="ptr"/> to the allocated pointer.
            </summary>
            <param name="ptr">Target pointer.</param>
            <param name="capacity">The number of elements that can be stored without resizing</param>
            <returns></returns>
        </member>
        <member name="T:Quantum.Core.FrameBase.FrameBaseUnsafe">
            <summary>
            Frame API to give access to C# unsafe pointers and advanced immediate operations.
            </summary>
            <remarks>Usage: Frame.Unsafe.Get</remarks>
            \ingroup FrameClass
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.#ctor(Quantum.Core.FrameBase)">
            <summary>
            Create FrameBaseUnsafe from a FrameBase.
            </summary>
            <param name="frame">Frame</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetComponentBlockIterator``1">
            <summary>
            Get a component iterator that cycles blocks of component pointers.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <returns>Block iterator</returns>
            <example><code>
            var region = 1UL &lt;&lt; 1;
            var navMeshAgents = f.Unsafe.GetComponentBlockIterator&lt;NavMeshAgent&gt;();
            while (navMeshAgents.NextBlock(out EntityRef* entities, out NavMeshAgent* agents, out int count)) {
              for (int i = 0; i&lt;count; i++) {
                var entity = entities[i];
                var agent = &amp;agents[i];
                agent->SetNavMeshRegionActive(region, !agent->IsNavMeshRegionActive(region));
               }
            }
            </code></example>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetComponentBlockIterator``1(System.Int32,System.Int32)">
            <summary>
            Get a component iterator that cycles blocks of component pointers, using a start offset and count
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="offset">Offset of entities we want</param>
            <param name="count">How many entities we want</param>
            <returns>Block iterator</returns>
            <example><code>
            var region = 1UL &lt;&lt; 1;
            var navMeshAgents = f.Unsafe.GetComponentBlockIterator&lt;NavMeshAgent&gt;(32, 16);
            while (navMeshAgents.NextBlock(out EntityRef* entities, out NavMeshAgent* agents, out int count)) {
              for (int i = 0; i&lt;count; i++) {
                var entity = entities[i];
                var agent =  &amp;agents[i];
                agent->SetNavMeshRegionActive(region, !agent->IsNavMeshRegionActive(region));
               }
            }
            </code></example>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.FilterStruct``1(Quantum.ComponentSet,Quantum.ComponentSet,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Returns a filtered ComponentFilterStruct instance for the specified type T.
            </summary>
            <param name="without">The ComponentSet specifying components that the filtering should exclude.</param>
            <param name="any">The ComponentSet specifying components that at least one of them should be present in the filtering result.</param>
            <param name="offset">The optional offset specifying the starting index of the filtering result.</param>
            <param name="count">The optional count specifying the number of elements in the filtering result.</param>
            <typeparam name="T">The type of components to filter.</typeparam>
            <returns>A ComponentFilterStruct instance representing the filtered component collection.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.ComponentGetter``1">
            <summary>
            Retrieves a ComponentGetter instance for the specified component type T from a FrameBaseUnsafe object.
            </summary>
            <typeparam name="T">The type of the component to retrieve</typeparam>
            <returns>A ComponentGetter instance for the specified component type T</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointer``1(Quantum.EntityRef)">
            <summary>
            Gets a pointer to a component that can be changed directly without writing the component back with <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <returns>Pointer to the requested component</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does have the requested component type.</exception>
            <para>Always check the availability of the component with <see cref="M:Quantum.Core.FrameBase.Has(Quantum.EntityRef,Quantum.ComponentSet)"/> before using this method.</para>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointer(Quantum.EntityRef,System.Int32)">
            <summary>
            Gets a pointer to a component that can be changed directly without writing the component back with <see cref="M:Quantum.Core.FrameBase.Set``1(Quantum.EntityRef,``0)"/>.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="componentIndex">Component index defined by ComponentTypeId{T}.Id.</param>
            <returns>Pointer to the requested component</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the entity does not exist</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the requested component index is invalid.</exception>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.TryGetPointer``1(Quantum.EntityRef,``0*@)">
            <summary>
            Similar to <see cref="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointer``1(Quantum.EntityRef)"/> but does not throw an exception if the component is not present.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="entityRef">Entity reference</param>
            <param name="value">Resulting component pointer of <see langword="null"/> if the component was not found</param>
            <returns><see langword="true"/> if component was found</returns>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.TryGetPointer(Quantum.EntityRef,System.Int32,System.Void*@)">
            <summary>
            Similar to <see cref="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointer(Quantum.EntityRef,System.Int32)"/> but does not throw an exception if the component is not present.
            </summary>
            <param name="entityRef">Entity reference</param>
            <param name="componentIndex">Component index defined by ComponentTypeId{T}.Id.</param>
            <param name="value">Resulting component pointer of <see langword="null"/> if the component was not found</param>
            <returns><see langword="true"/> if component was found</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the component index is invalid.</exception>
            \ingroup EntityApi
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.CommitAllCommands">
            <summary>
            Trigger the execution of entity and component deletion.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointerSingleton``1">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetPointerSingleton``1"/>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointerSingleton(System.Type)">
            <summary>
            Returns a pointer to the singleton component of type T.
            </summary>
            <param name="componentType">The type of the singleton component.</param>
            <returns>A pointer to the singleton component.</returns>
            <remarks>
            The component type T must implement the <see cref="T:Quantum.IComponentSingleton"/> interface and be unmanaged.
            </remarks>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetPointerSingleton(System.Int32)">
            <summary>
            Get a pointer to the singleton instance of the specified component type.
            </summary>
            <param name="componentIndex">The index of the component type.</param>
            <returns>A pointer to the singleton instance of the component.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.TryGetPointerSingleton``1(``0*@)">
            <summary>
            Tries to get a pointer to a component singleton of type T.
            </summary>
            <typeparam name="T">The type of the component singleton.</typeparam>
            <param name="component">The pointer to the component singleton if found, otherwise <see langword="null"/>.</param>
            <returns><see langword="true"/> if the pointer to the component singleton was successfully obtained, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.TryGetPointerSingleton``1(System.Type,System.Void*@)">
            <summary>
            Tries to get a pointer to the singleton component of type T.
            </summary>
            <param name="componentType">The type of the singleton component.</param>
            <param name="component">A pointer to the singleton component.</param>
            <returns><see langword="true"/> if the singleton component was successfully found and the pointer was obtained, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.TryGetPointerSingleton(System.Int32,System.Void*@)">
            <summary>
            Try to get a pointer to the specified component singleton in the current frame.
            </summary>
            <param name="componentIndex">The index of the component singleton.</param>
            <param name="component">A pointer to the component, if it exists; otherwise, <see langword="null"/>.</param>
            <returns><see langword="true"/> if the component singleton exists and a pointer is successfully obtained; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetOrAddSingletonPointer``1(Quantum.EntityRef)">
            <summary>
            Get or add a pointer to the singleton component of type T in the Frame.
            </summary>
            <typeparam name="T">Type of the singleton component</typeparam>
            <param name="optionalAddTarget">Optional entity reference to add the singleton component to, if it doesn't already exist</param>
            <returns>Pointer to the singleton component</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.GetOrAddSingletonPointer(System.Int32,Quantum.EntityRef)">
            <summary>
            Retrieves a pointer to the specified singleton component, creating it if it doesn't exist.
            </summary>
            <param name="componentIndex">The index of the component.</param>
            <param name="optionalAddTarget">The entity reference to add the singleton component if it doesn't exist.</param>
            <returns>A pointer to the singleton component.</returns>
        </member>
        <member name="M:Quantum.Core.FrameBase.FrameBaseUnsafe.Dispose">
            <summary>
            Dispose the FrameBaseUnsafe instance.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameBase.Print(Quantum.Core.FrameBase,Quantum.FramePrinter,System.Boolean)">
            <summary>
            Prints the entities and their components in the frame.
            </summary>
            <param name="r">The frame to print.</param>
            <param name="printer">The frame printer.</param>
            <param name="printComponentsChecksum">Whether to print the checksums of the components or not.</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Serialize(Quantum.Core.FrameBase,Quantum.FrameSerializer)">
            <summary>
            Serializes the given frame using the provided serializer.
            </summary>
            <param name="r">The frame to serialize.</param>
            <param name="serializer">The frame serializer.</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Copy(Quantum.Core.FrameBase,Quantum.Core.FrameBase)">
            <summary>
            Copies the data from one FrameBase instance to another.
            </summary>
            <param name="to">The destination FrameBase instance.</param>
            <param name="from">The source FrameBase instance.</param>
        </member>
        <member name="M:Quantum.Core.FrameBase.Initialize(Quantum.Core.FrameBase,Quantum.Core.FrameBase.EntitiesConfig,System.Int32)">
            <summary>
            Initializes the FrameBase instance.
            </summary>
            <param name="f">The FrameBase instance to initialize.</param>
            <param name="config">The configuration settings for the FrameBase instance.</param>
            <param name="maxComponents">The maximum number of components allowed.</param>
            <exception cref="T:System.NotImplementedException">Thrown if the method is not implemented.</exception>
        </member>
        <member name="T:Quantum.Core.FrameContext">
            <summary>
            The FrameContext is shared between individual transient <see cref="T:Quantum.Core.FrameBase"/> instances. 
            <para>It controls systems like Quantum events, profilers, tasks, culling and subsystems for physics and navigation allocating reused memory.</para>
            </summary>
        </member>
        <member name="T:Quantum.Core.FrameContext.Args">
            <summary>
            The FrameContext creating arguments.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.PlatformInfo">
            <summary>
            Information about the platform Quantum is running on.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.IsLocalPlayer">
            <summary>
            A callback to decide if a player is local.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.IsServer">
            <summary>
            Flags the simulation as running on the server to filter out client and server events. 
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.NavigationConfig">
            <summary>
            The navigation global configuration from the SimulationConfig.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.PhysicsConfig">
            <summary>
            The physics global configuration from the SimulationConfig.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.CommandSerializer">
            <summary>
            The command serializer.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.AssetSerializer">
            <summary>
            The asset serializer.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.ResourceManager">
            <summary>
            The resource manager.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.InitialDynamicAssets">
            <summary>
            The initial dynamic asset db.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.HeapConfig">
            <summary>
            The global Quantum heap configuration.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.HeapTrackingMode">
            <summary>
            The heap tracking mode.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.UseCullingArea">
            <summary>
            Set to <see langword="true"/> to enabled entity culling.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.UsePhysics2D">
            <summary>
            Set to <see langword="true"/> to enable 2D physics subsystems.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.UsePhysics3D">
            <summary>
            Set to <see langword="true"/> to enabled 3D physics subsystems.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.UseNavigation">
            <summary>
            Set to <see langword="true"/> to enabled navigation subsystems.
            </summary>
        </member>
        <member name="F:Quantum.Core.FrameContext.Args.UseSharedChecksumSerialized">
            <summary>
            Use a single <see cref="T:Quantum.FrameSerializer"/> instance to generate all checksums.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.Physics2D">
            <summary>
            Access the 2D physics API.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.Physics3D">
            <summary>
            Access the 3D physics API.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.Allocator">
            <summary>
            Access the native allocator.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.TaskContext">
            <summary>
            Access the task context.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.ProfilerContext">
            <summary>
            Access the profiler context.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.Events">
            <summary>
            Access the current stored events.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.Culling">
            <summary>
            Access the culling subsystem.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.CommandSerializer">
            <summary>
            Access the command serializer.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.AssetSerializer">
            <summary>
            Access the the asset serializer.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.ResourceManager">
            <summary>
            Access the resource manager.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.AssetDB">
            <summary>
            Obsolete. Use <see cref="P:Quantum.Core.FrameContext.ResourceManager"/> instead.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.UseSharedChecksumSerializer">
            <summary>
            Returns <see langword="true"/> is <see cref="F:Quantum.Core.FrameContext.Args.UseSharedChecksumSerialized"/> was set.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.SharedChecksumSerializer">
            <summary>
            Access the shared checksum serializer.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.HeapTrackingMode">
            <summary>
            Return the heap tracking mode that the FrameContext was created with.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.HeapTracker">
            <summary>
            Access the heap tracker.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.PhysicsConfig">
            <summary>
            Access the global physics configuration.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.#ctor(Quantum.Core.FrameContext.Args)">
            <summary>
            Create a new instance of the FrameContext using the <see pa="Args"/>.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.IsLocalPlayer(Quantum.PlayerRef)">
            <summary>
            Don't use this in the simulation that affect the state because it is different on each client and will lead to desyncs.
            </summary>
            <param name="player">Player ref</param>
            <returns><see langword="true"/> if the player is controlled by the local simulation.</returns>
        </member>
        <member name="P:Quantum.Core.FrameContext.IsServer">
            <summary>
            Returns <see langword="true"/> if the FrameContext was started with <see cref="F:Quantum.Core.FrameContext.Args.IsServer"/> enabled.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.OnGameStart(Photon.Deterministic.DeterministicFrame)">
            <summary>
            Callback required to start the heap tracking.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.OnSimulationBegin">
            <summary>
            Forwards simulation begin event to internal subsystems.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.OnSimulationEnd">
            <summary>
            Forwards simulation end event to internal subsystems.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.OnFrameSimulationBegin(Quantum.Core.FrameBase)">
            <summary>
            Forwards frame simulation begin event to internal subsystems.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.OnFrameSimulationEnd">
            <summary>
            Forwards frame simulation end event to internal subsystems.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.TempAllocate(System.Int32,System.Int32)">
            <summary>
            Allocates memory that is released during <see cref="M:Quantum.Core.FrameContext.OnFrameSimulationEnd"/>.
            </summary>
            <param name="size">The memory size in bytes.</param>
            <param name="alignment">The expected memory alignment.</param>
            <returns>Allocated memory.</returns>
        </member>
        <member name="M:Quantum.Core.FrameContext.TempAllocateAndClear(System.Int32,System.Int32)">
            <inheritdoc cref="M:Quantum.Core.FrameContext.TempAllocate(System.Int32,System.Int32)"/>.
        </member>
        <member name="M:Quantum.Core.FrameContext.Dispose">
            <summary>
            Dispose internal subsystems and free allocated memory.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.AcquireEvent``1(System.Int32)">
            <summary>
            Creates a new event object from the pool.
            </summary>
            <typeparam name="T">The event type.</typeparam>
            <param name="id">The event id.</param>
            <returns>New or reused event object.</returns>
        </member>
        <member name="M:Quantum.Core.FrameContext.ReleaseEvent(Quantum.EventBase)">
            <summary>
            Release an event object and return it to the pool
            </summary>
            <param name="evnt">Event to release.</param>
        </member>
        <member name="M:Quantum.Core.FrameContext.SetPredictionArea(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">
            <summary>
            Sets the prediction area. Entities outside this area are culled from predicted frames.
            </summary>
            <param name="center">The center of the area of interest circle.</param>
            <param name="radius">The radius of the area if nterest circle.</param>
        </member>
        <member name="P:Quantum.Core.FrameContext.PredictionAreaCenter">
            <summary>
            Return the current prediction culling circle area center.
            </summary>
        </member>
        <member name="P:Quantum.Core.FrameContext.PredictionAreaRadius">
            <summary>
            Return the current prediction culling circle area radius.
            </summary>
        </member>
        <member name="M:Quantum.Core.FrameContext.InPredictionArea(Photon.Deterministic.DeterministicFrame,Photon.Deterministic.FPVector3)">
            <summary>
            This method determines if a position is inside the prediction area.
            <para>This method can be overwritten to support custom shapes.</para>
            </summary>
            <param name="frame">The current frame.</param>
            <param name="position">The position to check.</param>
            <returns><see langword="true"/> if the position is inside the prediction area.</returns>
        </member>
        <member name="M:Quantum.Core.FrameContext.InPredictionArea(Photon.Deterministic.DeterministicFrame,Photon.Deterministic.FPVector2)">
            <inheritdoc cref="M:Quantum.Core.FrameContext.InPredictionArea(Photon.Deterministic.DeterministicFrame,Photon.Deterministic.FPVector3)"/>
        </member>
        <member name="T:Quantum.Core.IDerivedStruct`1">
            <summary>
            An interface representing a derived struct. Not meant to be used directly. Quantum's code generation supports structs inheritance
            and emits the interface implementation if needed.
            </summary>
            <typeparam name="T">Type derived from.</typeparam>
        </member>
        <member name="T:Quantum.Core.ICollisionCallbacks2D">
            <summary>
            Interface for receiving 2D collision callbacks
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks2D.OnCollision2D(Quantum.Core.FrameBase,Quantum.CollisionInfo2D)">
            <summary>
            Raised when two non-trigger 2D colliders collide.
            Raised every frame while the collision lasts.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks2D.OnCollisionEnter2D(Quantum.Core.FrameBase,Quantum.CollisionInfo2D)">
            <summary>
            Raised on the frame when two non-trigger 2D colliders start colliding.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks2D.OnCollisionExit2D(Quantum.Core.FrameBase,Quantum.ExitInfo2D)">
            <summary>
            Raised on the first frame when two non-trigger 2D colliders are detected as no longer colliding.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks2D.OnTrigger2D(Quantum.Core.FrameBase,Quantum.TriggerInfo2D)">
            <summary>
            Raised when two 2D colliders collide if exactly one of them is a trigger collider.
            Raised every frame while the collision lasts.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks2D.OnTriggerEnter2D(Quantum.Core.FrameBase,Quantum.TriggerInfo2D)">
            <summary>
            Raised on the first frame when two 2D colliders start colliding if exactly one of them is a trigger collider.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks2D.OnTriggerExit2D(Quantum.Core.FrameBase,Quantum.ExitInfo2D)">
            <summary>
            Raised on the first frame when two 2D colliders are detected as no longer colliding
            if exactly one of them is a trigger collider.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="T:Quantum.Core.ICollisionCallbacks3D">
            <summary>
            Interface for receiving 3D collision callbacks
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks3D.OnCollision3D(Quantum.Core.FrameBase,Quantum.CollisionInfo3D)">
            <summary>
            Raised when two non-trigger 3D colliders collide.
            Raised every frame while the collision lasts.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks3D.OnCollisionEnter3D(Quantum.Core.FrameBase,Quantum.CollisionInfo3D)">
            <summary>
            Raised on the frame when two non-trigger 3D colliders start colliding.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks3D.OnCollisionExit3D(Quantum.Core.FrameBase,Quantum.ExitInfo3D)">
            <summary>
            Raised on the first frame when two non-trigger 3D colliders are detected as no longer colliding.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks3D.OnTrigger3D(Quantum.Core.FrameBase,Quantum.TriggerInfo3D)">
            <summary>
            Raised when two 3D colliders collide if exactly one of them is a trigger collider.
            Raised every frame while the collision lasts.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks3D.OnTriggerEnter3D(Quantum.Core.FrameBase,Quantum.TriggerInfo3D)">
            <summary>
            Raised on the first frame when two 3D colliders start colliding if exactly one of them is a trigger collider.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="M:Quantum.Core.ICollisionCallbacks3D.OnTriggerExit3D(Quantum.Core.FrameBase,Quantum.ExitInfo3D)">
            <summary>
            Raised on the first frame when two 3D colliders are detected as no longer colliding
            if exactly one of them is a trigger collider.
            </summary>
            <param name="f">Current frame instance.</param>
            <param name="info">Details about the collision.</param>
        </member>
        <member name="T:Quantum.Core.CompoundCommand">
            <summary>
            An auxiliary command that can be used to send multiple commands in one. Nested compound commands are accepted.
            </summary>
        </member>
        <member name="F:Quantum.Core.CompoundCommand.Commands">
            <summary>
            A list of the commands that are part of this compound.
            </summary>
        </member>
        <member name="M:Quantum.Core.CompoundCommand.Serialize(Photon.Deterministic.BitStream,Photon.Deterministic.DeterministicCommandSerializer)">
            <summary>
            Write or read a command from the raw input stream.
            </summary>
            <param name="stream">Bit stream</param>
            <param name="cmdSerializer">Command serializer</param>
        </member>
        <member name="M:Quantum.Core.CompoundCommand.Serialize(Photon.Deterministic.BitStream)">
            <summary>
            Not implemented, use the other overload instead.
            </summary>
            <param name="stream">Bitstream</param>
        </member>
        <member name="M:Quantum.Core.CompoundCommand.Dispose">
            <summary>
            Disposes all the commands in the compound.
            </summary>
        </member>
        <member name="T:Quantum.Core.RingBuffer`1">
            <summary>
            Ring buffer collection implementation.
            Stores <see cref="P:Quantum.Core.RingBuffer`1.Capacity"/> number of values and will overwrite the oldest value when full.
            </summary>
            <typeparam name="T">Type of data that the collection stores</typeparam>
        </member>
        <member name="P:Quantum.Core.RingBuffer`1.Capacity">
            <summary>
            The maximum size of the buffer.
            </summary>
        </member>
        <member name="P:Quantum.Core.RingBuffer`1.Size">
            <summary>
            The current used size of the buffer.
            </summary>
        </member>
        <member name="P:Quantum.Core.RingBuffer`1.ToArray">
            <summary>
            Return the underlying array.
            </summary>
        </member>
        <member name="P:Quantum.Core.RingBuffer`1.IsFull">
            <summary>
            Check if the buffer is full.
            </summary>
        </member>
        <member name="P:Quantum.Core.RingBuffer`1.IsEmpty">
            <summary>
            Check if the buffer is empty.
            </summary>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.#ctor(System.Int32)">
            <summary>
            Create a new RingBuffer with a given capacity.
            </summary>
            <param name="capacity">Initial capacity</param>
            <exception cref="T:System.ArgumentException">Is raised the the capacity is invalid.</exception>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.Clear">
            <summary>
            Clear the buffer and reset the start and end positions.
            </summary>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.PushBack(`0)">
            <summary>
            Add a value in the back of the buffer.
            </summary>
            <param name="item">The value to add to the collection</param>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.PushFront(`0)">
            <summary>
            Add a value in the front of the buffer.
            </summary>
            <param name="item">The value to add to the collection</param>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.PopBack">
            <summary>
            Remove and return the last value in the buffer.
            </summary>
            <returns>The youngest value of the buffer</returns>
            <exception cref="T:System.InvalidOperationException">Is raised when the buffer is empty.</exception>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.PopFront">
            <summary>
            Remove and return the first value in the buffer.
            </summary>
            <returns>The oldest value in the buffer</returns>
            <exception cref="T:System.InvalidOperationException">Is raised when the buffer is empty.</exception>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.PeekBack(System.Int32)">
            <summary>
            Look at the last element in the buffer without removing it.
            </summary>
            <param name="offset">Optional offset to apply</param>
            <returns>The youngest element</returns>
            <exception cref="T:System.InvalidOperationException">Is raised when the buffer is empty.</exception>
            <exception cref="T:System.IndexOutOfRangeException">Is raised when the offset is invalid</exception>
        </member>
        <member name="M:Quantum.Core.RingBuffer`1.PeekFront(System.Int32)">
            <summary>
            Look at the first element in the buffer without removing it.
            </summary>
            <param name="offset">Optional offset to apply</param>
            <returns>The olders element</returns>
            <exception cref="T:System.InvalidOperationException">Is raised when the buffer is empty.</exception>
            <exception cref="T:System.IndexOutOfRangeException">Is raised when the offset is invalid</exception>
        </member>
        <member name="T:Quantum.Core.StreamUtils">
            <summary>
            Streaming utility methods.
            </summary>
        </member>
        <member name="M:Quantum.Core.StreamUtils.ReadInt(System.IO.BinaryReader,System.Int32)">
            <summary>
            Read an integer from a binary reader.
            </summary>
            <param name="reader">Reader</param>
            <param name="offset">Read position offset</param>
            <returns>Converted integer that was read from the stream</returns>
            <exception cref="T:System.ArgumentNullException">Is raised when the reader is <see langword="null"/></exception>
            <exception cref="T:System.Exception">Is raised when the integer could not be read from the stream</exception>
        </member>
        <member name="M:Quantum.Core.StreamUtils.ReadInt(System.IO.Stream,System.Int32)">
            <summary>
            Read an integer from a stream.
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="offset">Read position offset </param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Is raised when the stream is <see langword="null"/></exception>
            <exception cref="T:System.Exception">Is raised when the stream is not readable, the offset is invalid or the integer could not be read</exception>
        </member>
        <member name="M:Quantum.Core.StreamUtils.SeekOrThrow(System.IO.Stream,System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seek to a position in the stream or throw on error.
            </summary>
            <param name="stream">The stream to seek in</param>
            <param name="offset">The offset to seek to</param>
            <param name="seekOrigin">The origin to seek from</param>
            <returns>The position after seeking</returns>
            <exception cref="T:System.ArgumentNullException">Is raised when the stream is <see langword="null"/></exception>
            <exception cref="T:System.Exception">Is raised when the stream is not seek-able or the seeking failed.</exception>
        </member>
        <member name="T:Quantum.FixedArray">
            <summary>
            Provides utility methods for working with Quantum fixed-size arrays.
            </summary>
        </member>
        <member name="M:Quantum.FixedArray.Serialize``1(Quantum.FixedArray{``0},Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes the <see cref="T:Quantum.FixedArray"/> Ptr into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="array">The <see cref="T:Quantum.FixedArray"/> to be serialized.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="itemSerializer">A delegate for serializing the array items.</param>
        </member>
        <member name="T:Quantum.FixedArray`1">
            <summary>
            A Quantum array with fixed size.
            </summary>
        </member>
        <member name="F:Quantum.FixedArray`1.Buffer">
            <summary>
            The buffer used to store the array elements.
            </summary>
        </member>
        <member name="F:Quantum.FixedArray`1.Stride">
            <summary>
            The stride of the elements.
            </summary>
        </member>
        <member name="F:Quantum.FixedArray`1.Length">
            <summary>
            The amount of elements.
            </summary>
        </member>
        <member name="P:Quantum.FixedArray`1.Item(System.Int32)">
            <summary>
            Gets the value associated with the specified index.
            </summary>
            <exception cref="T:System.NullReferenceException">When the array buffer is <see langword="null"/>.</exception>
            <exception cref="T:System.IndexOutOfRangeException">When the specified index is out of the array boundaries.</exception>
        </member>
        <member name="M:Quantum.FixedArray`1.#ctor(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Initializes the array buffer, stride and length.
            </summary>
        </member>
        <member name="M:Quantum.FixedArray`1.GetPointer(System.Int32)">
            <summary>
            Gets a pointer to the item on the specified index.
            </summary>
            <param name="index">The index to be found in the array.</param>
            <exception cref="T:System.NullReferenceException">When the array buffer is <see langword="null"/>.</exception>
            <exception cref="T:System.IndexOutOfRangeException">When the specified index is out of the list boundaries.</exception>
        </member>
        <member name="M:Quantum.FixedArray`1.GetHashCode">
            <summary>
            Gets the array hash code.
            </summary>
        </member>
        <member name="M:Quantum.FixedArray`1.Equals(Quantum.FixedArray{`0})">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Quantum.FixedArray`1"/> value.
            </summary>
            <param name="other">A <see cref="T:Quantum.FixedArray`1"/> value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.FixedArray`1.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.FixedArray`1.op_Equality(Quantum.FixedArray{`0},Quantum.FixedArray{`0})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.FixedArray`1"/> are equal.
            </summary>
            <returns><see langword="true"/> if the instances are equal.</returns>
        </member>
        <member name="M:Quantum.FixedArray`1.op_Inequality(Quantum.FixedArray{`0},Quantum.FixedArray{`0})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.FixedArray`1"/> are not equal.
            </summary>
            <returns><see langword="true"/> if the instances are not equal.</returns>
        </member>
        <member name="M:Quantum.FixedArray`1.Serialize(Quantum.FixedArray{`0},Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes the <see cref="T:Quantum.FixedArray`1"/> Ptr into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="array">The <see cref="T:Quantum.FixedArray"/> to be serialized.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="itemSerializer">A delegate for serializing the list items.</param>
        </member>
        <member name="T:Quantum.Collections.QCollectionsUtils">
            <summary>
            Helper class with utility methods used by QCollections.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QCollectionsUtils.IsPrimeFromList(System.UInt32)">
            <summary>
            Checks if an unsigned integer number is prime based on a lookup table.
            </summary>
            <param name="value">The value to be checked.</param>
            <returns><see langword="true"/> if the value is a prime number.</returns>
        </member>
        <member name="M:Quantum.Collections.QCollectionsUtils.IsPrimeFromList(System.Int32)">
            <summary>
            Checks if an integer number is prime based on a lookup table.
            </summary>
            <param name="value">The value to be checked.</param>
            <returns><see langword="true"/> if the value is a prime number.</returns>
        </member>
        <member name="M:Quantum.Collections.QCollectionsUtils.GetNextPrime(System.Int32)">
            <summary>
            Finds the next prime number based on an integer value. Uses a lookup table.
            </summary>
            <param name="value">The base value.</param>
            <returns>The next prime number.</returns>
        </member>
        <member name="M:Quantum.Collections.QCollectionsUtils.GetNextPrime(System.UInt32)">
            <summary>
            Finds the next prime number based on an unsigned integer value. Uses a lookup table.
            </summary>
            <param name="value">The base value.</param>
            <returns>The next prime number.</returns>
        </member>
        <member name="M:Quantum.Collections.QCollectionsUtils.GetNextPrimeGreaterThanOrEqual(System.Int32)">
            <summary>
            Finds a prime number which is either equal or greater than an integer value. Uses a lookup table.
            </summary>
            <param name="value">The base value.</param>
            <returns>The prime number.</returns>
        </member>
        <member name="M:Quantum.Collections.QCollectionsUtils.GetNextPrimeGreaterThanOrEqual(System.UInt32)">
            <summary>
            Finds a prime number which is either equal or greater than an unsigned integer value. Uses a lookup table.
            </summary>
            <param name="value">The base value.</param>
            <returns>The prime number.</returns>
        </member>
        <member name="M:Quantum.Collections.QCollectionsUtils.PrintSimple``1(System.Void*,Quantum.FramePrinter)">
            <summary>
            Prints the value contained in a memory location referenced by a pointer
            </summary>
        </member>
        <member name="T:Quantum.Collections.QDictionaryPtr`2">
            <summary>
            Stores a <see cref="T:Quantum.Ptr"/> which points to the memory location of a <see cref="T:Quantum.Collections.QDictionary`2"/> inside the frame heap.
            </summary>
            <typeparam name="K">An unmanaged key type.</typeparam>
            <typeparam name="V">An unmanaged value type.</typeparam>
        </member>
        <member name="F:Quantum.Collections.QDictionaryPtr`2.Ptr">
            <summary>
            The pointer to the memory location of the  <see cref="T:Quantum.Collections.QDictionary`2"/> inside the frame heap.<br/>
            To check if this collection is not allocated, check if this Ptr is not equals to <see cref="P:Quantum.Ptr.Null"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QDictionaryPtr`2.#ctor(Quantum.Ptr)">
            <summary>
            Stores the pointer to the  <see cref="T:Quantum.Collections.QDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QDictionaryPtr`2.GetHashCode">
            <summary>
            Gets the hash code of the stored <see cref="T:Quantum.Ptr"/>.
            </summary>
            <returns>Returns the hash code of the stored <see cref="T:Quantum.Ptr"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QDictionaryPtr`2.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QDictionaryPtr`2.Equals(Quantum.Collections.QDictionaryPtr{`0,`1})">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Quantum.Collections.QDictionaryPtr`2"/> value.
            </summary>
            <param name="other">A <see cref="T:Quantum.Collections.QDictionaryPtr`2"/> value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QDictionaryPtr`2.op_Equality(Quantum.Collections.QDictionaryPtr{`0,`1},Quantum.Collections.QDictionaryPtr{`0,`1})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.Collections.QDictionaryPtr`2"/> are equal.
            </summary>
            <returns><see langword="true"/> if the instances are equal.</returns>
        </member>
        <member name="M:Quantum.Collections.QDictionaryPtr`2.op_Inequality(Quantum.Collections.QDictionaryPtr{`0,`1},Quantum.Collections.QDictionaryPtr{`0,`1})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.Collections.QDictionaryPtr`2"/> are not equal.
            </summary>
            <returns><see langword="true"/> if the instances are not equal.</returns>
        </member>
        <member name="T:Quantum.Collections.QDictionaryIterator`2">
            <summary>
            An iterator for traversing the entries of a <see cref="T:Quantum.Collections.QDictionary`2"/>. This iterator allows for traversing the key-value pairs stored within the dictionary in a sequential manner.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QDictionaryIterator`2.Current">
            <summary>
            Gets the current key-value pair in the <see cref="T:Quantum.Collections.QDictionary`2"/> based in the iterator state.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QDictionaryIterator`2.ValuePtrUnsafe">
            <summary>
            Returns a pointer to the current value based on the iterator current element.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QDictionaryIterator`2.MoveNext">
            <summary>
            Advances the iterator to the next element of the <see cref="T:Quantum.Collections.QDictionary`2"/>, which can be retrieved with <see cref="P:Quantum.Collections.QDictionaryIterator`2.Current"/>.
            </summary>
            <returns><see langword="true"/> if the iterator is still in the boundaries of the <see cref="T:Quantum.Collections.QDictionary`2"/>.</returns>
        </member>
        <member name="T:Quantum.Collections.QDictionary">
            <summary>
            A Quantum dictionary-like collection which uses the frame heap.
            This collection relies on Frame and on its API for allocating, deallocating and resolving.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QDictionary.Serialize``2(Quantum.Collections.QDictionaryPtr{``0,``1}*,Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes a <see cref="T:Quantum.Collections.QDictionary"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Collections.QDictionary"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="keySerializer">A delegate for serializing the <see cref="T:Quantum.Collections.QDictionary`2"/> keys.</param>
            <param name="valSerializer">A delegate for serializing the <see cref="T:Quantum.Collections.QDictionary`2"/> values.</param>
        </member>
        <member name="T:Quantum.Collections.QDictionary`2">
            <summary>
            A Quantum dictionary-like collection which uses the frame heap.
            This collection relies on Frame and on its API for allocating, deallocating and resolving.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QDictionary`2.Capacity">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QDictionary`2"/> current capacity. The capacity automatically expands, if necessary, when adding new entries.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QDictionary`2.Count">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QDictionary`2"/> current entries amount.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. When setting a value, if the key does not exist in the dictionary, it will add a new key-value pair to it.
            </returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when trying to get a value for a key that does not exist in the dictionary.</exception>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.ContainsKey(`0)">
            <summary>
            Checks whether the dictionary contains a specific key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.Clear">
            <summary>
            Removes all elements from the dictionary. It does not reset the dictionary <see cref="P:Quantum.Collections.QDictionary`2.Capacity"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with the specified key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <param name="val">
            When this method returns, this parameters contains the value associated with the specified key,
            if the key is found; otherwise, it contains the default value for the type of the value parameter.
            </param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.TryGetValuePointer(`0,`1*@)">
            <summary>
            Attempts to get the pointer to a value associated with the specified key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <param name="val">
            When this method returns, this parameters contains the pointer to the value associated with the specified key,
            if the key is found; otherwise, it contains <see langword="null"/>.
            </param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the specified key and value into the dictionary. It might expand the capacity if needed.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add.</param>
            <exception cref="T:System.ArgumentException">Thrown when the key already exists in the dictionary.</exception>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.TryAdd(`0,`1)">
            <summary>
            Adds an element with the specified key and value into the dictionary if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add.</param>
            <returns>
            <see langword="true"/> if the element is successfully added; otherwise, <see langword="false"/> if the key already exists in the dictionary.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the dictionary.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            <see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/> if the key is not found in the dictionary.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.GetEnumerator">
            <summary>
            Returns an iterator that traverses through the <see cref="T:Quantum.Collections.QDictionary`2"/>.
            </summary>
            <returns>An iterator to traverse through the dictionary.</returns>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.Allocate(Quantum.Allocator.FrameHeap,System.Int32)">
            <summary>
            Allocates a <see cref="T:Quantum.Collections.QDictionary`2"/> in the frame heap. It must be used before trying to resolve and use the dictionary.
            </summary>
            <returns>The allocated <see cref="T:Quantum.Collections.QDictionary`2"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.Print(Quantum.Ptr,Quantum.FramePrinter)">
            <summary>
            Prints the <see cref="T:Quantum.Collections.QDictionary`2"/> data.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.PrintQDictionaryPtr(Quantum.Collections.QDictionaryPtr{`0,`1},Quantum.FramePrinter)">
            <summary>
            Prints the <see cref="T:Quantum.Collections.QDictionary`2"/> data.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.Serialize(Quantum.Ptr*,Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes the <see cref="T:Quantum.Collections.QDictionary`2"/> Ptr into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The <see cref="T:Quantum.Collections.QDictionary`2"/> Ptr.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="keySerializer">A delegate for serializing the QDictionary{K, V} keys.</param>
            <param name="valSerializer">A delegate for serializing the QDictionary{K, V} values.</param>
        </member>
        <member name="M:Quantum.Collections.QDictionary`2.op_Implicit(Quantum.Collections.QDictionary{`0,`1})~Quantum.Collections.QDictionaryPtr{`0,`1}">
            <summary>
            Operator which allocates a <see cref="T:Quantum.Collections.QDictionary`2"/> based on another <see cref="T:Quantum.Collections.QDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Quantum.Collections.QEnumDictionary`2">
            <summary>
            A Quantum dictionary-like collection which uses the frame heap. Used in Quantum dictionaries which uses an <see langword="Enum"/> as the key type.<br/>
            This collection relies on Frame and on its API for allocating, deallocating and resolving.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QEnumDictionary`2.Capacity">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QDictionary`2"/> current capacity. The capacity automatically expands, if necessary, when adding new entries.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QEnumDictionary`2.Count">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QDictionary`2"/> current entries amount.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QEnumDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. When setting a value, if the key does not exist in the dictionary, it will add a new key-value pair to it.
            </returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when trying to get a value for a key that does not exist in the dictionary.</exception>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.ContainsKey(`0)">
            <summary>
            Checks whether the dictionary contains a specific key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.Clear">
            <summary>
            Removes all elements from the dictionary. It does not reset the dictionary <see cref="P:Quantum.Collections.QDictionary`2.Capacity"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with the specified key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <param name="val">
            When this method returns, this parameters contains the value associated with the specified key,
            if the key is found; otherwise, it contains the default value for the type of the value parameter.
            </param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.TryGetValuePointer(`0,`1*@)">
            <summary>
            Attempts to get the pointer to a value associated with the specified key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <param name="val">
            When this method returns, this parameters contains the pointer to the value associated with the specified key,
            if the key is found; otherwise, it contains <see langword="null"/>.
            </param>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the specified key and value into the dictionary. It might expand the capacity if needed.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add.</param>
            <exception cref="T:System.ArgumentException">Thrown when the key already exists in the dictionary.</exception>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.TryAdd(`0,`1)">
            <summary>
            Adds an element with the specified key and value into the dictionary if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add.</param>
            <returns>
            <see langword="true"/> if the element is successfully added; otherwise, <see langword="false"/> if the key already exists in the dictionary.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the dictionary.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            <see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/> if the key is not found in the dictionary.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.GetEnumerator">
            <summary>
            Returns an iterator that traverses through the <see cref="T:Quantum.Collections.QDictionary`2"/>.
            </summary>
            <returns>An iterator to traverse through the dictionary.</returns>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.Allocate(Quantum.Allocator.FrameHeap,System.Int32)">
            <summary>
            Allocates a <see cref="T:Quantum.Collections.QDictionary`2"/> in the frame heap. It must be used before trying to resolve and use the dictionary.
            </summary>
            <returns>The allocated <see cref="T:Quantum.Collections.QDictionary`2"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.Print(Quantum.Ptr,Quantum.FramePrinter)">
            <summary>
            Prints the <see cref="T:Quantum.Collections.QDictionary`2"/> data.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.PrintQDictionaryPtr(Quantum.Collections.QDictionaryPtr{`0,`1},Quantum.FramePrinter)">
            <summary>
            Prints the <see cref="T:Quantum.Collections.QDictionary`2"/> data.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.Serialize(Quantum.Ptr*,Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes the <see cref="T:Quantum.Collections.QDictionary`2"/> Ptr into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The <see cref="T:Quantum.Collections.QDictionary`2"/> Ptr.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="keySerializer">A delegate for serializing the QDictionary{K, V} keys.</param>
            <param name="valSerializer">A delegate for serializing the QDictionary{K, V} values.</param>
        </member>
        <member name="M:Quantum.Collections.QEnumDictionary`2.op_Implicit(Quantum.Collections.QEnumDictionary{`0,`1})~Quantum.Collections.QDictionaryPtr{`0,`1}">
            <summary>
            Operator which allocates a <see cref="T:Quantum.Collections.QDictionary`2"/> based on another <see cref="T:Quantum.Collections.QDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Quantum.Collections.QHashSet`1">
            <summary>
            A Quantum hashset-like collection which uses the frame heap.
            This collection relies on Frame and on its API for allocating, deallocating and resolving.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QHashSet`1.Count">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QHashSet`1"/> current entries amount.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QHashSet`1.Capacity">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QHashSet`1"/> current capacity. The capacity automatically expands, if necessary, when adding new entries.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QHashSet`1.op_Implicit(Quantum.Collections.QHashSet{`0})~Quantum.Collections.QHashSetPtr{`0}">
            <summary>
            Operator which allocates a <see cref="T:Quantum.Collections.QHashSet`1"/> based on another <see cref="T:Quantum.Collections.QHashSet`1"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QHashSet`1.Contains(`0)">
            <summary>
            Checks whether the hash set contains a specific value.
            </summary>
            <param name="value">The value to locate in the hash set.</param>
        </member>
        <member name="M:Quantum.Collections.QHashSet`1.Clear">
            <summary>
            Removes all elements from the hash set. It does not reset the hash set <see cref="P:Quantum.Collections.QHashSet`1.Capacity"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QHashSet`1.Add(`0)">
            <summary>
            Adds an element into the hash set. It might expand the capacity if needed.
            </summary>
            <param name="value">The value to add.</param>
            <returns><see langword="true"/> if the element was not set in the hash set.</returns>
        </member>
        <member name="M:Quantum.Collections.QHashSet`1.Remove(`0)">
            <summary>
            Removes the element from the hash set.
            </summary>
            <param name="value">The element to remove.</param>
            <returns>
            <see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/> if the element is not found in the dictionary.
            </returns>
        </member>
        <member name="M:Quantum.Collections.QHashSet`1.GetEnumerator">
            <summary>
            Returns an iterator that traverses through the <see cref="T:Quantum.Collections.QHashSet`1"/>.
            </summary>
            <returns>An enumerator object for the hash set.</returns>
        </member>
        <member name="M:Quantum.Collections.QHashSet`1.Allocate(Quantum.Allocator.FrameHeap,System.Int32)">
            <summary>
            Allocates a <see cref="T:Quantum.Collections.QHashSet`1"/> in the frame heap. It must be used before trying to resolve and use the hash set.
            </summary>
            <returns>The allocated <see cref="T:Quantum.Collections.QHashSet`1"/>.</returns>
        </member>
        <member name="T:Quantum.Collections.QHashSet">
            <summary>
            A Quantum hashset-like collection which uses the frame heap.
            This collection relies on Frame and on its API for allocating, deallocating and resolving.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QHashSet.Serialize``1(Quantum.Collections.QHashSetPtr{``0}*,Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes the <see cref="T:Quantum.Collections.QHashSet`1"/> Ptr into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The <see cref="T:Quantum.Collections.QHashSet`1"/> Ptr.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="valSerializer">A delegate for serializing the hash set values.</param>
        </member>
        <member name="T:Quantum.Collections.QHashSetPtr`1">
            <summary>
            Stores a <see cref="T:Quantum.Ptr"/> which points to the memory location of a <see cref="T:Quantum.Collections.QHashSet`1"/> inside the frame heap.
            </summary>
            <typeparam name="T">An unmanaged type.</typeparam>
        </member>
        <member name="F:Quantum.Collections.QHashSetPtr`1.Ptr">
            <summary>
            The pointer to the memory location of the <see cref="T:Quantum.Collections.QHashSet`1"/> inside the frame heap.<br/>
            To check if this collection is not allocated, check if this Ptr is not equals to <see cref="P:Quantum.Ptr.Null"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QHashSetPtr`1.#ctor(Quantum.Ptr)">
            <summary>
            Stores the pointer to the <see cref="T:Quantum.Collections.QHashSet`1"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QHashSetPtr`1.GetHashCode">
            <summary>
            Gets the hash code of the stored <see cref="T:Quantum.Ptr"/>.
            </summary>
            <returns>Returns the hash code of the stored <see cref="T:Quantum.Ptr"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QHashSetPtr`1.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QHashSetPtr`1.Equals(Quantum.Collections.QHashSetPtr{`0})">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Quantum.Collections.QHashSet`1"/> value.
            </summary>
            <param name="other">A <see cref="T:Quantum.Collections.QHashSet`1"/> value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QHashSetPtr`1.op_Equality(Quantum.Collections.QHashSetPtr{`0},Quantum.Collections.QHashSetPtr{`0})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.Collections.QHashSetPtr`1"/> are equal.
            </summary>
            <returns><see langword="true"/> if the instances are equal.</returns>
        </member>
        <member name="M:Quantum.Collections.QHashSetPtr`1.op_Inequality(Quantum.Collections.QHashSetPtr{`0},Quantum.Collections.QHashSetPtr{`0})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.Collections.QHashSetPtr`1"/> are not equal.
            </summary>
            <returns><see langword="true"/> if the instances are not equal.</returns>
        </member>
        <member name="T:Quantum.Collections.QHashSetIterator`1">
            <summary>
            An iterator for traversing the entries of a <see cref="T:Quantum.Collections.QHashSet`1"/>. This iterator allows for traversing the values stored within the hash set in a sequential manner.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QHashSetIterator`1.Current">
            <summary>
            Gets the current key-value pair in the <see cref="T:Quantum.Collections.QHashSet`1"/> based in the iterator state.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QHashSetIterator`1.ValuePtrUnsafe">
            <summary>
            Returns a pointer to the current value based on the iterator current element.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QHashSetIterator`1.MoveNext">
            <summary>
            Advances the iterator to the next element of the <see cref="T:Quantum.Collections.QHashSet`1"/>, which can be retrieved with <see cref="P:Quantum.Collections.QHashSetIterator`1.Current"/>.
            </summary>
            <returns><see langword="true"/> if the iterator is still in the boundaries of the <see cref="T:Quantum.Collections.QHashSet`1"/>.</returns>
        </member>
        <member name="T:Quantum.Collections.QListPtr`1">
            <summary>
            Stores a <see cref="T:Quantum.Ptr"/> which points to the memory location of a <see cref="T:Quantum.Collections.QList`1"/> inside the frame heap.
            </summary>
            <typeparam name="T">An unmanaged type.</typeparam>
        </member>
        <member name="F:Quantum.Collections.QListPtr`1.Ptr">
            <summary>
            The pointer to the memory location of the <see cref="T:Quantum.Collections.QList`1"/> inside the frame heap.<br/>
            To check if this collection is not allocated, check if this Ptr is not equals to <see cref="P:Quantum.Ptr.Null"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QListPtr`1.#ctor(Quantum.Ptr)">
            <summary>
            Stores the pointer to the <see cref="T:Quantum.Collections.QList`1"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QListPtr`1.GetHashCode">
            <summary>
            Gets the hash code of the stored <see cref="T:Quantum.Ptr"/>.
            </summary>
            <returns>Returns the hash code of the stored <see cref="T:Quantum.Ptr"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QListPtr`1.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QListPtr`1.Equals(Quantum.Collections.QListPtr{`0})">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Quantum.Collections.QList`1"/> value.
            </summary>
            <param name="other">A <see cref="T:Quantum.Collections.QList`1"/> value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QListPtr`1.op_Equality(Quantum.Collections.QListPtr{`0},Quantum.Collections.QListPtr{`0})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.Collections.QList`1"/> are equal.
            </summary>
            <returns><see langword="true"/> if the instances are equal.</returns>
        </member>
        <member name="M:Quantum.Collections.QListPtr`1.op_Inequality(Quantum.Collections.QListPtr{`0},Quantum.Collections.QListPtr{`0})">
            <summary>
            Operator override for which checks if two instances of <see cref="T:Quantum.Collections.QList`1"/> are not equal.
            </summary>
            <returns><see langword="true"/> if the instances are not equal.</returns>
        </member>
        <member name="T:Quantum.Collections.QList">
            <summary>
            A Quantum list-like collection which uses the frame heap.
            This collection relies on Frame and on its API for allocating, deallocating and resolving.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList.Serialize``1(Quantum.Collections.QListPtr{``0}*,Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes the <see cref="T:Quantum.Collections.QList`1"/> Ptr into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The <see cref="T:Quantum.Collections.QList`1"/> Ptr.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="itemSerializer">A delegate for serializing the list items.</param>
        </member>
        <member name="T:Quantum.Collections.QList`1">
            <summary>
            A Quantum list-like collection which uses the frame heap.
            This collection relies on Frame and on its API for allocating, deallocating and resolving.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QList`1.Count">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QList`1"/> current entries amount.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QList`1.Capacity">
            <summary>
            Gets the <see cref="T:Quantum.Collections.QList`1"/> current capacity. The capacity automatically expands, if necessary, when adding new entries.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QList`1.Item(System.Int32)">
            <summary>
            Gets or sets the value associated with the specified index.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList`1.Clear">
            <summary>
            Removes all elements from the list. It does not reset the list <see cref="P:Quantum.Collections.QList`1.Capacity"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList`1.Add(`0)">
            <summary>
            Adds an item into the list. It might expand the capacity if needed.
            </summary>
            <param name="item">The item to add.</param>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.SetCapacity(System.Int32)">
            <summary>
            Sets the capacity of the list.
            </summary>
            <param name="capacity">The new capacity value.</param>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.GetPointer(System.Int32)">
            <summary>
            Gets a pointer to the item on the specified index.
            </summary>
            <param name="index">The index to be found in the list.</param>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
            <exception cref="T:System.IndexOutOfRangeException">When the specified index is out of the list boundaries.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item on the list on the specified index. When removing items at the middle of the list, the rightmost items are shifted to the left so their relative order is maintained.
            </summary>
            <param name="index">The index to be found in the list.</param>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">When the specified index is out of the list boundaries.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.RemoveAtUnordered(System.Int32)">
            <summary>
            Removes the element on the list on the specified index. When removing items at the middle of the list, the last items in the list is moved to such position. The relative order is not maintained,
            but the remove cost is constant, does not matter the position of the removed item.
            </summary>
            <param name="index">The index to be found in the list.</param>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">When the specified index is out of the list boundaries.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns the index of the first occurrence within the list.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>
            The index of the first occurrence of the item within the list, if found. Otherwise, -1.
            </returns>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.LastIndexOf(`0)">
            <summary>
            Searches for the specified item and returns the index of the last occurrence within the list.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>
            The index of the last occurrence of the item within the list, if found. Otherwise, -1.
            </returns>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.Remove(`0)">
            <summary>
            Removes the specified item from the list. When the item is located at the middle of the list, the rightmost items are shifted to the left so their relative order is maintained.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>
            <see langword="true"/> if the item was found on the list.
            </returns>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.RemoveUnordered(`0)">
            <summary>
            Removes the specified item from the list. When the item is located at the middle of the list, the last element in the list is moved to such position. The relative order is not maintained,
            but the remove cost is constant, does not matter the position of the removed element.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>
            <see langword="true"/> if the item was found on the list.
            </returns>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.Contains(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Checks whether the list contains a specific item.
            </summary>
            <param name="item">The value to locate in the list.</param>
            <param name="comparer">An optional EqualityComparer.</param>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.GetIterator">
            <summary>
            Returns an iterator that traverses through the <see cref="T:Quantum.Collections.QList`1"/>.
            </summary>
            <returns>An iterator to traverse through the list.</returns>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.GetEnumerator">
            <summary>
            Returns an iterator that traverses through the <see cref="T:Quantum.Collections.QList`1"/>.
            </summary>
            <returns>An iterator to traverse through the list.</returns>
        </member>
        <member name="M:Quantum.Collections.QList`1.Allocate(Quantum.Allocator.FrameHeap,System.Int32)">
            <summary>
            Allocates a <see cref="T:Quantum.Collections.QList`1"/> in the frame heap. It must be used before trying to resolve and use the list.
            </summary>
            <returns>The allocated <see cref="T:Quantum.Collections.QList`1"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QList`1.Serialize(Quantum.Ptr*,Quantum.FrameSerializer,Quantum.FrameSerializer.Delegate)">
            <summary>
            Serializes the <see cref="T:Quantum.Collections.QList`1"/> Ptr into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The <see cref="T:Quantum.Collections.QList`1"/> Ptr.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
            <param name="itemSerializer">A delegate for serializing the <see cref="T:Quantum.Collections.QList`1"/> items.</param>
        </member>
        <member name="M:Quantum.Collections.QList`1.PrintQListPtr(Quantum.Collections.QListPtr{`0},Quantum.FramePrinter)">
            <summary>
            Prints the <see cref="T:Quantum.Collections.QList`1"/> data.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList`1.Print(Quantum.Ptr,Quantum.FramePrinter)">
            <summary>
            Prints the <see cref="T:Quantum.Collections.QList`1"/> data.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList`1.op_Implicit(Quantum.Collections.QList{`0})~Quantum.Collections.QListPtr{`0}">
            <summary>
            Operator which allocates a <see cref="T:Quantum.Collections.QList`1"/> based on another <see cref="T:Quantum.Collections.QList`1"/>.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList`1.Reverse">
            <summary>
            Reverses the order of the items in the list.
            </summary>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Collections.QList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in the entire list using the specified comparer.
            </summary>
            <para>
            The sorting uses Quicksort algorithm and produces and unstable sorting result, 
            which means that the relative order of equal elements is not guaranteed to be preserved.
            </para>
            <para>
            To remove randomness when sorting entities include the entity index in the comparison.
            </para>
            <param name="comparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing elements.
            If not informed, the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/> is used.
            </param>
            <exception cref="T:System.NullReferenceException">When either the FrameHeap or the list is <see langword="null"/>.</exception>
        </member>
        <member name="T:Quantum.Collections.QList`1.Iterator">
            <summary>
            An iterator for traversing the entries of a <see cref="T:Quantum.Collections.QList`1"/>. This iterator allows for traversing the entries stored within the list in a sequential manner.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList`1.Iterator.MoveNext">
            <summary>
            Advances the iterator to the next element of the <see cref="T:Quantum.Collections.QList`1"/>, which can be retrieved with <see cref="P:Quantum.Collections.QList`1.Iterator.Current"/>.
            </summary>
            <returns><see langword="true"/> if the iterator is still in the boundaries of the <see cref="T:Quantum.Collections.QList`1"/>.</returns>
        </member>
        <member name="M:Quantum.Collections.QList`1.Iterator.Reset">
            <summary>
            Resets the iterator to the initial position of the list.
            </summary>
        </member>
        <member name="P:Quantum.Collections.QList`1.Iterator.Current">
            <summary>
            Gets the current entry in the <see cref="T:Quantum.Collections.QList`1"/> based in the iterator state.
            </summary>
        </member>
        <member name="M:Quantum.Collections.QList`1.Iterator.Dispose">
            <summary>
            Disposes the <see cref="T:Quantum.Collections.QList`1"/>
            </summary>
        </member>
        <member name="T:Quantum.BitSetRef">
            <summary>
            A variable sized bitmask.
            </summary>
        </member>
        <member name="F:Quantum.BitSetRef.Bits">
            <summary>
            The unsinged long array that holds the bits.
            </summary>
        </member>
        <member name="F:Quantum.BitSetRef.BitsSize">
            <summary>
            The number of bit that the bitmask can hold.
            </summary>
        </member>
        <member name="M:Quantum.BitSetRef.#ctor(System.UInt64*,System.Int32)">
            <summary>
            Create a bitmask with the given bits and size.
            </summary>
            <param name="bits">The ulong array to save the bit information</param>
            <param name="bitsSize">The maximum bit index of the bitmask</param>
        </member>
        <member name="P:Quantum.BitSetRef.Length">
            <summary>
            Returns the size of the bitmask
            </summary>
        </member>
        <member name="M:Quantum.BitSetRef.Set(System.Int32)">
            <summary>
            Set a bit in the bitmask.
            </summary>
            <param name="bit">Bit index, must be less than <see cref="P:Quantum.BitSetRef.Length"/></param>
        </member>
        <member name="M:Quantum.BitSetRef.Clear(System.Int32)">
            <summary>
            Remove the bit from the bitmask.
            </summary>
            <param name="bit">Bit to remove, must be less than <see cref="P:Quantum.BitSetRef.Length"/></param>
        </member>
        <member name="M:Quantum.BitSetRef.ClearAll">
            <summary>
            Clear all bits in the bitmask.
            </summary>
        </member>
        <member name="M:Quantum.BitSetRef.IsSet(System.Int32)">
            <summary>
            Check if a bit is set in the bitmask.
            </summary>
            <param name="bit">Bit to check, must be less than <see cref="P:Quantum.BitSetRef.Length"/></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.BitSet1024">
            <summary>
            A bitmask with 1024 bits.
            </summary>
        </member>
        <member name="F:Quantum.BitSet1024.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.BitSet1024.ALIGNMENT">
            <summary>
            The alignment of the component.
             </summary>
        </member>
        <member name="F:Quantum.BitSet1024.Bits">
            <summary>
            The data that the bitmask is actually saved to.
            </summary>
        </member>
        <member name="F:Quantum.BitSet1024.BitsSize">
            <summary>
            The maximum number of bits that can be stored in this bitmask.
            </summary>
        </member>
        <member name="P:Quantum.BitSet1024.Length">
            <summary>
            The maximum number of bits that can be stored in this bitmask.
            </summary>
        </member>
        <member name="M:Quantum.BitSet1024.Print(System.Void*,Quantum.FramePrinter)">
            <summary>
            Prints the BitSet1024 using a <see cref="T:Quantum.FramePrinter"/>.
            </summary>
            <param name="ptr">Pointer to BitSet1024 instance</param>
            <param name="printer">Printer object</param>
        </member>
        <member name="M:Quantum.BitSet1024.FromArray(System.UInt64[])">
            <summary>
            Create a new BitSet1024 and initialize the data from an array.
            </summary>
            <param name="values">Array of UInt64 values</param>
        </member>
        <member name="M:Quantum.BitSet1024.Set(System.Int32)">
            <summary>
            Set a bit in the bitmask. 
            </summary>
            <param name="bit">Bit index, must be less than <see cref="P:Quantum.BitSet1024.Length"/></param>
        </member>
        <member name="M:Quantum.BitSet1024.Clear(System.Int32)">
            <summary>
            Clear a bit in the bitmask.
            </summary>
            <param name="bit">Bit index, must be less than <see cref="P:Quantum.BitSet1024.Length"/></param>
        </member>
        <member name="M:Quantum.BitSet1024.ClearAll">
            <summary>
            Clear all bits in the bitmask.
            </summary>
        </member>
        <member name="M:Quantum.BitSet1024.IsSet(System.Int32)">
            <summary>
            Check if a bit is set in the bitmask.
            </summary>
            <param name="bit">Bit index, must be less than <see cref="P:Quantum.BitSet1024.Length"/></param>
        </member>
        <member name="M:Quantum.BitSet1024.GetHashCode">
            <summary>
            Returns the hash code for the BitSet1024.
            </summary>
            <returns>The hash code for the BitSet1024.</returns>
        </member>
        <member name="M:Quantum.BitSet1024.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.BitSet1024"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.BitSet1024"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.ComponentTypeId">
             <summary>
             Runtime information for component types, containing their ID, size, flags and callbacks.
            
             Internally, types are identified as integers. Number assigned to a type is sequential (starting from 1), hence they are not persistent - any new
             component type is going to invalidate indices of other types that are registered after it.
             </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId.BuiltInComponentCount">
            <summary>
            The number of built-in components.
            </summary>
        </member>
        <member name="T:Quantum.ComponentTypeId.Builder">
            <summary>
            Builder for component type registry. This type is not meant to be used directly.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeId.Builder.AddBuiltInComponents">
            <summary>
            Add all built-in components to the builder.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeId.Builder.Add``1(Quantum.ComponentCallbacks,Quantum.ComponentFlags)">
            <summary>
            Add a component type.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeId.Builder.Add``1(Quantum.ComponentSerializeDelegate,Quantum.ComponentChangedDelegate,Quantum.ComponentChangedDelegate,Quantum.ComponentFlags)">
            <summary>
            Add a component type.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeId.Builder.Finish">
            <summary>
            Complete building the component type registry.
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId.Type">
            <summary>
            All registered component types. Index 0 is reserved for null.
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId.Size">
            <summary>
            Size of each component type in bytes. Index 0 is reserved for null.
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId.Flags">
            <summary>
            Flags for each component type. Index 0 is reserved for null.
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId.Callbacks">
            <summary>
            Callbacks for each component type. Index 0 is reserved for null.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeId.GetComponentIndex(System.Type)">
            <summary>
            Returns the index of the component type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.ComponentTypeId.GetComponentIndex(System.String)">
            <summary>
            Returns the index of the component type based on type's short name, i.e. the name without namespace.
            </summary>
            <param name="shortTypeName"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.ComponentTypeId.GetComponentIndex(Quantum.ComponentTypeRef)">
            <summary>
            Returns the index of the component type based on the type reference.
            </summary>
            <param name="componentType"></param>
            <returns></returns>
        </member>
        <member name="P:Quantum.ComponentTypeId.Count">
            <summary>
            Returns the number of component types registered plus one.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeId.GetComponentSize(System.Int32)">
            <summary>
            Returns the size of the component type identified by the index.
            </summary>
            <param name="index">The index of a type</param>
        </member>
        <member name="M:Quantum.ComponentTypeId.GetComponentType(System.Int32)">
            <summary>
            Returns the type of component identified by the index.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeId.GetComponentTypeRef(System.Int32)">
            <summary>
            Converts the type index to a component type reference. Component type references are persistent and can be used to identify types across different runs and builds.
            </summary>
            <seealso cref="T:Quantum.ComponentTypeRef"/>
        </member>
        <member name="M:Quantum.ComponentTypeId.Reset(System.Int32)">
            <summary>
            Resets the component type registry. This method is not meant to be used directly.
            </summary>
            <param name="componentCount">The expected number of component types</param>
        </member>
        <member name="T:Quantum.Prototypes.Transform2DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.Transform2D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Transform2DPrototype.Position">
            <summary>
            The entity's position.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Transform2DPrototype.Rotation">
            <summary>
            The entity's rotation, in degrees.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Transform2DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.Transform2D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="M:Quantum.Prototypes.Transform2DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.Transform2D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="T:Quantum.Prototypes.Transform3DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.Transform3D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Transform3DPrototype.Position">
            <summary>
            The entity's position.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Transform3DPrototype.Rotation">
            <summary>
            The entity's rotation, in degrees.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Transform3DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.Transform3D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="M:Quantum.Prototypes.Transform3DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.Transform3D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="T:Quantum.Prototypes.Transform2DVerticalPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.Transform2DVertical"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Transform2DVerticalPrototype.Position">
            <summary>
            The vertical offset position.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Transform2DVerticalPrototype.Height">
            <summary>
            The vertical height.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Transform2DVerticalPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.Transform2DVertical"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="M:Quantum.Prototypes.Transform2DVerticalPrototype.Materialize(Quantum.Core.FrameBase,Quantum.Transform2DVertical@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsCollider2DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsCollider2D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider2DPrototype.ShapeConfig">
            <summary>
            The definition of the physics collider's shape.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider2DPrototype.Layer">
            <summary>
            The physics collider's layer.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider2DPrototype.IsTrigger">
            <summary>
            Set to <see langword="true"/> to make the physics collider a trigger collider.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider2DPrototype.PhysicsMaterial">
            <summary>
            The physics collider's physics material asset.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsCollider2DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.PhysicsCollider2D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsCollider2DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsCollider2D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsBody2DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsBody2D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.Config">
            <summary>
            The configuration flags used by the PhysicsBody.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.Mass">
            <summary>
            The PhysicsBody's mass.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.Drag">
            <summary>
            The PhysicsBody's drag.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.AngularDrag">
            <summary>
            The PhysicsBody's angular drag.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.CenterOfMass">
            <summary>
            The PhysicsBody's center of mass.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.GravityScale">
            <summary>
            The PhysicsBody's gravity scale.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.InertiaScale">
            <summary>
            The scale of the body inertia tensor. 
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.InertiaMode">
            <summary>
            The mode in which the body's inertia tensor is computed.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.ExplicitInertia">
            <summary>
            The body inertia tensor when <see cref="F:Quantum.Prototypes.PhysicsBody2DPrototype.InertiaMode"/> is set to <see cref="F:Quantum.Prototypes.PhysicsBodyInertiaMode.Explicit"/>. 
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody2DPrototype.ParametricInertiaShape">
            <summary>
            The parametric shape used to compute the body inertia tensor when <see cref="F:Quantum.Prototypes.PhysicsBody2DPrototype.InertiaMode"/> is set to <see cref="F:Quantum.Prototypes.PhysicsBodyInertiaMode.ParametricShape"/>. 
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsBody2DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.PhysicsBody2D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsBody2DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsBody2D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsCollider3DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsCollider3D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider3DPrototype.ShapeConfig">
            <summary>
            The definition of the physics collider's shape.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider3DPrototype.Layer">
            <summary>
            The physics collider's layer.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider3DPrototype.IsTrigger">
            <summary>
            Set to <see langword="true"/> to make the physics collider a trigger collider.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCollider3DPrototype.PhysicsMaterial">
            <summary>
            The physics collider's physics material asset.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsCollider3DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.PhysicsCollider3D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsCollider3DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsCollider3D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsBody3DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsBody3D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.Config">
            <summary>
            The configuration flags used by the PhysicsBody.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.Mass">
            <summary>
            The PhysicsBody's mass.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.Drag">
            <summary>
            The PhysicsBody's drag.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.AngularDrag">
            <summary>
            The PhysicsBody's angular drag.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.CenterOfMass">
            <summary>
            The PhysicsBody's center of mass.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.RotationFreeze">
            <summary>
            The PhysicsBody's rotation freeze flags.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.GravityScale">
            <summary>
            The PhysicsBody's gravity scale.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.InertiaScale">
            <summary>
            The scale of the body inertia tensor. 
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.InertiaMode">
            <summary>
            The mode in which the body's inertia tensor is computed.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.ExplicitInertiaTensor">
            <summary>
            The body inertia tensor when <see cref="F:Quantum.Prototypes.PhysicsBody3DPrototype.InertiaMode"/> is set to <see cref="F:Quantum.Prototypes.PhysicsBodyInertiaMode.Explicit"/>. 
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBody3DPrototype.ParametricInertiaShape">
            <summary>
            The parametric shape used to compute the body inertia tensor when <see cref="F:Quantum.Prototypes.PhysicsBody3DPrototype.InertiaMode"/> is set to <see cref="F:Quantum.Prototypes.PhysicsBodyInertiaMode.ParametricShape"/>. 
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsBody3DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.PhysicsBody3D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsBody3DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsBody3D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsJoints2DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsJoints2D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsJoints2DPrototype.JointConfigs">
            <summary>
            The configurations of the joints.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsJoints2DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsJoints2D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsJoints2DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.PhysicsJoints2D@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
            <param name="context"></param>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsJoints2DPrototype.OnEntityPrototypeMaterialized(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityPrototypeRef)">
            <summary>
            Called after the entity prototype has been completely materialized.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="prototypeRef"></param>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsJoints3DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsJoints3D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsJoints3DPrototype.JointConfigs">
            <summary>
            The configurations of the joints.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsJoints3DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsJoints3D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsJoints3DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.PhysicsJoints3D@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
            <param name="context"></param>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsJoints3DPrototype.OnEntityPrototypeMaterialized(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityPrototypeRef)">
            <summary>
            Called after the entity prototype has been completely materialized.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="prototypeRef"></param>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsCallbacks2DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsCallbacks2D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCallbacks2DPrototype.CallbackFlags">
            <summary>
            The physics callbacks flags.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsCallbacks2DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsCallbacks2D"/> component, adds it to the entity and fills it with the prototype data.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsCallbacks3DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.PhysicsCallbacks3D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsCallbacks3DPrototype.CallbackFlags">
            <summary>
            The physics callbacks flags.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.PhysicsCallbacks3DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.PhysicsCallbacks3D"/> component, adds it to the entity and fills it with the prototype data.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.CharacterController2DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.CharacterController2D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.CharacterController2DPrototype.Config">
            <summary>
            The CharacterController2D configuration asset.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.CharacterController2DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.CharacterController2D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="M:Quantum.Prototypes.CharacterController2DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.CharacterController2D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.CharacterController3DPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.CharacterController3D"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.CharacterController3DPrototype.Config">
            <summary>
            The CharacterController3D configuration asset.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.CharacterController3DPrototype.Materialize(Quantum.Core.FrameBase,Quantum.CharacterController3D@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="M:Quantum.Prototypes.CharacterController3DPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.CharacterController3D"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.NavMeshPathfinderPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.NavMeshPathfinder"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshPathfinderPrototype.AgentConfig">
            <summary>
            The configuration asset with the setup for this nav mesh agent.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshPathfinderPrototype.InitialTarget">
            <summary>
            An initial position which is automatically set as a target when this prototype is materialized.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshPathfinderPrototype.InitialTargetNavMesh">
            <summary>
            The NavMesh asset used to set an initial target position when this prototype is materialized.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshPathfinderPrototype.InitialTargetNavMeshName">
            <summary>
            The name of the NavMesh used to set an initial target position when this prototype is materialized.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.NavMeshPathfinderPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.NavMeshPathfinder"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="M:Quantum.Prototypes.NavMeshPathfinderPrototype.Materialize(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshPathfinder@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="entity"></param>
            <param name="result"></param>
        </member>
        <member name="T:Quantum.Prototypes.NavMeshSteeringAgentPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.NavMeshSteeringAgent"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshSteeringAgentPrototype.OverrideMaxSpeed">
            <summary>
            Set to <see langword="true"/> to override the steering agent's MaxSpeed with a value from the prototype, instead of using the value from the nav mesh agent config asset.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshSteeringAgentPrototype.OverrideAcceleration">
            <summary>
            Set to <see langword="true"/> to override the steering agent's Acceleration with a value from the prototype, instead of using the value from the nav mesh agent config asset.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshSteeringAgentPrototype.MaxSpeed">
            <summary>
            Used to override the steering agent's MaxSpeed, instead of using the value from the nav mesh agent config asset.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshSteeringAgentPrototype.Acceleration">
            <summary>
            Used to override the steering agent's Acceleration, instead of using the value from the nav mesh agent config asset.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.NavMeshSteeringAgentPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.NavMeshSteeringAgent"/> component and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.NavMeshAvoidanceAgentPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.NavMeshAvoidanceAgent"/> Quantum component.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.NavMeshAvoidanceAgentPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.NavMeshAvoidanceAgent"/> component, and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.NavMeshAvoidanceObstaclePrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.NavMeshAvoidanceObstacle"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshAvoidanceObstaclePrototype.AvoidanceLayer">
            <summary>
            The layer to be included or excluded in other agents masks. <see cref="P:Quantum.NavMeshAvoidanceAgent.AvoidanceMask"/>.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshAvoidanceObstaclePrototype.Radius">
            <summary>
            The avoidance radius.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.NavMeshAvoidanceObstaclePrototype.IsActive">
            <summary>
            If set to <see langword="true"/>, the obstacle is considered by avoidance agents.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.NavMeshAvoidanceObstaclePrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.NavMeshAvoidanceObstacle"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="M:Quantum.Prototypes.NavMeshAvoidanceObstaclePrototype.Materialize(Quantum.Core.FrameBase,Quantum.NavMeshAvoidanceObstacle@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="T:Quantum.Prototypes.ViewPrototype">
            <summary>
            Prototype of the <see cref="T:Quantum.View"/> Quantum component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.ViewPrototype.Current">
            <summary>
            The EntityView asset to be referenced by the View component.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.ViewPrototype.Materialize(Quantum.Core.FrameBase,Quantum.View@)">
            <summary>
            Applies the prototype's fields to the actual component.
            </summary>
            <param name="frame"></param>
            <param name="result"></param>
        </member>
        <member name="M:Quantum.Prototypes.ViewPrototype.AddToEntity(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Creates an instance of the <see cref="T:Quantum.View"/> component, materializes and adds it to the entity.
            </summary>
            <param name="f"></param>
            <param name="entity"></param>
            <param name="context"></param>
            <returns>Returns <see langword="true"/> if adding the component to the entity succeeds.</returns>
        </member>
        <member name="T:Quantum.Prototypes.Joint2DConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics2D.Joint"/> struct of any type.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.StartDisabled">
            <summary>
            If the joint should be materialized with <see cref="P:Quantum.Physics2D.Joint.Enabled"/> set to <see langword="false"/>,
            not being considered by the Physics Engine.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.JointType">
            <inheritdoc cref="P:Quantum.Physics2D.Joint.Type"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.UserTag">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.ConnectedEntity">
            <summary>
            A Map Entity that the joint might be connected to.
            The entity must have at least a Transform2D component prototype.
            <seealso cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.Anchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.Frequency">
            <summary>
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate.
            Typical values are below half the frequency of the simulation.
            <seealso cref="M:Quantum.Physics2D.SpringJoint.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.DampingRatio">
            <summary>
            A dimensionless value representing the damper capacity of
            suppressing the spring oscillation, typically between 0 and 1.
            <seealso cref="M:Quantum.Physics2D.SpringJoint.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.AutoConfigureDistance">
            <summary>
            Automatically configure the target Distance to be the current distance between the anchor points in the scene.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.Distance">
            <inheritdoc cref="F:Quantum.Physics2D.SpringJoint.Distance"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.MinDistance">
            <inheritdoc cref="P:Quantum.Physics2D.DistanceJoint.MinDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.MaxDistance">
            <inheritdoc cref="P:Quantum.Physics2D.DistanceJoint.MaxDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.UseAngleLimits">
            <summary>
            If the relative angle between the joint transform and its connected anchor should be limited by the hinge joint.
            Set this checkbox to configure the lower and upper limiting angles.
            <seealso cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.LowerAngle">
            <summary>
            The lower limiting angle of the allowed arc of rotation around the connected anchor, in degrees.
            <seealso cref="F:Quantum.Physics2D.HingeJoint.LowerLimitRad"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.UpperAngle">
            <summary>
            The upper limiting  angle of the allowed arc of rotation around the connected anchor, in degrees.
            <seealso cref="F:Quantum.Physics2D.HingeJoint.UpperLimitRad"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.UseMotor">
            <summary>
            If the hinge joint uses a motor. Set this checkbox to configure the motor speed and max torque.
            <seealso cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.MotorSpeed">
            <summary>
            The speed at which the hinge motor will attempt to rotate, in degrees per second.
            <seealso cref="F:Quantum.Physics2D.HingeJoint.MotorSpeed"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint2DConfig.MaxMotorTorque">
            <summary>
            The maximum torque produced by the hinge motor in order to achieve the target motor speed.
            Leave this checkbox unchecked and the motor toque should not be limited.
            <seealso cref="F:Quantum.Physics2D.HingeJoint.MaxMotorTorque"/>
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Joint2DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics2D.Joint"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.Joint2DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.EntityRef,Quantum.EntityRef)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics2D.Joint"/> resultant of this materialization.</param>
            <param name="jointEntityRef">The entity that owns the materialized joint</param>
            <param name="connectedAnchorEntityRef">An optional entity to which the joint entity is connected to. See <see cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedEntity"/>.</param>
        </member>
        <member name="M:Quantum.Prototypes.Joint2DConfig.OnEntityPrototypeMaterializedJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityPrototypeRef,Quantum.Physics2D.Joint*)">
            <summary>
            Obsolete. Use 'OnEntityPrototypeMaterializedJoint(FrameBase, EntityRef, Joint*)' overload.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Joint2DConfig.OnEntityPrototypeMaterializedJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics2D.Joint*)">
            <summary>
            Callback called after the full materialization of an <see cref="T:Quantum.EntityPrototype"/>
            that contains a <paramref name="joint"/> materialized by this prototype.
            </summary>
            <param name="f">The frame in which this prototype was materialized.</param>
            <param name="entity">The entity into which this joint prototype has been materialized.</param>
            <param name="joint">A pointer to the joint materialized by this prototype.</param>
        </member>
        <member name="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase)">
            <summary>
            Obsolete. Use the 'CreateJoint(FrameBase f, EntityRef, EntityRef)' overload.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <summary>
            Materializes the prototype for a given entity reference.
            </summary>
            <param name="f">The frame in which this prototype is being materialized.</param>
            <param name="jointEntityRef">The entity that owns the materialized joint</param>
            <param name="connectedAnchorEntityRef">An optional entity to which the joint entity is connected to. See <see cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedEntity"/>.</param>
            <returns>The materialized <see cref="T:Quantum.Physics2D.Joint"/>.</returns>
        </member>
        <member name="T:Quantum.Prototypes.DistanceJointConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics2D.Joint"/> struct of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.StartDisabled">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.StartDisabled"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.UserTag">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedEntity"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.Anchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.AutoConfigureDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.AutoConfigureDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.MinDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.MinDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJointConfig.MaxDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.MaxDistance"/>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJointConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics2D.Joint"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJointConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJointConfig.CreateJoint(Quantum.Core.FrameBase)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJointConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="T:Quantum.Prototypes.HingeJointConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics2D.Joint"/> struct of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.StartDisabled">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.StartDisabled"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.UserTag">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedEntity"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.Anchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.UseAngleLimits">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.UseAngleLimits"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.LowerAngle">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.LowerAngle"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.UpperAngle">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.UpperAngle"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.UseMotor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.UseMotor"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.MotorSpeed">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.MotorSpeed"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJointConfig.MaxMotorTorque">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.MaxMotorTorque"/>
        </member>
        <member name="M:Quantum.Prototypes.HingeJointConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics2D.Joint"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.HingeJointConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.Prototypes.HingeJointConfig.CreateJoint(Quantum.Core.FrameBase)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Prototypes.HingeJointConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="T:Quantum.Prototypes.SpringJointConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics2D.Joint"/> struct of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.StartDisabled">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.StartDisabled"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.UserTag">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedEntity"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.Anchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.Frequency">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.Frequency"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.DampingRatio">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.DampingRatio"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.AutoConfigureDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.AutoConfigureDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJointConfig.Distance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint2DConfig.Distance"/>
        </member>
        <member name="M:Quantum.Prototypes.SpringJointConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics2D.Joint"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.SpringJointConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.Prototypes.SpringJointConfig.CreateJoint(Quantum.Core.FrameBase)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Prototypes.SpringJointConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint2DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="T:Quantum.Prototypes.Joint3DConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics3D.Joint3D"/> struct of any type.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.StartDisabled">
            <summary>
            If the joint should be materialized with <see cref="P:Quantum.Physics3D.Joint3D.Enabled"/> set to <see langword="false"/>,
            not being considered by the Physics Engine.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.JointType">
            <inheritdoc cref="P:Quantum.Physics3D.Joint3D.Type"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.UserTag">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.ConnectedEntity">
            <summary>
            A Map Entity that the joint might be connected to.
            The entity must have at least a transform component prototype.
            <seealso cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.Anchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.Axis">
            <summary>
            Axis around which the joint rotates, defined in the local space of the entity.
            The vector is normalized before set. If zeroed, FPVector3.Right is used instead.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.Frequency">
            <summary>
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate.
            Typical values are below half the frequency of the simulation.
            <seealso cref="M:Quantum.Physics3D.SpringJoint3D.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.DampingRatio">
            <summary>
            A dimensionless value representing the damper capacity of
            suppressing the spring oscillation, typically between 0 and 1.
            <seealso cref="M:Quantum.Physics3D.SpringJoint3D.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.AutoConfigureDistance">
            <summary>
            Automatically configure the target Distance to be the current distance between the anchor points in the scene.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.Distance">
            <inheritdoc cref="F:Quantum.Physics3D.SpringJoint3D.Distance"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.MinDistance">
            <inheritdoc cref="P:Quantum.Physics3D.DistanceJoint3D.MinDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.MaxDistance">
            <inheritdoc cref="P:Quantum.Physics3D.DistanceJoint3D.MaxDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.UseAngleLimits">
            <summary>
            If the relative angle between the joint transform and its connected anchor should be limited by the hinge joint.
            Set this checkbox to configure the lower and upper limiting angles.
            <seealso cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.LowerAngle">
            <summary>
            The lower limiting angle of the allowed arc of rotation around the connected anchor, in degrees.
            <seealso cref="F:Quantum.Physics3D.HingeJoint3D.LowerLimitRad"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.UpperAngle">
            <summary>
            The upper limiting  angle of the allowed arc of rotation around the connected anchor, in degrees.
            <seealso cref="F:Quantum.Physics3D.HingeJoint3D.UpperLimitRad"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.UseMotor">
            <summary>
            If the hinge joint uses a motor. Set this checkbox to configure the motor speed and max torque.
            <seealso cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.MotorSpeed">
            <summary>
            The speed at which the hinge motor will attempt to rotate, in degrees per second.
            <seealso cref="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed"/>
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.Joint3DConfig.MaxMotorTorque">
            <summary>
            The maximum torque produced by the hinge motor in order to achieve the target motor speed.
            Leave this checkbox unchecked and the motor toque should not be limited.
            <seealso cref="F:Quantum.Physics3D.HingeJoint3D.MaxMotorTorque"/>
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Joint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics3D.Joint3D"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.Joint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.EntityRef,Quantum.EntityRef)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics3D.Joint3D"/> resultant of this materialization.</param>
            <param name="jointEntityRef">The entity that owns the materialized joint</param>
            <param name="connectedAnchorEntityRef">An optional entity to which the joint entity is connected to. See <see cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedEntity"/>.</param>
        </member>
        <member name="M:Quantum.Prototypes.Joint3DConfig.OnEntityPrototypeMaterializedJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityPrototypeRef,Quantum.Physics3D.Joint3D*)">
            <summary>
            Obsolete. Use 'OnEntityPrototypeMaterializedJoint(FrameBase, EntityRef, Joint3D*)' overload.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Joint3DConfig.OnEntityPrototypeMaterializedJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics3D.Joint3D*)">
            <summary>
            Callback called after the full materialization of an <see cref="T:Quantum.EntityPrototype"/>
            that contains a <paramref name="joint"/> materialized by this prototype.
            </summary>
            <param name="f">The frame in which this prototype was materialized.</param>
            <param name="entity">The entity into which this joint prototype has been materialized.</param>
            <param name="joint">A pointer to the joint materialized by this prototype.</param>
        </member>
        <member name="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase)">
            <summary>
            Obsolete. Use the 'CreateJoint(FrameBase f, EntityRef, EntityRef)' overload.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <summary>
            Materializes the prototype for a given entity reference.
            </summary>
            <param name="f">The frame in which this prototype is being materialized.</param>
            <param name="jointEntityRef">The entity that owns the materialized joint</param>
            <param name="connectedAnchorEntityRef">An optional entity to which the joint entity is connected to. See <see cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedEntity"/>.</param>
            <returns>The materialized <see cref="T:Quantum.Physics3D.Joint3D"/>.</returns>
        </member>
        <member name="T:Quantum.Prototypes.DistanceJoint3DConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics3D.Joint3D"/> struct of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.StartDisabled">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.StartDisabled"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.UserTag">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedEntity"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.Anchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.AutoConfigureDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.AutoConfigureDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.MinDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.MinDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.DistanceJoint3DConfig.MaxDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.MaxDistance"/>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJoint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics3D.Joint3D"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJoint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJoint3DConfig.CreateJoint(Quantum.Core.FrameBase)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Prototypes.DistanceJoint3DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="T:Quantum.Prototypes.HingeJoint3DConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics3D.Joint3D"/> struct of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.StartDisabled">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.StartDisabled"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.UserTag">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedEntity"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.Anchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.Axis">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.Axis"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.UseAngleLimits">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.UseAngleLimits"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.LowerAngle">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.LowerAngle"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.UpperAngle">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.UpperAngle"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.UseMotor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.UseMotor"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.MotorSpeed">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.MotorSpeed"/>
        </member>
        <member name="F:Quantum.Prototypes.HingeJoint3DConfig.MaxMotorTorque">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.MaxMotorTorque"/>
        </member>
        <member name="M:Quantum.Prototypes.HingeJoint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics3D.Joint3D"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.HingeJoint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.Prototypes.HingeJoint3DConfig.CreateJoint(Quantum.Core.FrameBase)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Prototypes.HingeJoint3DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="T:Quantum.Prototypes.SpringJoint3DConfig">
            <summary>
            Defines a prototype of a <see cref="T:Quantum.Physics3D.Joint3D"/> struct of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.StartDisabled">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.StartDisabled"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.UserTag">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.UserTag"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedEntity"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.ConnectedAnchor"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.Anchor">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.Anchor"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.Frequency">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.Frequency"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.DampingRatio">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.DampingRatio"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.AutoConfigureDistance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.AutoConfigureDistance"/>
        </member>
        <member name="F:Quantum.Prototypes.SpringJoint3DConfig.Distance">
            <inheritdoc cref="F:Quantum.Prototypes.Joint3DConfig.Distance"/>
        </member>
        <member name="M:Quantum.Prototypes.SpringJoint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materializes this joint prototype into a <paramref name="joint"/> instance.
            </summary>
            <param name="frame">The frame in which this prototype is being materialized.</param>
            <param name="joint">The <see cref="T:Quantum.Physics3D.Joint3D"/> resultant of this materialization.</param>
            <param name="context">The <see cref="T:Quantum.PrototypeMaterializationContext"/> in which this prototype is being materialized.</param>
        </member>
        <member name="M:Quantum.Prototypes.SpringJoint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.Materialize(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.Prototypes.SpringJoint3DConfig.CreateJoint(Quantum.Core.FrameBase)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Prototypes.SpringJoint3DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Prototypes.Joint3DConfig.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityRef)"/>
        </member>
        <member name="T:Quantum.Prototypes.DictionaryEntry">
            <summary>
            A base class for dictionary entries. For maximum compatibility with Unity, dictionaries in prototypes are serialized
            as an array of entries, rather than a dictionary.
            </summary>
        </member>
        <member name="T:Quantum.Prototypes.PhysicsBodyInertiaMode">
            <summary>
            Enumerates different ways to compute the inertia tensor of a dynamic body.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBodyInertiaMode.ColliderShape">
            <summary>
            The inertia tensor is computed based on the shape of the entity collider,
            assuming a uniform distribution of Mass over the collider area (2D) or volume (3D). 
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBodyInertiaMode.ParametricShape">
            <summary>
            The inertia tensor is computed based on a specific shape (not necessarily the colliders shape),
            assuming a uniform distribution of Mass over the collider area (2D) or volume (3D). 
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.PhysicsBodyInertiaMode.Explicit">
            <summary>
            The inertia tensor is set to be a value explicitly configured.
            In this mode, neither the Mass of the body nor the shape of the collider affect the body's inertia.
            </summary>
        </member>
        <member name="T:Quantum.Prototypes.PrototypeAttribute">
            <summary>
            Attribute to mark a class as a prototype of a struct or a component. Automatically applied by the CodeGen.
            </summary>
            <param name="type">Type of the struct/component.</param>
        </member>
        <member name="M:Quantum.Prototypes.PrototypeAttribute.#ctor(System.Type)">
            <summary>
            Attribute to mark a class as a prototype of a struct or a component. Automatically applied by the CodeGen.
            </summary>
            <param name="type">Type of the struct/component.</param>
        </member>
        <member name="P:Quantum.Prototypes.PrototypeAttribute.Type">
            <summary>
            Type of the prototype.
            </summary>
        </member>
        <member name="T:Quantum.Prototypes.FrameTimerPrototype">
            <summary>
            Prototype to create a <see cref="T:Quantum.FrameTimer"/> component.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.FrameTimerPrototype.Mode">
            <summary>
            The mode how to track the time.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.FrameTimerPrototype.Frames">
            <summary>
            The number of frames to count.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.FrameTimerPrototype.Seconds">
            <summary>
            The number of seconds to count.
            </summary>
        </member>
        <member name="M:Quantum.Prototypes.FrameTimerPrototype.Materialize(Quantum.Core.FrameBase,Quantum.FrameTimer@,Quantum.PrototypeMaterializationContext@)">
            <summary>
            Materialized the prototype into the <see cref="T:Quantum.FrameTimer"/> component. 
            </summary>
            <param name="frame">Frame</param>
            <param name="result">Resulting component</param>
            <param name="context">Materialization context</param>
        </member>
        <member name="T:Quantum.Prototypes.FrameTimerPrototypeMode">
            <summary>
            The mode how to keep track of the time.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.FrameTimerPrototypeMode.Frames">
            <summary>
            Count the number of frames.
            </summary>
        </member>
        <member name="F:Quantum.Prototypes.FrameTimerPrototypeMode.Seconds">
            <summary>
            Count the number of seconds.
            </summary>
        </member>
        <member name="T:Quantum.Button">
            <summary>
            The Quantum button used for player input.
            Instead of using bools or similar data types to represent key presses, the Button type is used inside the Input DSL definition. 
            This is because it only uses one bit per instance, so it is favorable to use where possible. 
            Although they only use one bit over the network, locally they will contain a bit more game state. 
            This is because the single bit is only representative of whether or not the button was pressed during the current frame, 
            the rest of the information is computed locally.
            </summary>
        </member>
        <member name="F:Quantum.Button.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="P:Quantum.Button.IsDown">
            <summary>
            Is the button currently down.
            </summary>
        </member>
        <member name="P:Quantum.Button.WasPressed">
            <summary>
            Was the button pressed this frame.
            </summary>
        </member>
        <member name="P:Quantum.Button.WasReleased">
            <summary>
            Was the button released this frame.
            </summary>
        </member>
        <member name="M:Quantum.Button.Update(System.Int32,System.Boolean)">
            <summary>
            Updates the button state.
            This is called from the code-generated Quantum input methods.
            </summary>
            <param name="frame">New frame</param>
            <param name="state">New button state</param>
            <returns>The updated button.</returns>
        </member>
        <member name="M:Quantum.Button.op_Implicit(Quantum.Button)~System.Boolean">
            <summary>
            Casts a button to <see cref="P:Quantum.Button.IsDown"/>.
            </summary>
            <param name="k">Button to check</param>
        </member>
        <member name="M:Quantum.Button.op_Implicit(System.Boolean)~Quantum.Button">
            <summary>
            Creates a button from the boolean value.
            </summary>
            <param name="k">Creates configured button representing a recently pressed button</param>
        </member>
        <member name="M:Quantum.Button.Serialize(Quantum.Button*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Button"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Button"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Button.ToString">
            <summary>
            Converts the numeric value of this instance to its equivalent string representation.
            </summary>
            <returns>The string representation of the value of this instance</returns>
        </member>
        <member name="M:Quantum.Button.GetHashCode">
            <summary>
            Overrides the default hash function.
            </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Quantum.CallbackBase">
            <summary>
            The base class for callbacks adds an id to the callback.
            </summary>
        </member>
        <member name="P:Quantum.CallbackBase.Game">
            <summary>
            The game that the callback is dispatched to.
            </summary>
        </member>
        <member name="F:Quantum.CallbackBase.ID">
            <summary>
            The callback id.
            </summary>
        </member>
        <member name="M:Quantum.CallbackBase.#ctor(System.Int32)">
            <summary>
            Create the callback with an id.
            </summary>
            <param name="id">Callback id</param>
        </member>
        <member name="M:Quantum.CallbackBase.#ctor(System.Int32,Photon.Deterministic.IDeterministicGame)">
            <summary>
            Creates a callback with an id and a game.
            </summary>
            <param name="id">Callback id</param>
            <param name="game">Game reference</param>
        </member>
        <member name="T:Quantum.ComponentSerializeDelegate">
            <summary>
            The signature that components are serialized with when creating frame snapshots.
            </summary>
            <param name="component">The pointer to the component in the frame memory</param>
            <param name="serializer">The serializer to write or read the component</param>
        </member>
        <member name="T:Quantum.ComponentChangedDelegate">
            <summary>
            The signature that components are signaled with changes like adding or removing.
            </summary>
            <param name="frame">The frame</param>
            <param name="entity">The entity the component belongs to</param>
            <param name="component">The component that was added or removed</param>
        </member>
        <member name="T:Quantum.ComponentCallbacks">
            <summary>
            Component callbacks.
            </summary>
        </member>
        <member name="F:Quantum.ComponentCallbacks.Serialize">
            <summary>
            Frame serialization callback.
            </summary>
        </member>
        <member name="F:Quantum.ComponentCallbacks.OnAdded">
            <summary>
            Component added callback.
            </summary>
        </member>
        <member name="F:Quantum.ComponentCallbacks.OnRemoved">
            <summary>
            Component removed callback.
            </summary>
        </member>
        <member name="M:Quantum.ComponentCallbacks.#ctor(Quantum.ComponentSerializeDelegate)">
            <summary>
            Create a callback object with serialization only.
            </summary>
            <param name="serialize">Serialization callback</param>
        </member>
        <member name="M:Quantum.ComponentCallbacks.#ctor(Quantum.ComponentSerializeDelegate,Quantum.ComponentChangedDelegate,Quantum.ComponentChangedDelegate)">
            <summary>
            Create a callback object.
            </summary>
            <param name="serialize">Serialization callback</param>
            <param name="onAdded">Component added callback</param>
            <param name="onRemoved">Component removed callback</param>
        </member>
        <member name="T:Quantum.IComponent">
            <summary>
            The interface to identify Quantum components.
            </summary>
        </member>
        <member name="T:Quantum.IComponentSingleton">
            <summary>
            The interface to identify Quantum singleton components.
            </summary>
        </member>
        <member name="T:Quantum.ComponentFlags">
            <summary>
            Component type flags.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFlags.None">
            <summary>
            Normal component.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFlags.Singleton">
            <summary>
            Singleton component.
            </summary>
        </member>
        <member name="T:Quantum.ComponentBlockIterator`1">
            <summary>
            Component block iterators give the fastest possible access via pointers.
            </summary>
            <typeparam name="T">Component type to iterate over</typeparam>
        </member>
        <member name="T:Quantum.ComponentBlockIterator`1.Enumerator">
            <summary>
            ComponentBlockIterator enumerator object.
            </summary>
        </member>
        <member name="P:Quantum.ComponentBlockIterator`1.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Quantum.ComponentBlockIterator`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:Quantum.ComponentBlockIterator`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection of components.
            </summary>
            <returns>An Enumerator object that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:Quantum.ComponentDataBuffer.Count">
            <summary>
            How many valid entries in the buffer are currently filled with data,
            either actively linked to an entity or with pending removal.
            Note: The first buffer entry (index 0) is always invalid and not used.
            </summary>
        </member>
        <member name="P:Quantum.ComponentDataBuffer.UsedCount">
            <summary>
            How many valid entries in the buffer are currently filled with data and
            are actively linked to an existing entity, i.e. entries with pending removal are not included.
            </summary>
        </member>
        <member name="T:Quantum.ComponentFilter`1">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`1.UseCulling">
            <summary>
            (Prediction-) Culled entities are removed from the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`1.Next(Quantum.EntityRef@,`0@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`1.NextUnsafe(Quantum.EntityRef@,`0*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilter`2">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`2.UseCulling">
            <summary>
            Include culled entities in the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`2.Next(Quantum.EntityRef@,`0@,`1@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
            <param name="component1">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`2.NextUnsafe(Quantum.EntityRef@,`0*@,`1*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
            <param name="component1">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilter`3">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`3.UseCulling">
            <summary>
            Include culled entities in the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`3.Next(Quantum.EntityRef@,`0@,`1@,`2@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
            <param name="component1">The component</param>
            <param name="component2">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`3.NextUnsafe(Quantum.EntityRef@,`0*@,`1*@,`2*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
            <param name="component1">The unsafe component pointer</param>
            <param name="component2">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilter`4">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`4.UseCulling">
            <summary>
            Include culled entities in the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`4.Next(Quantum.EntityRef@,`0@,`1@,`2@,`3@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
            <param name="component1">The component</param>
            <param name="component2">The component</param>
            <param name="component3">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`4.NextUnsafe(Quantum.EntityRef@,`0*@,`1*@,`2*@,`3*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
            <param name="component1">The unsafe component pointer</param>
            <param name="component2">The unsafe component pointer</param>
            <param name="component3">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilter`5">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`5.UseCulling">
            <summary>
            Include culled entities in the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`5.Next(Quantum.EntityRef@,`0@,`1@,`2@,`3@,`4@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
            <param name="component1">The component</param>
            <param name="component2">The component</param>
            <param name="component3">The component</param>
            <param name="component4">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`5.NextUnsafe(Quantum.EntityRef@,`0*@,`1*@,`2*@,`3*@,`4*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
            <param name="component1">The unsafe component pointer</param>
            <param name="component2">The unsafe component pointer</param>
            <param name="component3">The unsafe component pointer</param>
            <param name="component4">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilter`6">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`6.UseCulling">
            <summary>
            Include culled entities in the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`6.Next(Quantum.EntityRef@,`0@,`1@,`2@,`3@,`4@,`5@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
            <param name="component1">The component</param>
            <param name="component2">The component</param>
            <param name="component3">The component</param>
            <param name="component4">The component</param>
            <param name="component5">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`6.NextUnsafe(Quantum.EntityRef@,`0*@,`1*@,`2*@,`3*@,`4*@,`5*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
            <param name="component1">The unsafe component pointer</param>
            <param name="component2">The unsafe component pointer</param>
            <param name="component3">The unsafe component pointer</param>
            <param name="component4">The unsafe component pointer</param>
            <param name="component5">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilter`7">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`7.UseCulling">
            <summary>
            Include culled entities in the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`7.Next(Quantum.EntityRef@,`0@,`1@,`2@,`3@,`4@,`5@,`6@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
            <param name="component1">The component</param>
            <param name="component2">The component</param>
            <param name="component3">The component</param>
            <param name="component4">The component</param>
            <param name="component5">The component</param>
            <param name="component6">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`7.NextUnsafe(Quantum.EntityRef@,`0*@,`1*@,`2*@,`3*@,`4*@,`5*@,`6*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
            <param name="component1">The unsafe component pointer</param>
            <param name="component2">The unsafe component pointer</param>
            <param name="component3">The unsafe component pointer</param>
            <param name="component4">The unsafe component pointer</param>
            <param name="component5">The unsafe component pointer</param>
            <param name="component6">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilter`8">
            <summary>
            Filter entities by component types.
            </summary>
        </member>
        <member name="P:Quantum.ComponentFilter`8.UseCulling">
            <summary>
            Include culled entities in the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilter`8.Next(Quantum.EntityRef@,`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The component</param>
            <param name="component1">The component</param>
            <param name="component2">The component</param>
            <param name="component3">The component</param>
            <param name="component4">The component</param>
            <param name="component5">The component</param>
            <param name="component6">The component</param>
            <param name="component7">The component</param>
        </member>
        <member name="M:Quantum.ComponentFilter`8.NextUnsafe(Quantum.EntityRef@,`0*@,`1*@,`2*@,`3*@,`4*@,`5*@,`6*@,`7*@)">
            <summary>
            Advances the filter to the next element of the collection. Grants unsafe access to the component data.
            </summary>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
            <param name="entity">The entity ref</param>
            <param name="component0">The unsafe component pointer</param>
            <param name="component1">The unsafe component pointer</param>
            <param name="component2">The unsafe component pointer</param>
            <param name="component3">The unsafe component pointer</param>
            <param name="component4">The unsafe component pointer</param>
            <param name="component5">The unsafe component pointer</param>
            <param name="component6">The unsafe component pointer</param>
            <param name="component7">The unsafe component pointer</param>
        </member>
        <member name="T:Quantum.ComponentFilterStructMeta">
            <summary>
            Component filter that is initialized from a filter class having component fields.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFilterStructMeta.MAX_COMPONENT_TYPES">
            <summary>
            Maximum number of component types that can be used to filter.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFilterStructMeta.Set">
            <summary>
            The resulting component set.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFilterStructMeta.SetRank">
            <summary>
            <see cref="P:Quantum.ComponentSet.Rank"/>.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFilterStructMeta.EntityOffset">
            <summary>
            The current entity offset.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFilterStructMeta.ComponentCount">
            <summary>
            Return the component count from the filter.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFilterStructMeta.ComponentOffsets">
            <summary>
            The component field offset for all types.
            </summary>
        </member>
        <member name="F:Quantum.ComponentFilterStructMeta.ComponentTypes">
            <summary>
            The component index for all types.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilterStructMeta.Create``1">
            <summary>
            Create a new component filter meta from a filter type.
            </summary>
            <typeparam name="T">Filter type</typeparam>
            <returns>C</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Quantum.ComponentFilterStruct`1">
            <summary>
            Component filter.
            </summary>
            <typeparam name="T">Component type to find.</typeparam>
        </member>
        <member name="P:Quantum.ComponentFilterStruct`1.UseCulling">
            <summary>
            Include culled entities.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilterStruct`1.Reset">
            <summary>
            Reset the filter.
            </summary>
        </member>
        <member name="M:Quantum.ComponentFilterStruct`1.Reset(System.Int32,System.Int32)">
            <summary>
            Reset a part of the filter.
            </summary>
            <param name="offset">Offset</param>
            <param name="count">Count</param>
        </member>
        <member name="M:Quantum.ComponentFilterStruct`1.Next(`0*)">
            <summary>
            Advances the filter to the next element of the collection.
            </summary>
            <param name="components">The component pointer</param>
            <returns><see langword="true"/> if the filter was successfully advanced to the next element; <see langword="false"/> if the filter has passed the end of the collection.</returns>   
        </member>
        <member name="T:Quantum.ComponentPrototypeRef">
            <summary>
            Represents a generalized reference to a component prototype. The prototype can either come from an entity prototype asset
            or from a map asset. Type is stored as a <see cref="T:Quantum.ComponentTypeRef"/>.
            </summary>
        </member>
        <member name="F:Quantum.ComponentPrototypeRef.SIZE">
            <inheritdoc cref="F:Quantum.CodeDocHelper.SIZE"/>
        </member>
        <member name="F:Quantum.ComponentPrototypeRef.Asset">
            <summary>
            The asset reference of the entity prototype asset or the map asset.
            </summary>
        </member>
        <member name="F:Quantum.ComponentPrototypeRef.InnerAssetId">
            <summary>
            Index of the host entity prototype, if the component prototype comes from a map asset.
            </summary>
        </member>
        <member name="F:Quantum.ComponentPrototypeRef.ComponentType">
            <summary>
            Type of the component.
            </summary>
        </member>
        <member name="P:Quantum.ComponentPrototypeRef.IsValid">
            <summary>
            Returns true if the component prototype reference is valid.
            </summary>
        </member>
        <member name="P:Quantum.ComponentPrototypeRef.EntityPrototypeRef">
            <summary>
            Returns a reference to the entity prototype hosting the component prototype.
            </summary>
        </member>
        <member name="P:Quantum.ComponentPrototypeRef.ComponentTypeIndex">
            <summary>
            Returns the index of the component type.
            </summary>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.op_Equality(Quantum.ComponentPrototypeRef,Quantum.ComponentPrototypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.op_Equality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)"/>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.op_Inequality(Quantum.ComponentPrototypeRef,Quantum.ComponentPrototypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.op_Inequality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)"/>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.Equals(Quantum.ComponentPrototypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.GetHashCode"/>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.Equals(System.Object)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Equals(System.Object)"/>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.GetHashCode">
            <inheritdoc cref="M:Quantum.CodeDocHelper.GetHashCode"/>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes the <see cref="T:Quantum.ComponentPrototypeRef"/> to the specified <see cref="T:Quantum.FrameSerializer"/> stream.
            </summary>
            <param name="ptr">A pointer to the <see cref="T:Quantum.ComponentPrototypeRef"/> to be serialized.</param>
            <param name="stream">The <see cref="T:Quantum.FrameSerializer"/> stream to serialize to.</param>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.ToString">
            <summary>
            Returns a string that represents the current <see cref="T:Quantum.ComponentPrototypeRef"/> in the format of:
            <code>
            [ComponentPrototypeRef Asset: {Asset}, InnerAssetId: {InnerAssetId}, ComponentType: {ComponentType}]
            </code>
            </summary>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.FromEntityPrototypeRefAndTypeIndex(Quantum.EntityPrototypeRef,System.Int32)">
            <summary>
            Creates a new <see cref="T:Quantum.ComponentPrototypeRef"/> from the specified <see cref="P:Quantum.ComponentPrototypeRef.EntityPrototypeRef"/> and component type index.
            </summary>
            <param name="prototypeRef">The <see cref="P:Quantum.ComponentPrototypeRef.EntityPrototypeRef"/> to create the <see cref="T:Quantum.ComponentPrototypeRef"/> from.</param>
            <param name="typeIndex">The index of the component type.</param>
            <returns>A new <see cref="T:Quantum.ComponentPrototypeRef"/> instance.</returns>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.FromEntityPrototypeRefAndType(Quantum.EntityPrototypeRef,Quantum.ComponentTypeRef)">
            <summary>
            Creates a new <see cref="T:Quantum.ComponentPrototypeRef"/> from the specified <see cref="P:Quantum.ComponentPrototypeRef.EntityPrototypeRef"/> and component type.
            </summary>
            <param name="prototypeRef">The <see cref="P:Quantum.ComponentPrototypeRef.EntityPrototypeRef"/> to create the <see cref="T:Quantum.ComponentPrototypeRef"/> from.</param>
            <param name="type">The <see cref="T:Quantum.ComponentTypeRef"/> of the component.</param>
            <returns>A new <see cref="T:Quantum.ComponentPrototypeRef"/> instance.</returns>
        </member>
        <member name="M:Quantum.ComponentPrototypeRef.FromEntityPrototypeRefAndType(Quantum.EntityPrototypeRef,System.Type)">
            <summary>
            Creates a new <see cref="T:Quantum.ComponentPrototypeRef"/> from the specified <see cref="P:Quantum.ComponentPrototypeRef.EntityPrototypeRef"/> and component type.
            </summary>
            <param name="prototypeRef">The <see cref="P:Quantum.ComponentPrototypeRef.EntityPrototypeRef"/> to create the <see cref="T:Quantum.ComponentPrototypeRef"/> from.</param>
            <param name="type">The <see cref="T:System.Type"/> of the component.</param>
            <returns>A new <see cref="T:Quantum.ComponentPrototypeRef"/> instance.</returns>
        </member>
        <member name="T:Quantum.ComponentSet">
            <summary>
            A bitset representing a set of components. The set can contain up to 512 components.
            This type is not serializable, as any defining or removing a component type would
            affect other component indices.
            </summary>
            <seealso cref="T:Quantum.ComponentTypeId"/>
        </member>
        <member name="F:Quantum.ComponentSet.MAX_COMPONENTS">
            <summary>
            Maximum number of components that can be stored in the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Create``1">
            <summary>
            Creates a new component set with the specified components.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Create``2">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create``3">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create``4">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create``5">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create``6">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create``7">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create``8">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create(Quantum.ComponentTypeRef)">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="M:Quantum.ComponentSet.Create(System.ReadOnlySpan{Quantum.ComponentTypeRef})">
            <inheritdoc cref="M:Quantum.ComponentSet.Create``1"/>
        </member>
        <member name="P:Quantum.ComponentSet.IsEmpty">
            <summary>
            Returns true if the set is empty.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Equals(Quantum.ComponentSet@)">
            <summary>
            Returns true if both sets are equal.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IsSubsetOf(Quantum.ComponentSet@)">
            <summary>
            Returns true if the set is a subset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Overlaps(Quantum.ComponentSet@)">
            <summary>
            Returns true if the set and <paramref name="other"/> have at least one element in common.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IsSupersetOf(Quantum.ComponentSet64@)">
            <summary>
            Returns true if the set is a superset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Remove(Quantum.ComponentSet64@)">
            <summary>
            Removes all elements from the set that are in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.UnionWith(Quantum.ComponentSet64@)">
            <summary>
            Returns the set of elements that are in the set or in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IntersectWith(Quantum.ComponentSet64@)">
            <summary>
            Returns the set of elements that are both in the set and in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IsSupersetOf(Quantum.ComponentSet256@)">
            <summary>
            Returns true if the set is a superset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Remove(Quantum.ComponentSet256@)">
            <summary>
            Removes all elements from the set that are in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.UnionWith(Quantum.ComponentSet256@)">
            <summary>
            Returns the set of elements that are in the set or in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IntersectWith(Quantum.ComponentSet256@)">
            <summary>
            Returns the set of elements that are both in the set and in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IsSupersetOf(Quantum.ComponentSet@)">
            <summary>
            Returns true if the set is a superset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Remove(Quantum.ComponentSet@)">
            <summary>
            Removes all elements from the set that are in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.UnionWith(Quantum.ComponentSet@)">
            <summary>
            Returns the set of elements that are in the set or in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IntersectWith(Quantum.ComponentSet@)">
            <summary>
            Returns the set of elements that are both in the set and in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IsSet(System.Int32)">
            <summary>
            Returns true if the set contains the element at the specified index.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Add(System.Int32)">
            <summary>
            Adds the element at the specified index to the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Remove(System.Int32)">
            <summary>
            Removes the element at the specified index from the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Add``1">
            <summary>
            Adds the type's id to the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.Remove``1">
            <summary>
            Removes the type's id from the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.IsSet``1">
            <summary>
            Returns true if the type's id is in the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet.GetHashCode">
            <inheritdoc cref="M:Quantum.CodeDocHelper.GetHashCode"/>
        </member>
        <member name="P:Quantum.ComponentSet256.IsEmpty">
            <summary>
            Returns true if the set is empty.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Equals(Quantum.ComponentSet256@)">
            <summary>
            Returns true if both sets are equal.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IsSubsetOf(Quantum.ComponentSet256@)">
            <summary>
            Returns true if the set is a subset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Overlaps(Quantum.ComponentSet256@)">
            <summary>
            Returns true if the set and <paramref name="other"/> have at least one element in common.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IsSubsetOf(Quantum.ComponentSet@)">
            <summary>
            Returns true if the set is a subset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Overlaps(Quantum.ComponentSet@)">
            <summary>
            Returns true if the set and <paramref name="other"/> have at least one element in common.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IsSupersetOf(Quantum.ComponentSet64@)">
            <summary>
            Returns true if the set is a superset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Remove(Quantum.ComponentSet64@)">
            <summary>
            Removes all elements from the set that are in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.UnionWith(Quantum.ComponentSet64@)">
            <summary>
            Returns the set of elements that are in the set or in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IntersectWith(Quantum.ComponentSet64@)">
            <summary>
            Returns the set of elements that are both in the set and in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IsSupersetOf(Quantum.ComponentSet256@)">
            <summary>
            Returns true if the set is a superset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Remove(Quantum.ComponentSet256@)">
            <summary>
            Removes all elements from the set that are in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.UnionWith(Quantum.ComponentSet256@)">
            <summary>
            Returns the set of elements that are in the set or in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IntersectWith(Quantum.ComponentSet256@)">
            <summary>
            Returns the set of elements that are both in the set and in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IsSet(System.Int32)">
            <summary>
            Returns true if the set contains the element at the specified index.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Add(System.Int32)">
            <summary>
            Adds the element at the specified index to the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Remove(System.Int32)">
            <summary>
            Removes the element at the specified index from the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Add``1">
            <summary>
            Adds the type's id to the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.Remove``1">
            <summary>
            Removes the type's id from the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.IsSet``1">
            <summary>
            Returns true if the type's id is in the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet256.GetHashCode">
            <inheritdoc cref="M:Quantum.CodeDocHelper.GetHashCode"/>
        </member>
        <member name="P:Quantum.ComponentSet64.IsEmpty">
            <summary>
            Returns true if the set is empty.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Equals(Quantum.ComponentSet64@)">
            <summary>
            Returns true if both sets are equal.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.IsSubsetOf(Quantum.ComponentSet64@)">
            <summary>
            Returns true if the set is a subset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Overlaps(Quantum.ComponentSet64@)">
            <summary>
            Returns true if the set and <paramref name="other"/> have at least one element in common.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.IsSubsetOf(Quantum.ComponentSet256@)">
            <summary>
            Returns true if the set is a subset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Overlaps(Quantum.ComponentSet256@)">
            <summary>
            Returns true if the set and <paramref name="other"/> have at least one element in common.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.IsSubsetOf(Quantum.ComponentSet@)">
            <summary>
            Returns true if the set is a subset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Overlaps(Quantum.ComponentSet@)">
            <summary>
            Returns true if the set and <paramref name="other"/> have at least one element in common.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.IsSupersetOf(Quantum.ComponentSet64@)">
            <summary>
            Returns true if the set is a superset of the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Remove(Quantum.ComponentSet64@)">
            <summary>
            Removes all elements from the set that are in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.UnionWith(Quantum.ComponentSet64@)">
            <summary>
            Returns the set of elements that are in the set or in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.IntersectWith(Quantum.ComponentSet64@)">
            <summary>
            Returns the set of elements that are both in the set and in the <paramref name="other"/> set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.IsSet(System.Int32)">
            <summary>
            Returns true if the set contains the element at the specified index.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Add(System.Int32)">
            <summary>
            Adds the element at the specified index to the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Remove(System.Int32)">
            <summary>
            Removes the element at the specified index from the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Add``1">
            <summary>
            Adds the type's id to the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.Remove``1">
            <summary>
            Removes the type's id from the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.IsSet``1">
            <summary>
            Returns true if the type's id is in the set.
            </summary>
        </member>
        <member name="M:Quantum.ComponentSet64.GetHashCode">
            <inheritdoc cref="M:Quantum.CodeDocHelper.GetHashCode"/>
        </member>
        <member name="T:Quantum.ComponentTypeSetSelector">
            <summary>
            Represents a set of component types. Use ComponentTypeRef array insteadd.
            </summary>
        </member>
        <member name="T:Quantum.ComponentTypeId`1">
            <summary>
            Runtime information for a component type, containing its ID, size, flags and callbacks.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.ComponentTypeId`1.Id">
            <summary>
            Component type ID/index.
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId`1.Size">
            <summary>
            Component type size in bytes.
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId`1.Flags">
            <summary>
            Component type flags.
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeId`1.Callbacks">
            <summary>
            Component type callbacks.
            </summary>
        </member>
        <member name="T:Quantum.ComponentTypeRef">
            <summary>
            A persistent and serializable reference to a component type. Is valid as long as the component type is not renamed. 
            </summary>
        </member>
        <member name="F:Quantum.ComponentTypeRef.SIZE">
            <inheritdoc cref="F:Quantum.CodeDocHelper.SIZE"/>
        </member>
        <member name="F:Quantum.ComponentTypeRef.RawValue">
            <summary>
            The hash of the component type name.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeRef.FromRaw(System.UInt32)">
            <summary>
            Creates a new component type reference from a raw value.
            </summary>
            <param name="rawValue"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.ComponentTypeRef.FromType``1">
            <summary>
            Creates a new component type reference from a type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.ComponentTypeRef.FromType(System.Type)">
            <inheritdoc cref="M:Quantum.ComponentTypeRef.FromType``1"/>
        </member>
        <member name="M:Quantum.ComponentTypeRef.FromTypeName(System.String)">
            <summary>
            Creates a new component type reference from a type name.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.ComponentTypeRef.Is``1">
            <summary>
            Returns true if this component type reference points to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Quantum.ComponentTypeRef.Is(System.Type)">
            <summary>
            Returns true if this component type reference points to <paramref name="type"/>.
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:Quantum.ComponentTypeRef.IsValid">
            <summary>
            Returns true if this component type reference points to any type.
            </summary>
        </member>
        <member name="M:Quantum.ComponentTypeRef.Equals(Quantum.ComponentTypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Equals(System.Object)"/>
        </member>
        <member name="M:Quantum.ComponentTypeRef.Equals(System.Object)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Equals(System.Object)"/>
        </member>
        <member name="M:Quantum.ComponentTypeRef.GetHashCode">
            <inheritdoc cref="M:Quantum.CodeDocHelper.GetHashCode"/>
        </member>
        <member name="M:Quantum.ComponentTypeRef.op_Equality(Quantum.ComponentTypeRef,Quantum.ComponentTypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.op_Equality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)"/>
        </member>
        <member name="M:Quantum.ComponentTypeRef.op_Inequality(Quantum.ComponentTypeRef,Quantum.ComponentTypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.op_Inequality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)"/>
        </member>
        <member name="T:Quantum.DispatchableHandler`1">
            <summary>
            Delegate for dispatchable events.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Quantum.DispatchableFilter">
            <summary>
            Delegate for filtering events.
            </summary>
        </member>
        <member name="T:Quantum.DispatcherHandlerFlags">
            <summary>
            Built-in flags for <see cref="M:Quantum.DispatcherBase.Subscribe``1(System.Object,Quantum.DispatchableHandler{``0},System.Boolean,System.UInt32,Quantum.DispatchableFilter)"/>
            </summary>
        </member>
        <member name="F:Quantum.DispatcherHandlerFlags.CustomFlagsShift">
            <summary>
            Use as bit shift for custom flags.
            </summary>
        </member>
        <member name="F:Quantum.DispatcherHandlerFlags.DontInvokeIfAddedInAHandler">
            <summary>
            If set, handler will not be called if added in an active handler.
            </summary>
        </member>
        <member name="F:Quantum.DispatcherHandlerFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:Quantum.DispatcherHandlerFlags.Once">
            <summary>
            Call handler only once, then remove.
            </summary>
        </member>
        <member name="T:Quantum.DispatcherSubscription">
            <summary>
            Represents a specific subscription to a dispatcher. Can be used to unsubscribe
            without knowing the listener or handler.
            </summary>
        </member>
        <member name="M:Quantum.DispatcherSubscription.#ctor(System.Int32,System.UInt32)">
            <summary>
            Represents a specific subscription to a dispatcher. Can be used to unsubscribe
            without knowing the listener or handler.
            </summary>
        </member>
        <member name="T:Quantum.DispatcherBase">
            <summary>
            Base class for dispatchers. Dispatchers are used to publish and subscribe to events represented by <see cref="T:Quantum.IDispatchable"/>
            objects. 
            </summary>
        </member>
        <member name="P:Quantum.DispatcherBase.Next">
            <summary>
            A reference to the next dispatcher in the chain. If set, the dispatcher will forward events to the next dispatcher after.
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.#ctor(System.Collections.Generic.Dictionary{System.Type,System.Int32})">
            <summary>
            Initializes the dispatcher with a mapping of types to ids. The ids are used to quickly find the correct event handler.
            </summary>
            <param name="typeToIndex">Type-to-index mapping</param>>
        </member>
        <member name="T:Quantum.DispatcherBase.ListenerStatus">
            <summary>
            Status of a listener. Used to determine if a listener is still alive.
            </summary>
        </member>
        <member name="F:Quantum.DispatcherBase.ListenerStatus.Active">
            <summary>
            Listener is active and should be called.
            </summary>
        </member>
        <member name="F:Quantum.DispatcherBase.ListenerStatus.Inactive">
            <summary>
            Listener is inactive and should not be called, but not cleaned up.
            </summary>
        </member>
        <member name="F:Quantum.DispatcherBase.ListenerStatus.Dead">
            <summary>
            Listener is dead and should be cleaned up.
            </summary>
        </member>
        <member name="P:Quantum.DispatcherBase.IsEmpty">
            <summary>
            Returns <see langword="true"/> if there are no active subscriptions.
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.GetIndex``1">
            <summary>
            Returns the index of a specific dispatchable type. Throws in case the type is not registered.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.Subscribe``1(System.Object,Quantum.DispatchableHandler{``0},System.Boolean,System.UInt32,Quantum.DispatchableFilter)">
            <summary>
            Creates a subscription. Subscriptions can be cancelled manually by calling <see cref="M:Quantum.DispatcherBase.UnsubscribeHandler``1(Quantum.DispatchableHandler{``0})"/>, but as long
            as the derived class overrides <see cref="M:Quantum.DispatcherBase.GetListenerStatus(System.Object,System.UInt32)"/> and calls <see cref="M:Quantum.DispatcherBase.RemoveDeadListeners"/> periodically, the dispatcher will
            be free of memory leaks.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. A class extending this one decided whether a listener is alive or not in <see cref="M:Quantum.DispatcherBase.GetListenerStatus(System.Object,System.UInt32)"></see></param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="flags">Additional flags. Deriving classes can define their own flags starting with 1 &lt;&lt; <see cref="F:Quantum.DispatcherHandlerFlags.CustomFlagsShift"/> and analyze them in method overrides.</param>
            <param name="filter">Optional event filter. If returns <see langword="false"/>, handler will not be invoked.</param>
            <returns>Subscription that can be stored and used in <see cref="M:Quantum.DispatcherBase.Unsubscribe(Quantum.DispatcherSubscription)"/></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.Unsubscribe(Quantum.DispatcherSubscription)">
            <summary>
            Cancel a specific subscription.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.UnsubscribeHandler``1(Quantum.DispatchableHandler{``0})">
            <summary>
            Cancel every subscription using a handler.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.UnsubscribeListener``1(System.Object)">
            <summary>
            Cancel every specific subscription type for a listener.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.SubscribeManual``1(Quantum.DispatchableHandler{``0},System.Boolean,Quantum.DispatchableFilter)">
            <summary>
            Creates a subscription that is active until the caller disposes the result.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="handler"></param>
            <param name="once"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.SubscribeManual``1(System.Object,Quantum.DispatchableHandler{``0},System.Boolean,Quantum.DispatchableFilter)">
            <summary>
            Creates a subscription that is active until the caller disposes the result or calls Unsubscribe.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener"></param>
            <param name="handler"></param>
            <param name="once"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.Clear">
            <summary>
            Removes all subscriptions.
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.RemoveDeadListeners">
            <summary>
            Removes every subscription for which <see cref="M:Quantum.DispatcherBase.GetListenerStatus(System.Object,System.UInt32)"/> returns <see cref="F:Quantum.DispatcherBase.ListenerStatus.Dead"/>
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.UnsubscribeListener(System.Object)">
            <summary>
            Cancel every subscription for a listener.
            </summary>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.GetListenerStatus(System.Object,System.UInt32)">
            <summary>
            Returns <see cref="F:Quantum.DispatcherBase.ListenerStatus.Active"/> if listener is not <see langword="null"/>, <see cref="F:Quantum.DispatcherBase.ListenerStatus.Dead"/> otherwise.
            Override this method to provide custom listener status.
            </summary>
            <param name="listener"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.InvokeMeta``1(``0)">
            <summary>
            Invokes handlers for a specific dispatchable.
            </summary>
            <param name="e"></param>
            <typeparam name="TDispatchable"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.InvokeMeta(System.Int32,Quantum.IDispatchable)">
            <summary>
            Invokes handlers for a specific dispatchable.
            </summary>
            <param name="metaIndex"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.SubscribeInternal``1(System.Object,Quantum.DispatchableHandler{``0},Quantum.DispatchableFilter,System.UInt32)">
            <summary>
            Creates a subscription. Subscriptions can be cancelled manually by calling <see cref="M:Quantum.DispatcherBase.UnsubscribeHandler``1(Quantum.DispatchableHandler{``0})"/>.
            </summary>
            <param name="listener"></param>
            <param name="handler"></param>
            <param name="filter"></param>
            <param name="flags"></param>
            <typeparam name="TDispatchable"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Quantum.DispatcherBase.SubscribeManualInternal``1(System.Object,Quantum.DispatchableHandler{``0},Quantum.DispatchableFilter,System.Boolean)">
            <summary>
            Creates a subscription that is active until the caller disposes the result.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener"></param>
            <param name="handler"></param>
            <param name="filter"></param>
            <param name="once"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DispatcherBase.UnsubscribeInternal``1(System.Object,Quantum.DispatchableHandler{``0})">
            <summary>
            Unsubscribes a listener from a handler.
            </summary>
            <param name="listener"></param>
            <param name="handler"></param>
            <typeparam name="TDispatchable"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Quantum.DispatcherBase.HandlerDisposable">
            <summary>
            A helper class that allows to create a subscription that is active until the caller disposes the result.
            </summary>
        </member>
        <member name="M:Quantum.DispatcherBase.HandlerDisposable.Dispose">
            <summary>
            Dispose the dispatcher and unsubscribe.
            </summary>
        </member>
        <member name="T:Quantum.DispatcherBase.DispatchableMeta">
            <summary>
            Base class for dispatchable event meta information.
            </summary>
        </member>
        <member name="T:Quantum.EntityComponentPair`1">
            <summary>
            An entity-component pair. Used when iterating over components. Since this type contains a copy of the component, it is not suitable for writing back to the component.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.EntityComponentPair`1.Entity">
            <summary>
            Entity the component belongs to.
            </summary>
        </member>
        <member name="F:Quantum.EntityComponentPair`1.Component">
            <summary>
            Copy of the component.
            </summary>
        </member>
        <member name="M:Quantum.EntityComponentPair`1.Deconstruct(Quantum.EntityRef@,`0@)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Deconstruct(System.Int32@)"/>
        </member>
        <member name="T:Quantum.EntityComponentPointerPair`1">
            <summary>
            An entity-component pointer pair. Used when iterating over components.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.EntityComponentPointerPair`1.Entity">
            <summary>
            The entity the component belongs to.
            </summary>
        </member>
        <member name="F:Quantum.EntityComponentPointerPair`1.Component">
            <summary>
            Pointer to the component.
            </summary>
        </member>
        <member name="M:Quantum.EntityComponentPointerPair`1.Deconstruct(Quantum.EntityRef@,`0*@)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Deconstruct(System.Int32@)"/>
        </member>
        <member name="T:Quantum.EntityPrototypeRef">
            <summary>
            Represents a generalized reference to an entity prototype - either <see cref="T:Quantum.EntityPrototype"/> asset or an entity from <see cref="T:Quantum.Map"/>.
            </summary>
        </member>
        <member name="F:Quantum.EntityPrototypeRef.SIZE">
            <inheritdoc cref="F:Quantum.CodeDocHelper.SIZE"/>
        </member>
        <member name="F:Quantum.EntityPrototypeRef.Asset">
            <summary>
            The asset reference of <see cref="T:Quantum.EntityPrototype"/> or <see cref="T:Quantum.Map"/>.
            </summary>
        </member>
        <member name="F:Quantum.EntityPrototypeRef.InnerAssetId">
            <summary>
            If the entity prototype reference comes from a map asset, this is the index of the entity in the map.
            </summary>
        </member>
        <member name="P:Quantum.EntityPrototypeRef.Invalid">
            <summary>
            Invalid entity prototype reference.
            </summary>
        </member>
        <member name="P:Quantum.EntityPrototypeRef.IsValid">
            <summary>
            Returns true if the entity prototype reference is valid.
            </summary>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.op_Equality(Quantum.EntityPrototypeRef,Quantum.EntityPrototypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.op_Equality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)"/>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.op_Inequality(Quantum.EntityPrototypeRef,Quantum.EntityPrototypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.op_Inequality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)"/>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.Equals(Quantum.EntityPrototypeRef)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Equals(System.Object)"/>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.Equals(System.Object)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Equals(System.Object)"/>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.GetHashCode">
            <inheritdoc cref="M:Quantum.CodeDocHelper.GetHashCode"/>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.Serialize(System.Void*,Quantum.FrameSerializer)">
            <inheritdoc cref="M:Quantum.CodeDocHelper.Serialize(System.Void*,Quantum.FrameSerializer)"/>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.ToString">
            <summary>
            Returns a string that represents the current <see cref="T:Quantum.EntityPrototypeRef"/> in the format of:
            <code>
            [EntityPrototypeRef Asset: {Asset}, InnerAssetId: {InnerAssetId}]
            </code>
            </summary>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.FromPrototypeAsset(Quantum.EntityPrototype)">
            <summary>
            Creates a new entity prototype reference from an entity prototype asset.
            </summary>
            <param name="prototype"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.FromPrototypeAsset(Quantum.AssetRef{Quantum.EntityPrototype})">
            <inheritdoc cref="M:Quantum.EntityPrototypeRef.FromPrototypeAsset(Quantum.EntityPrototype)"/>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.FromMasterAsset(Quantum.Map,System.Int32)">
            <summary>
            Creates a new entity prototype reference from an entity in a map asset.
            </summary>
            <param name="asset">Map asset</param>
            <param name="internalAssetId">Index of the entity prototype</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.EntityPrototypeRef.FromMasterAsset(Quantum.AssetRef{Quantum.Map},System.Int32)">
            <summary>
            Creates a new entity prototype reference from an entity in a map asset.
            </summary>
            <param name="asset">Map asset</param>
            <param name="internalAssetId">Index of the entity prototype</param>
            <returns></returns>
        </member>
        <member name="T:Quantum.EntityRef">
            <summary>
            Quantum entity reference identifies a unique Entity.
            </summary>
            <para>Quantum implements a sparse-set ECS model (similar to enTT). This means entities are just references to collections of components.</para>
            <para>Most important advantages: memory consumption is proportional to instantiated entities + ability to add and remove components dynamically.</para>
            \ingroup EntityApi
        </member>
        <member name="P:Quantum.EntityRef.Comparer">
            <summary>
            Global Entity ref comparer.
            </summary>
        </member>
        <member name="F:Quantum.EntityRef.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="P:Quantum.EntityRef.None">
            <summary>
            The EntityRef value defining a non-existent Entity.
            </summary>
        </member>
        <member name="P:Quantum.EntityRef.IsValid">
            <summary>
            Returns <see langword="false"/> if this entity is equal to <see cref="P:Quantum.EntityRef.None"/>
            </summary>
        </member>
        <member name="F:Quantum.EntityRef.Index">
            <summary>
            Entity index.
            </summary>
        </member>
        <member name="F:Quantum.EntityRef.Version">
            <summary>
            Entity version is incremented during the entity life cycle when the entity slot is reused.
            </summary>
        </member>
        <member name="M:Quantum.EntityRef.op_Equality(Quantum.EntityRef,Quantum.EntityRef)">
            <summary>
            Operator override for which checks if two instances of EntityRef are equal.
            </summary>
            <returns><see langword="true"/> if the instances are equal.</returns>
        </member>
        <member name="M:Quantum.EntityRef.op_Inequality(Quantum.EntityRef,Quantum.EntityRef)">
            <summary>
            Operator override for which checks if two instances of EntityRef are not equal.
            </summary>
            <returns><see langword="true"/> if the instances are not equal.</returns>
        </member>
        <member name="M:Quantum.EntityRef.Equals(Quantum.EntityRef)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified EntityRef value.
            </summary>
            <param name="other">An EntityRef value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.EntityRef.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.EntityRef.GetHashCode">
            <summary>
            Overrides the default hash function.
            </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Quantum.EntityRef.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.EntityRef"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.EntityRef"/>.</param>
            <param name="stream">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.EntityRef.Print(System.Void*,Quantum.FramePrinter)">
            <summary>
            Prints the REPLACE using a <see cref="T:Quantum.FramePrinter"/>.
            </summary>
            <param name="ptr">Pointer to REPLACE instance</param>
            <param name="printer">Printer object</param>
        </member>
        <member name="M:Quantum.EntityRef.ToString">
            <summary>
            Converts the numeric value of this instance to its equivalent string representation.
            </summary>
            <returns>The string representation of the value of this instance</returns>
        </member>
        <member name="M:Quantum.EntityRef.TryParse(System.String,Quantum.EntityRef@)">
            <summary>
            Try to parse an EntityRef from a string.
            </summary>
            <param name="str">String</param>
            <param name="result">Resulting EntityRef</param>
            <returns><see langword="true"/> if the entity ref was successfully parsed</returns>
        </member>
        <member name="T:Quantum.EventFlags">
            <summary>
            Flags to mark Quantum event mechanics.
            </summary>
        </member>
        <member name="F:Quantum.EventFlags.None">
            <summary>
            Regular Quantum event.
            </summary>
        </member>
        <member name="F:Quantum.EventFlags.Synced">
            <summary>
            Marks a synced event that is only emitted after input has been verified.
            </summary>
        </member>
        <member name="F:Quantum.EventFlags.Server">
            <summary>
            Marks the event to be only invoked on the server.
            </summary>
        </member>
        <member name="F:Quantum.EventFlags.Client">
            <summary>
            Marks the event to be only invoked on the client.
            </summary>
        </member>
        <member name="T:Quantum.EventBase">
            <summary>
            The base class for Quantum events.
            Events are a fire-and-forget mechanism to transfer information from the simulation to the view.
            </summary>
        </member>
        <member name="F:Quantum.EventBase.Tick">
            <summary>
            The tick that the event was invoked on.
            </summary>
        </member>
        <member name="P:Quantum.EventBase.Game">
            <summary>
            The reference to the game that the event is dispatched to.
            </summary>
        </member>
        <member name="P:Quantum.EventBase.Synced">
            <summary>
            Returns <see langword="true"/> if the event is a synced event.
            </summary>
        </member>
        <member name="P:Quantum.EventBase.CanBeInvokedOnServer">
            <summary>
            Returns <see langword="true"/> if the event can be invoked on the server.
            </summary>
        </member>
        <member name="P:Quantum.EventBase.CanBeInvokedOnClient">
            <summary>
            Returns <see langword="true"/> if the event can be invoked on the client.
            </summary>
        </member>
        <member name="F:Quantum.EventBase.Id">
            <summary>
            The event id.
            </summary>
        </member>
        <member name="F:Quantum.EventBase._flags">
            <summary>
            The event flags.
            </summary>
        </member>
        <member name="M:Quantum.EventBase.OnReleased">
            <summary>
            Is called when the event is released and returned to the pool.
            </summary>
        </member>
        <member name="M:Quantum.EventBase.#ctor(System.Int32,Quantum.EventFlags)">
            <summary>
            Event event constructor.
            </summary>
            <param name="id">Event id</param>
            <param name="flags">Event flags</param>
        </member>
        <member name="T:Quantum.EventList">
            <summary>
            Internally used class.
            </summary>
        </member>
        <member name="T:Quantum.DatabaseType">
            <summary>
            Enum representing different types of databases.
            </summary>
        </member>
        <member name="F:Quantum.DatabaseType.AssetDB">
            <summary>
            The AssetDB.
            </summary>
        </member>
        <member name="F:Quantum.DatabaseType.DynamicDB">
            <summary>
            The DynamicDB.
            </summary>
        </member>
        <member name="F:Quantum.DatabaseType.Any">
            <summary>
            Any database.
            </summary>
        </member>
        <member name="F:Quantum.DatabaseType.Default">
            <summary>
            The default database: <see cref="F:Quantum.DatabaseType.AssetDB"/>
            </summary>
        </member>
        <member name="T:Quantum.AddResult">
            <summary>
            The result of a FrameBase.Add call.
            </summary>
        </member>
        <member name="F:Quantum.AddResult.EntityDoesNotExist">
            <summary>
            The entity does not exist.
            </summary>
        </member>
        <member name="F:Quantum.AddResult.ComponentAlreadyExists">
            <summary>
            The entity already has a component of the type being added.
            </summary>
        </member>
        <member name="F:Quantum.AddResult.ComponentAdded">
            <summary>
            The component was successfully added to the entity.
            </summary>
        </member>
        <member name="T:Quantum.SetResult">
            <summary>
            The result of a FrameBase.Set call.
            </summary>
        </member>
        <member name="F:Quantum.SetResult.EntityDoesNotExist">
            <summary>
            The entity does not exist.
            </summary>
        </member>
        <member name="F:Quantum.SetResult.ComponentUpdated">
            <summary>
            Indicates that a component has been updated in the FrameBase.Set method.
            </summary>
        </member>
        <member name="F:Quantum.SetResult.ComponentAdded">
            <summary>
            The component was successfully added to the entity.
            </summary>
        </member>
        <member name="T:Quantum.CommitCommandsModes">
            <summary>
            Indicates the mode in which commands are committed.
            </summary>
        </member>
        <member name="F:Quantum.CommitCommandsModes.OnFrameSimulationBegin">
            <summary>
            The commands are committed at the beginning of the frame simulation.
            </summary>
        </member>
        <member name="F:Quantum.CommitCommandsModes.OnFrameSimulationEnd">
            <summary>
            The commands are committed at the end of the frame simulation.
            </summary>
        </member>
        <member name="F:Quantum.CommitCommandsModes.InBetweenSystems">
            <summary>
            The commands are committed in between systems.
            </summary>
        </member>
        <member name="F:Quantum.CommitCommandsModes.Manual">
            <summary>
            The commands are committed manually.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.UpdateRate">
            <summary>
            Gets the update rate of the frame.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.IsMainThread">
            <summary>
            Gets a value indicating whether the current thread is the main thread.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.Number">
            <summary>
            Gets the number of the frame.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.IsPredicted">
            <summary>
            Returns if the frame is predicted.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.IsVerified">
            <summary>
            Returns if the frame is verified.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.Context">
            <summary>
            Gets the current <see cref="T:Quantum.Core.FrameContext"/>.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.Layers">
            <summary>
            Access to the Layers API.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.Map">
            <inheritdoc cref="P:Quantum.Core.FrameBase.Map"/>
        </member>
        <member name="P:Quantum.FrameThreadSafe.DeltaTime">
            <inheritdoc cref="P:Quantum.Core.FrameBase.DeltaTime"/>
        </member>
        <member name="P:Quantum.FrameThreadSafe.Physics2D">
            <summary>
            Access to the 2D Physics API.
            </summary>
        </member>
        <member name="P:Quantum.FrameThreadSafe.Physics3D">
            <summary>
            Access to the 3D Physics API.
            </summary>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Void(Quantum.Ptr)">
            <summary>
            Converts a Ptr to a void pointer.
            </summary>
            <param name="ptr">Ptr</param>
            <returns>Pointer</returns>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Void(System.Void*)">
            <summary>
            Converts a pointer to a Ptr.
            </summary>
            <param name="ptr">Void pointer</param>
            <returns>Ptr</returns>
        </member>
        <member name="M:Quantum.FrameThreadSafe.op_Implicit(Quantum.FrameThreadSafe)~Quantum.Core.FrameBase">
            <summary>
            Implicitly converts a FrameThreadSafe object to a FrameBase object.
            </summary>
            <param name="f">The FrameThreadSafe object to convert.</param>
            <returns>The converted FrameBase object.</returns>
        </member>
        <member name="M:Quantum.FrameThreadSafe.op_Explicit(Quantum.Core.FrameBase)~Quantum.FrameThreadSafe">
            <summary>
            Explicitly converts a FrameBase object to a FrameThreadSafe object.
            </summary>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Get``1(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Get``1(Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGet``1(Quantum.EntityRef,``0@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryGet``1(Quantum.EntityRef,``0@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Has``1(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Has``1(Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Has(Quantum.EntityRef,System.Int32)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Has(Quantum.EntityRef,System.Int32)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Exists(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Exists(Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.IsCulled(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.IsCulled(Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.IsCullable(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.IsCullable(Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.LoadAsset(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.LoadAsset(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.DisposeAsset(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.DisposeAsset(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.DisposeAsset(System.String,Quantum.DatabaseType)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.DisposeAsset(System.String,Quantum.DatabaseType)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.FindAsset``1(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.FindAsset``1(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.FindAsset``1(Quantum.AssetRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetGuid,``0@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.FindAsset``1(Quantum.AssetRef,``0@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetGuid,``0@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.FindAsset``1(Quantum.AssetRef{``0})">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetGuid,``0@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryFindAsset``1(Quantum.AssetGuid,``0@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetGuid,``0@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryFindAsset``1(Quantum.AssetRef,``0@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryFindAsset``1(Quantum.AssetGuid,``0@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryFindAsset``1(Quantum.AssetRef{``0},``0@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.FindAsset``1(System.String,Quantum.DatabaseType)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.FindAsset``1(System.String,Quantum.DatabaseType)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.FindAsset``1(System.String,Quantum.DatabaseType)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryFindAsset``1(System.String,``0@,Quantum.DatabaseType)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryFindAsset``1(System.String,``0@,Quantum.DatabaseType)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGetPointer``1(Quantum.EntityRef,``0*@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryGetPointer``1(Quantum.EntityRef,``0*@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGetPointer(Quantum.EntityRef,System.Int32,System.Void*@)">
            <summary>
            Tries to get a pointer to a component of an entity in the frame.
            </summary>
            <param name="entityRef">The entity reference.</param>
            <param name="componentIndex">The index of the component.</param>
            <param name="value">The output parameter to store the pointer.</param>
            <returns><see langword="true"/> if the pointer was successfully retrieved; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetPointer``1(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetPointer``1(Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetPointer(Quantum.EntityRef,System.Int32)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetPointer(Quantum.EntityRef,System.Int32)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetComponentIterator``1">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetComponentIterator``1"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetComponentBlockIterator``1">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetComponentBlockIterator``1"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetComponentBlockIterator``1(System.Int32,System.Int32)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetComponentBlockIterator``1(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetComponentSet(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetComponentSet(Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetPlayerInputFlags(System.Int32)">
            <inheritdoc cref="M:Photon.Deterministic.DeterministicFrame.GetPlayerInputFlags(Quantum.PlayerRef)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.ResolveList``1(Quantum.Collections.QListPtr{``0})">
            <inheritdoc cref="M:Quantum.Core.FrameBase.ResolveList``1(Quantum.Collections.QListPtr{``0})"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.ResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1})">
            <inheritdoc cref="M:Quantum.Core.FrameBase.ResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1})"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.ResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.EnumEqualityComparer.Tag)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.ResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1})"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.ResolveHashSet``1(Quantum.Collections.QHashSetPtr{``0})">
            <inheritdoc cref="M:Quantum.Core.FrameBase.ResolveHashSet``1(Quantum.Collections.QHashSetPtr{``0})"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryResolveList``1(Quantum.Collections.QListPtr{``0},Quantum.Collections.QList{``0}@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryResolveList``1(Quantum.Collections.QListPtr{``0},Quantum.Collections.QList{``0}@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.Collections.QDictionary{``0,``1}@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.Collections.QDictionary{``0,``1}@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.Collections.QEnumDictionary{``0,``1}@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryResolveDictionary``2(Quantum.Collections.QDictionaryPtr{``0,``1},Quantum.Collections.QEnumDictionary{``0,``1}@,Quantum.EnumEqualityComparer.Tag)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryResolveHashSet``1(Quantum.Collections.QHashSetPtr{``0},Quantum.Collections.QHashSet{``0}@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryResolveHashSet``1(Quantum.Collections.QHashSetPtr{``0},Quantum.Collections.QHashSet{``0}@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetSingleton``1">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetSingleton``1"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetSingletonEntityRef``1">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetSingletonEntityRef``1"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetSingletonEntityRef(System.Int32)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetSingletonEntityRef(System.Int32)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGetSingleton``1(``0@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryGetSingleton``1(``0@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGetSingletonEntityRef``1(Quantum.EntityRef@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryGetSingletonEntityRef``1(Quantum.EntityRef@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGetSingletonEntityRef(System.Int32,Quantum.EntityRef@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryGetSingletonEntityRef(System.Int32,Quantum.EntityRef@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetPointerSingleton``1">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetPointerSingleton``1"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.GetPointerSingleton(System.Int32)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.GetPointerSingleton(System.Int32)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGetPointerSingleton``1(``0*@)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.TryGetPointerSingleton``1(``0*@)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.TryGetPointerSingleton(System.Int32,System.Void*@)">
            <summary>
            Tries to get a pointer to a singleton component by its component index.
            </summary>
            <param name="componentIndex">The index of the component.</param>
            <param name="component">The pointer to the singleton component.</param>
            <returns>Returns <see langword="true"/> if the pointer to the singleton component was successfully retrieved, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``1(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``1(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``2(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``2(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``3(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``3(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``4(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``4(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``5(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``5(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``6(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``6(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``7(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``7(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.Filter``8(Quantum.ComponentSet,Quantum.ComponentSet)">
            <inheritdoc cref="M:Quantum.Core.FrameBase.Filter``8(Quantum.ComponentSet,Quantum.ComponentSet)"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.FilterStruct``1(Quantum.ComponentSet,Quantum.ComponentSet,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:Quantum.Core.FrameBase.FrameBaseUnsafe.FilterStruct``1(Quantum.ComponentSet,Quantum.ComponentSet,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Quantum.FrameThreadSafe.ComponentGetter``1">
            <inheritdoc cref="M:Quantum.Core.FrameBase.FrameBaseUnsafe.ComponentGetter``1"/>
        </member>
        <member name="P:Quantum.FrameThreadSafe.Unsafe">
            <summary>
            Gets the Unsafe API for the frame.
            </summary>
        </member>
        <member name="T:Quantum.FrameChecksumerBitStream">
            <summary>
            Represents a bit stream used for frame checksum calculation.
            Implements the <see cref="T:Photon.Deterministic.IBitStream"/> interface.
            </summary>
        </member>
        <member name="P:Quantum.FrameChecksumerBitStream.Writing">
            <summary>
            Indicating whether the bit stream is currently writing.  
            </summary>
        </member>
        <member name="P:Quantum.FrameChecksumerBitStream.Reading">
            <summary>
            Indicating whether the bit stream is currently reading.
            </summary>
        </member>
        <member name="P:Quantum.FrameChecksumerBitStream.Checksum">
            <summary>
            Get or set the current checksum.
            </summary>
        </member>
        <member name="P:Quantum.FrameChecksumerBitStream.BytesRequired">
            <summary>
            Get the number of bytes required to store the checksum.
            </summary>
        </member>
        <member name="P:Quantum.FrameChecksumerBitStream.Data">
            <summary>
            Convert the checksum into a byte array.
            </summary>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.#ctor(System.UInt64)">
            <summary>
            Constructor with an initial checksum.
            </summary>
            <param name="crc">Initial checksum</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Condition(System.Boolean)">
            <summary>
            Evaluates a condition and updates the checksum accordingly.
            </summary>
            <param name="condition">The condition to evaluate.</param>
            <returns>The evaluated condition.</returns>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Reset(System.UInt64)">
            <summary>
            Resets the checksum to the specified value.
            </summary>
            <param name="crc">The value to reset the checksum to.</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.String@)">
            <summary>
            Not supported, will throw an exception.
            </summary>
            <param name="value">String value</param>
            <exception cref="T:System.NotImplementedException">Not supported-</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Boolean@)">
            <summary>
            Update the checksum with a boolean value.
            </summary>
            <param name="value">Boolean value</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Single@)">
            <summary>
            Update the checksum with a float value.
            </summary>
            <param name="value">Float value</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Double@)">
            <summary>
            Update the checksum with a double value.
            </summary>
            <param name="value">Double value</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int64@)">
            <summary>
            Update the checksum with a long value.
            </summary>
            <param name="value">Long value</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt64@)">
            <summary>
            Update the checksum with a ulong value.
            </summary>
            <param name="value">Ulong value</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(Photon.Deterministic.FP@)">
            <summary>
            Update the checksum with a FP value.
            </summary>
            <param name="value">FP value</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(Photon.Deterministic.FPVector2@)">
            <summary>
            Update the checksum with a FPVector2.
            </summary>
            <param name="value">Vector2</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(Photon.Deterministic.FPVector3@)">
            <summary>
            Update the checksum with a FPVector3.
            </summary>
            <param name="value">Vector3</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(Photon.Deterministic.FPQuaternion@)">
            <summary>
            Update the checksum with a FPQuaternion.
            </summary>
            <param name="value">Quaternion</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Byte@)">
            <summary>
            Update the checksum with a byte value.
            </summary>
            <param name="value">Byte</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt32@)">
            <summary>
            Update the checksum with a uint value.
            </summary>
            <param name="value">Uint</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt32@,System.Int32)">
            <summary>
            Update the checksum with a uint value.
            </summary>
            <param name="value">Uint</param>
            <param name="bits">Unsused</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt64@,System.Int32)">
            <summary>
            Update the checkusm with a ulong value.
            </summary>
            <param name="value">Ulong</param>
            <param name="bits">Unused</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int32@)">
            <summary>
            Update the checksum with an int value.
            </summary>
            <param name="value">Int</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int32@,System.Int32)">
            <summary>
            Update the checksum with an int value.
            </summary>
            <param name="value">Int</param>
            <param name="bits">Unused</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Byte*)">
            <summary>
            Update the checksum with a byte.
            </summary>
            <param name="v">Pointer to byte</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.SByte*)">
            <summary>
            Updates the the checksum with a sbyte.
            </summary>
            <param name="v">Sbyte</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int16*)">
            <summary>
            Update the checksum with a short.
            </summary>
            <param name="v">Short</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt16*)">
            <summary>
            Update the checksum with a ushort.
            </summary>
            <param name="v">Ushort</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int32*)">
            <summary>
            Update the checksum with an int.
            </summary>
            <param name="v">Int</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt32*)">
            <summary>
            Update the checksum with a uint.
            </summary>
            <param name="v">Uint</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int64*)">
            <summary>
            Update the checksum with a long.
            </summary>
            <param name="v">Long</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt64*)">
            <summary>
            Update the checksum with a ulong.
            </summary>
            <param name="v">Ulong</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.UInt32*,System.Int32)">
            <summary>
            Update the checksum with an uint.
            </summary>
            <param name="v">Uint</param>
            <param name="bits">Unused</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int32*,System.Int32)">
            <summary>
            Updates the checksum with and int.
            </summary>
            <param name="v">Int</param>
            <param name="bits">Unused</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.Byte*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of bytes.
            </summary>
            <param name="buffer">Byte array</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.SByte*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of sbytes.
            </summary>
            <param name="buffer">Sbyte array</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.Int16*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of shorts.
            </summary>
            <param name="buffer">Array of shorts</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.UInt16*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of ushorts.
            </summary>
            <param name="buffer">Array of ushort</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.Int32*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of ints.
            </summary>
            <param name="buffer">Array of ints</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.UInt32*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of uints.
            </summary>
            <param name="buffer">Array of uint</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.Int64*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of longs.
            </summary>
            <param name="buffer">Array of longs</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeBuffer(System.UInt64*,System.Int32)">
            <summary>
            Updates the checksum with a buffer of ulongs.
            </summary>
            <param name="buffer">Array of ulong</param>
            <param name="length">Array length</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteBool(System.Boolean)">
            <summary>
            Updates the checksum with a bool.
            </summary>
            <param name="v">Bool</param>
            <returns>Returns the input value</returns>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteBoolean(System.Boolean)">
            <summary>
            Updates the checksum with a bool.
            </summary>
            <param name="v">Bool</param>
            <returns>Returns the input value</returns>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteInt(System.Int32)">
            <summary>
            Updates the checksum with an int.
            </summary>
            <param name="v">Int</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteUInt(System.UInt32)">
            <summary>
            Updates the checksum with a uint.
            </summary>
            <param name="v">Uint</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteFP(Photon.Deterministic.FP)">
            <summary>
            Updates the checksum with a FP.
            </summary>
            <param name="v">FP</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteFPVector2(Photon.Deterministic.FPVector2)">
            <summary>
            Updates the checksum with a FPVector2.
            </summary>
            <param name="v">Vector2</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteFPVector3(Photon.Deterministic.FPVector3)">
            <summary>
            Updates the checksum with a FPVector3.
            </summary>
            <param name="v">Vector3</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteLong(System.Int64)">
            <summary>
            Updates the checksum with a long.
            </summary>
            <param name="v">Long</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteULong(System.UInt64)">
            <summary>
            Updates the checksum with a ulong.
            </summary>
            <param name="v">Ulong</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.WriteByte(System.Byte)">
            <summary>
            Updates the checksum with a byte.
            </summary>
            <param name="v">Byte value</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Int32[]@)">
            <summary>
            Updates the checksum with a byte array. Not supported, will throw an exception.
            </summary>
            <param name="value">Byte array reference</param>
            <exception cref="T:System.InvalidOperationException">Not supported</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Byte[]@)">
            <summary>
            Not supported.
            </summary>
            <param name="value">Value</param>
            <exception cref="T:System.InvalidOperationException">Not supported</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Byte[]@,System.Int32@)">
            <summary>
            Not supported.
            </summary>
            <param name="array">Array</param>
            <param name="length">Array length</param>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Byte[]@,System.Int32)">
            <summary>
            Not supported.
            </summary>
            <param name="value">Array</param>
            <param name="fixedSize">Array fixes size</param>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Serialize(System.Byte[]@,System.Int32@,System.Int32)">
            <summary>
            Not supported.
            </summary>
            <param name="array">Array</param>
            <param name="length">Array length</param>
            <param name="fixedSize">Array fixed size</param>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeArrayLength``1(``0[]@,System.Int32)">
            <summary>
            Updates the checksum with an array.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="array">Array reference</param>
            <param name="maxLength">The max size of the input array.</param>
            <returns>The length of the array secured by maxLength.</returns>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.SerializeArray``1(``0[]@,Photon.Deterministic.BitStream.ArrayElementSerializer{``0},System.Int32)">
            <summary>
            Updates the checksum with an array ans a custom serializer.
            </summary>
            <typeparam name="T">Type of array</typeparam>
            <param name="array">Array reference</param>
            <param name="serializer">Serializer callback</param>
            <param name="maxLength">The max size of the input array.</param>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadLong">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadUInt">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadBool">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadBoolean">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadByte">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadULong">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadInt">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadFP">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadFPVector2">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ReadFPVector3">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.CopyFromArray(System.Byte[])">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.CopyFromBuffer(System.Byte*,System.Int32)">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.ToArray">
            <summary>
            Not supported.
            </summary>
            <returns>Throws</returns>
            <exception cref="T:System.InvalidOperationException">Not supported.</exception>
        </member>
        <member name="M:Quantum.FrameChecksumerBitStream.Reset">
            <summary>
            Resets the checksum to 0.
            </summary>
        </member>
        <member name="M:Quantum.FrameMetaData.QHashCollectionList.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.FrameMetaData.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.GlobalsCore">
            <summary>
            Internally used class.
            </summary>
        </member>
        <member name="T:Quantum.ICallbackDispatcher">
            <summary>
            A callback dispatcher interface. Implementations of this interface are responsible for dispatching callbacks to the runtime.
            </summary>
        </member>
        <member name="M:Quantum.ICallbackDispatcher.Publish(Quantum.CallbackBase)">
            <summary>
            Notifies the runtime of a callback.
            </summary>
            <param name="e"></param>
            <returns>True if there were any event handlers. Currently, this value is unused.</returns>
        </member>
        <member name="M:Quantum.ICallbackDispatcher.HasAnyListeners(Quantum.CallbackBase)">
            <summary>
            Returns true if the callback has any listeners.
            </summary>
        </member>
        <member name="T:Quantum.IDispatchable">
            <summary>
            The interface for the dispatchable callbacks or events.
            </summary>
        </member>
        <member name="P:Quantum.IDispatchable.Game">
            <summary>
            The game that the callback or event is dispatched to.
            </summary>
        </member>
        <member name="T:Quantum.IEntityPrototypeMaterializedListener">
            <summary>
            If implemented by <see cref="T:Quantum.ComponentPrototype"/>, <see cref="M:Quantum.IEntityPrototypeMaterializedListener.OnEntityPrototypeMaterialized(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityPrototypeRef)"/> will be invoked after
            the entire prototype has been materialized, but before <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/>.
            This is useful when a component needs some extra initialization after all the components have been materialized.
            </summary>
        </member>
        <member name="M:Quantum.IEntityPrototypeMaterializedListener.OnEntityPrototypeMaterialized(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.EntityPrototypeRef)">
            <summary>
            Invoked after the entire prototype has been materialized, but before <see cref="!:Quantum.ISignalOnEntityPrototypeMaterialized"/>.
            </summary>
            <param name="f"></param>
            <param name="entity">The materialized entity.</param>
            <param name="prototypeRef">The entity prototype this component prototype belongs to.</param>
        </member>
        <member name="T:Quantum.IEventDispatcher">
            <summary>
            An event dispatcher interface. Implementations of this interface are responsible for dispatching events to the runtime.
            </summary>
        </member>
        <member name="M:Quantum.IEventDispatcher.Publish(Quantum.EventBase)">
            <summary>
            Notifies the runtime of an event.
            </summary>
            <param name="e"></param>
            <returns>True if there were any event handlers. Currently, this value is unused.</returns>
        </member>
        <member name="T:Quantum.IPrototype">
            <summary>
            A prototype interface. Indicates that the implementing type is a prototype of some kind.
            </summary>
        </member>
        <member name="T:Quantum.ISignal">
            <summary>
            Represents a signal. Not meant to be implemented directly.
            </summary>
        </member>
        <member name="P:Quantum.ISignal.RuntimeIndex">
            <summary>
            Index of the signal in the runtime.
            </summary>
        </member>
        <member name="F:Quantum.PrototypeMaterializationContext.Entity">
            <summary>
            The current entity.
            </summary>
        </member>
        <member name="F:Quantum.PrototypeMaterializationContext.EntityPrototypeRef">
            <summary>
            Reference to the entity prototype.
            </summary>
        </member>
        <member name="F:Quantum.PrototypeMaterializationContext.ComponentTypeId">
            <summary>
            Current component type id.
            </summary>
        </member>
        <member name="F:Quantum.PrototypeMaterializationContext.ComponentPrototypeSet">
            <summary>
            Current component prototype set.
            </summary>
        </member>
        <member name="F:Quantum.PrototypeMaterializationContext.MapEntities">
            <summary>
            If the entity is a map entity, this array contains the entity references for each map entity.
            </summary>
        </member>
        <member name="F:Quantum.PrototypeMaterializationContext.UserData">
            <summary>
            User data.
            </summary>
        </member>
        <member name="M:Quantum.PrototypeMaterializationContext.#ctor(Quantum.EntityRef,Quantum.EntityPrototypeRef,Quantum.ComponentPrototypeSet,System.Int32,Quantum.EntityRef[],System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.PrototypeMaterializationContext"/> struct.
            </summary>
            <param name="entity">The current entity.</param>
            <param name="prototypeRef">The reference to the entity prototype.</param>
            <param name="set">The current component prototype set.</param>
            <param name="componentTypeId">The current component type index.</param>
            <param name="mapEntities">The array of entity references for each map entity, if the entity is a map entity.</param>
            <param name="userData">The user data.</param>
        </member>
        <member name="P:Quantum.PrototypeMaterializationContext.ComponentPrototypeRef">
            <summary>
            Reference to the current component prototype.
            </summary>
        </member>
        <member name="M:Quantum.PrototypeMaterializationContext.TryGetEntityRef(Quantum.MapEntityId,Quantum.EntityRef@)">
            <summary>
            Converts <see cref="T:Quantum.MapEntityId"/> to an entity reference.
            </summary>
            <param name="id"></param>
            <param name="entityRef"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.QEnum8`1">
            <summary>
            A variable sized enum field backed by a sbyte value.
            The type helps with consistency and backwards compatibility when Enum types change during development.
            </summary>
            <typeparam name="T">The encapsulated enumeration type</typeparam>  
        </member>
        <member name="F:Quantum.QEnum8`1.Value">
            <summary>
            The backing value.
            </summary>
        </member>
        <member name="M:Quantum.QEnum8`1.op_Implicit(Quantum.QEnum8{`0})~`0">
            <summary>
            Convert QEnum into the encapsulated enum value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum8`1.op_Implicit(`0)~Quantum.QEnum8{`0}">
            <summary>
            Convert enum into QEnum encapsulation.
            </summary>
            <param name="value">Enum value</param>
        </member>
        <member name="M:Quantum.QEnum8`1.op_Explicit(Quantum.QEnum8{`0})~System.SByte">
            <summary>
            Convert QEnum value into backing type value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum8`1.op_Explicit(System.SByte)~Quantum.QEnum8{`0}">
            <summary>
            Convert backing type value into QEnum.
            </summary>
            <param name="value">Backing type value</param>
        </member>
        <member name="M:Quantum.QEnum8`1.GetTypeCode">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.QEnum8`1.ToBoolean(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Boolean value using <see cref="M:System.Convert.ToBoolean(System.Boolean)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Boolean representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Byte value using <see cref="M:System.Convert.ToByte(System.Byte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Byte representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToChar(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Char value using <see cref="M:System.Convert.ToChar(System.Char)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Char representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToDateTime(System.IFormatProvider)">
            <summary>
            Convert QEnum into a DateTime value using <see cref="M:System.Convert.ToDateTime(System.DateTime)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>DateTime representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToDecimal(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Decimal value using <see cref="M:System.Convert.ToDecimal(System.Decimal)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Decimal representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToDouble(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Double value using <see cref="M:System.Convert.ToDouble(System.Double)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Double representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int16 value using <see cref="M:System.Convert.ToInt16(System.Int16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int32 value using <see cref="M:System.Convert.ToInt32(System.Int32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int64 value using <see cref="M:System.Convert.ToInt64(System.Int64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToSByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a SByte value using <see cref="M:System.Convert.ToSByte(System.SByte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>SByte representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToSingle(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Single value using <see cref="M:System.Convert.ToSingle(System.Single)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Single representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToString(System.IFormatProvider)">
            <summary>
            Convert QEnum into a String value using <see cref="M:System.Convert.ToString(System.String)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>String representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToUInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt16 value using <see cref="M:System.Convert.ToUInt16(System.UInt16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToUInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt32 value using <see cref="M:System.Convert.ToUInt32(System.UInt32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToUInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt64 value using <see cref="M:System.Convert.ToUInt64(System.UInt64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum8`1.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Convert QEnum into an object type using <see cref="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)"/>.
            </summary>
            <param name="conversionType">Conversion type</param>
            <param name="provider">Format provider.</param>
            <returns>Object representation</returns>
        </member>
        <member name="T:Quantum.QEnum16`1">
            <summary>
            A variable sized enum field backed by a short value.
            The type helps with consistency and backwards compatibility when Enum types change during development.
            </summary>
            <typeparam name="T">The encapsulated enumeration type</typeparam>  
        </member>
        <member name="F:Quantum.QEnum16`1.Value">
            <summary>
            The backing value.
            </summary>
        </member>
        <member name="M:Quantum.QEnum16`1.op_Implicit(Quantum.QEnum16{`0})~`0">
            <summary>
            Convert QEnum into the encapsulated enum value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum16`1.op_Implicit(`0)~Quantum.QEnum16{`0}">
            <summary>
            Convert enum into QEnum encapsulation.
            </summary>
            <param name="value">Enum value</param>
        </member>
        <member name="M:Quantum.QEnum16`1.op_Explicit(Quantum.QEnum16{`0})~System.Int16">
            <summary>
            Convert QEnum value into backing type value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum16`1.op_Explicit(System.Int16)~Quantum.QEnum16{`0}">
            <summary>
            Convert backing type value into QEnum.
            </summary>
            <param name="value">Backing type value</param>
        </member>
        <member name="M:Quantum.QEnum16`1.GetTypeCode">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.QEnum16`1.ToBoolean(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Boolean value using <see cref="M:System.Convert.ToBoolean(System.Boolean)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Boolean representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Byte value using <see cref="M:System.Convert.ToByte(System.Byte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Byte representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToChar(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Char value using <see cref="M:System.Convert.ToChar(System.Char)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Char representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToDateTime(System.IFormatProvider)">
            <summary>
            Convert QEnum into a DateTime value using <see cref="M:System.Convert.ToDateTime(System.DateTime)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>DateTime representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToDecimal(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Decimal value using <see cref="M:System.Convert.ToDecimal(System.Decimal)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Decimal representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToDouble(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Double value using <see cref="M:System.Convert.ToDouble(System.Double)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Double representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int16 value using <see cref="M:System.Convert.ToInt16(System.Int16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int32 value using <see cref="M:System.Convert.ToInt32(System.Int32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int64 value using <see cref="M:System.Convert.ToInt64(System.Int64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToSByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a SByte value using <see cref="M:System.Convert.ToSByte(System.SByte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>SByte representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToSingle(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Single value using <see cref="M:System.Convert.ToSingle(System.Single)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Single representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToString(System.IFormatProvider)">
            <summary>
            Convert QEnum into a String value using <see cref="M:System.Convert.ToString(System.String)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>String representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToUInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt16 value using <see cref="M:System.Convert.ToUInt16(System.UInt16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToUInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt32 value using <see cref="M:System.Convert.ToUInt32(System.UInt32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToUInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt64 value using <see cref="M:System.Convert.ToUInt64(System.UInt64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum16`1.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Convert QEnum into an object type using <see cref="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)"/>.
            </summary>
            <param name="conversionType">Conversion type</param>
            <param name="provider">Format provider.</param>
            <returns>Object representation</returns>
        </member>
        <member name="T:Quantum.QEnum32`1">
            <summary>
            A variable sized enum field backed by a int value.
            The type helps with consistency and backwards compatibility when Enum types change during development.
            </summary>
            <typeparam name="T">The encapsulated enumeration type</typeparam>  
        </member>
        <member name="F:Quantum.QEnum32`1.Value">
            <summary>
            The backing value.
            </summary>
        </member>
        <member name="M:Quantum.QEnum32`1.op_Implicit(Quantum.QEnum32{`0})~`0">
            <summary>
            Convert QEnum into the encapsulated enum value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum32`1.op_Implicit(`0)~Quantum.QEnum32{`0}">
            <summary>
            Convert enum into QEnum encapsulation.
            </summary>
            <param name="value">Enum value</param>
        </member>
        <member name="M:Quantum.QEnum32`1.op_Explicit(Quantum.QEnum32{`0})~System.Int32">
            <summary>
            Convert QEnum value into backing type value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum32`1.op_Explicit(System.Int32)~Quantum.QEnum32{`0}">
            <summary>
            Convert backing type value into QEnum.
            </summary>
            <param name="value">Backing type value</param>
        </member>
        <member name="M:Quantum.QEnum32`1.GetTypeCode">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.QEnum32`1.ToBoolean(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Boolean value using <see cref="M:System.Convert.ToBoolean(System.Boolean)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Boolean representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Byte value using <see cref="M:System.Convert.ToByte(System.Byte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Byte representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToChar(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Char value using <see cref="M:System.Convert.ToChar(System.Char)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Char representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToDateTime(System.IFormatProvider)">
            <summary>
            Convert QEnum into a DateTime value using <see cref="M:System.Convert.ToDateTime(System.DateTime)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>DateTime representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToDecimal(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Decimal value using <see cref="M:System.Convert.ToDecimal(System.Decimal)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Decimal representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToDouble(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Double value using <see cref="M:System.Convert.ToDouble(System.Double)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Double representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int16 value using <see cref="M:System.Convert.ToInt16(System.Int16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int32 value using <see cref="M:System.Convert.ToInt32(System.Int32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int64 value using <see cref="M:System.Convert.ToInt64(System.Int64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToSByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a SByte value using <see cref="M:System.Convert.ToSByte(System.SByte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>SByte representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToSingle(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Single value using <see cref="M:System.Convert.ToSingle(System.Single)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Single representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToString(System.IFormatProvider)">
            <summary>
            Convert QEnum into a String value using <see cref="M:System.Convert.ToString(System.String)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>String representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToUInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt16 value using <see cref="M:System.Convert.ToUInt16(System.UInt16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToUInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt32 value using <see cref="M:System.Convert.ToUInt32(System.UInt32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToUInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt64 value using <see cref="M:System.Convert.ToUInt64(System.UInt64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum32`1.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Convert QEnum into an object type using <see cref="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)"/>.
            </summary>
            <param name="conversionType">Conversion type</param>
            <param name="provider">Format provider.</param>
            <returns>Object representation</returns>
        </member>
        <member name="T:Quantum.QEnum64`1">
            <summary>
            A variable sized enum field backed by a long value.
            The type helps with consistency and backwards compatibility when Enum types change during development.
            </summary>
            <typeparam name="T">The encapsulated enumeration type</typeparam>  
        </member>
        <member name="F:Quantum.QEnum64`1.Value">
            <summary>
            The backing value.
            </summary>
        </member>
        <member name="M:Quantum.QEnum64`1.op_Implicit(Quantum.QEnum64{`0})~`0">
            <summary>
            Convert QEnum into the encapsulated enum value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum64`1.op_Implicit(`0)~Quantum.QEnum64{`0}">
            <summary>
            Convert enum into QEnum encapsulation.
            </summary>
            <param name="value">Enum value</param>
        </member>
        <member name="M:Quantum.QEnum64`1.op_Explicit(Quantum.QEnum64{`0})~System.Int64">
            <summary>
            Convert QEnum value into backing type value.
            </summary>
            <param name="value">QEnum value</param>
        </member>
        <member name="M:Quantum.QEnum64`1.op_Explicit(System.Int64)~Quantum.QEnum64{`0}">
            <summary>
            Convert backing type value into QEnum.
            </summary>
            <param name="value">Backing type value</param>
        </member>
        <member name="M:Quantum.QEnum64`1.GetTypeCode">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.QEnum64`1.ToBoolean(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Boolean value using <see cref="M:System.Convert.ToBoolean(System.Boolean)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Boolean representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Byte value using <see cref="M:System.Convert.ToByte(System.Byte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Byte representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToChar(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Char value using <see cref="M:System.Convert.ToChar(System.Char)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Char representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToDateTime(System.IFormatProvider)">
            <summary>
            Convert QEnum into a DateTime value using <see cref="M:System.Convert.ToDateTime(System.DateTime)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>DateTime representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToDecimal(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Decimal value using <see cref="M:System.Convert.ToDecimal(System.Decimal)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Decimal representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToDouble(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Double value using <see cref="M:System.Convert.ToDouble(System.Double)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Double representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int16 value using <see cref="M:System.Convert.ToInt16(System.Int16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int32 value using <see cref="M:System.Convert.ToInt32(System.Int32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Int64 value using <see cref="M:System.Convert.ToInt64(System.Int64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Int64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToSByte(System.IFormatProvider)">
            <summary>
            Convert QEnum into a SByte value using <see cref="M:System.Convert.ToSByte(System.SByte)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>SByte representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToSingle(System.IFormatProvider)">
            <summary>
            Convert QEnum into a Single value using <see cref="M:System.Convert.ToSingle(System.Single)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>Single representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToString(System.IFormatProvider)">
            <summary>
            Convert QEnum into a String value using <see cref="M:System.Convert.ToString(System.String)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>String representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToUInt16(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt16 value using <see cref="M:System.Convert.ToUInt16(System.UInt16)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt16 representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToUInt32(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt32 value using <see cref="M:System.Convert.ToUInt32(System.UInt32)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt32 representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToUInt64(System.IFormatProvider)">
            <summary>
            Convert QEnum into a UInt64 value using <see cref="M:System.Convert.ToUInt64(System.UInt64)"/>.
            </summary>
            <param name="provider">Format provider.</param>
            <returns>UInt64 representation</returns>
        </member>
        <member name="M:Quantum.QEnum64`1.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Convert QEnum into an object type using <see cref="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)"/>.
            </summary>
            <param name="conversionType">Conversion type</param>
            <param name="provider">Format provider.</param>
            <returns>Object representation</returns>
        </member>
        <member name="T:Quantum.IQStringUtf8">
            <summary>
            QString interface for UTF-8 strings.
            </summary>
        </member>
        <member name="M:Quantum.IQStringUtf8.CompareOrdinal(System.Byte*,System.UInt16)">
            <inheritdoc cref="M:Quantum.IQString.CompareOrdinal(System.Byte*,System.UInt16)"/>
        </member>
        <member name="T:Quantum.QStringUtf8">
            <summary>
            Base class for DSL-generated variable QString(N) fields. QStringUtf8 supports UTF-8.
            N represents the total size of the string in bytes minus 2 bytes used for bookkeeping.
            In other words QString(64) will use 64 bytes for a string with a max byte length of 62 bytes, 
            i.e. up to 32 UTF-8 characters.
            </summary>
        </member>
        <member name="F:Quantum.QStringUtf8.ByteCountFieldName">
            <inheritdoc cref="F:Quantum.QString.ByteCountFieldName"/>
        </member>
        <member name="F:Quantum.QStringUtf8.BytesFieldName">
            <inheritdoc cref="F:Quantum.QString.BytesFieldName"/>
        </member>
        <member name="M:Quantum.QStringUtf8.AreEqual``1(``0@,System.Object)">
            <inheritdoc cref="M:Quantum.QString.AreEqual``1(``0@,System.Object)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.CanHold(System.String,System.Int32)">
            <inheritdoc cref="M:Quantum.QString.CanHold(System.String,System.Int32)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.CompareOrdinal``1(``0@,System.Byte*,System.UInt16)">
            <inheritdoc cref="M:Quantum.QString.CompareOrdinal``1(``0@,System.Byte*,System.UInt16)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.CompareOrdinal``1(``0@,System.String)">
            <inheritdoc cref="M:Quantum.QString.CompareOrdinal``1(``0@,System.String)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.CompareOrdinal``2(``0@,``1@)">
            <inheritdoc cref="M:Quantum.QString.CompareOrdinal``2(``0@,``1@)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.ConstructFrom``1(System.String,System.Int32,``0@)">
            <inheritdoc cref="M:Quantum.QString.ConstructFrom``1(System.String,System.Int32,``0@)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.GetFittingCharacterCount(System.String,System.Int32)">
            <inheritdoc cref="M:Quantum.QString.GetFittingCharacterCount(System.String,System.Int32)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.GetFittingCharacterCount(System.String,System.Int32,System.Int32@)">
            <inheritdoc cref="M:Quantum.QString.GetFittingCharacterCount(System.String,System.Int32,System.Int32@)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.GetLength``1(``0@)">
            <inheritdoc cref="M:Quantum.QString.GetLength``1(``0@)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.GetString``1(``0@)">
            <inheritdoc cref="M:Quantum.QString.GetString``1(``0@)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.Print(System.Void*,Quantum.FramePrinter)">
            <inheritdoc cref="M:Quantum.QString.Print(System.Void*,Quantum.FramePrinter)"/>
        </member>
        <member name="M:Quantum.QStringUtf8.ConstructNoByteCountCheck``1(System.String,System.Int32,System.Int32,``0@)">
            <inheritdoc cref="M:Quantum.QString.ConstructNoByteCountCheck``1(System.String,System.Int32,System.Int32,``0@)"/>
        </member>
        <member name="T:Quantum.IQString">
            <summary>
            QString interface for UTF-16 strings.
            </summary>
        </member>
        <member name="M:Quantum.IQString.CompareOrdinal(System.Byte*,System.UInt16)">
            <summary>
            Compares a string and a strings byte representation by evaluating the numeric values of the corresponding characters in each string. 
            </summary>
            <param name="bytes">String in bytes representation</param>
            <param name="byteCount">Byte count to check</param>
            <returns>An integer that indicates the lexical relationship between the two comparands.</returns>
        </member>
        <member name="T:Quantum.QString">
            <summary>
            Base class for DSL-generated variable QString(N) fields.
            QString supports UTF-16 (Unicode in .NET).
            N represents the total size of the string in bytes minus 2 bytes used for bookkeeping.
            In other words QString(64) will use 64 bytes for a string with a max byte length of 62 bytes, 
            i.e. up to 31 UTF-16 characters.
            </summary>
        </member>
        <member name="F:Quantum.QString.ByteCountFieldName">
            <summary>
            Byte count field name
            </summary>
        </member>
        <member name="F:Quantum.QString.BytesFieldName">
            <summary>
            Bytes field name
            </summary>
        </member>
        <member name="M:Quantum.QString.AreEqual``1(``0@,System.Object)">
            <summary>
            Check if two QStrings are equal.
            (CompareOrdinal) compares two strings by evaluating the numeric values of the corresponding characters in each string. 
            </summary>
            <typeparam name="T">QString type</typeparam>
            <param name="qstr">String a</param>
            <param name="other">Other string</param>
            <returns><see langword="true"/> if string are equal</returns>
        </member>
        <member name="M:Quantum.QString.CanHold(System.String,System.Int32)">
            <summary>
            Checks if the input string bytes are less than or equal to the given byte count.
            </summary>
            <param name="str">String to check</param>
            <param name="maxByteCount">Max bytes</param>
            <returns><see langword="true"/> if required bytes for the string is below or equal to the given size</returns>
        </member>
        <member name="M:Quantum.QString.CompareOrdinal``1(``0@,System.Byte*,System.UInt16)">
            <summary>
            Compares a string and a strings byte representation by evaluating the numeric values of the corresponding characters in each string. 
            </summary>
            <typeparam name="T">QString type</typeparam>
            <param name="qstr">QString string 1</param>
            <param name="bytes">Other string 2 in bytes representation</param>
            <param name="byteCount">Other string byte length</param>
            <returns>An integer that indicates the lexical relationship between the two comparands.</returns>
        </member>
        <member name="M:Quantum.QString.CompareOrdinal``1(``0@,System.String)">
            <summary>
            Compares a QString and a string by evaluating the numeric values of the corresponding characters in each string. 
            </summary>
            <typeparam name="T">QString type</typeparam>
            <param name="qstr">QString 1</param>
            <param name="str">String 2</param>
            <returns>An integer that indicates the lexical relationship between the two comparands.</returns>
        </member>
        <member name="M:Quantum.QString.CompareOrdinal``2(``0@,``1@)">
            <summary>
            Compares two different QStrings types by evaluating the numeric values of the corresponding characters in each string. 
            </summary>
            <typeparam name="T">QString type</typeparam>
            <typeparam name="U">QString type</typeparam>
            <param name="qstr1">String 1</param>
            <param name="qstr2">String 2</param>
            <returns>An integer that indicates the lexical relationship between the two comparands.</returns>
        </member>
        <member name="M:Quantum.QString.ConstructFrom``1(System.String,System.Int32,``0@)">
            <summary>
            Creates a QString from a string.
            </summary>
            <typeparam name="T">QString type</typeparam>
            <param name="str">String</param>
            <param name="maxByteCount">Max byte count defined by the QString type</param>
            <param name="qstr">Resulting QString</param>
            <exception cref="T:System.ArgumentException">Is raised when the string is too long</exception>
        </member>
        <member name="M:Quantum.QString.GetFittingCharacterCount(System.String,System.Int32)">
            <summary>
            Calculate the number of characters that fit into the given byte count.
            </summary>
            <param name="str">String</param>
            <param name="maxByteCount">Max byte count defined by the QString type</param>
            <returns>The number of characters that fit into the given byte count.</returns>
        </member>
        <member name="M:Quantum.QString.GetFittingCharacterCount(System.String,System.Int32,System.Int32@)">
            <summary>
            Calculate the number of characters that fit into the given byte count.
            </summary>
            <param name="str">String</param>
            <param name="maxByteCount">Max byte count defined by the QString type</param>
            <param name="actualByteCount">Is set to the number of required bytes</param>
            <returns>The number of characters that fit into the given byte count.</returns>
        </member>
        <member name="M:Quantum.QString.GetLength``1(``0@)">
            <summary>
            Get the length of a QString.
            </summary>
            <typeparam name="T">QString type</typeparam>
            <param name="qstr">QString</param>
            <returns>Returns the character count.</returns>
        </member>
        <member name="M:Quantum.QString.GetString``1(``0@)">
            <summary>
            Convert the QString to a String.
            </summary>
            <typeparam name="T">QString type</typeparam>
            <param name="qstr">QString</param>
            <returns>String.</returns>
        </member>
        <member name="M:Quantum.QString.Print(System.Void*,Quantum.FramePrinter)">
            <summary>
            Prints the QString using a <see cref="T:Quantum.FramePrinter"/>.
            </summary>
            <param name="ptr">Pointer to QString instance</param>
            <param name="printer">Printer object</param>
        </member>
        <member name="M:Quantum.QString.ConstructNoByteCountCheck``1(System.String,System.Int32,System.Int32,``0@)">
            <summary>
            Create a QString from a string without checking the byte count.
            </summary>
            <typeparam name="T">QString type</typeparam>
            <param name="str">String to convert</param>
            <param name="characterCount">Not used</param>
            <param name="maxByteCount">Not used</param>
            <param name="qstr">Resulting QString</param>
        </member>
        <member name="T:Quantum.StructPrototype">
            <summary>
            Base class for DSL code-generated structs.
            The fields will be ordered in alphabetical order when the struct is generated.
            </summary>
        </member>
        <member name="T:Quantum.UnionPrototype">
            <summary>
            Base class for DSL code-generated union structs.
            The union type overlaps in memory the data layout of all the involved structs.
            Unions can be declared as part of a component.
            Internally, the union type Data contains the logic necessary for switching between the union types as they are accessed
            </summary>
        </member>
        <member name="T:Quantum.InstantReplaySettings">
            <summary>
            Settings required to record frame snapshots for instant replays.
            </summary>
        </member>
        <member name="F:Quantum.InstantReplaySettings.SnapshotsPerSecond">
            <summary>
            How many snapshots to record per second.
            </summary>
        </member>
        <member name="F:Quantum.InstantReplaySettings.LengthSeconds">
            <summary>
            How many seconds of past to recorded.
            </summary>
        </member>
        <member name="P:Quantum.InstantReplaySettings.LenghtSeconds">
            <summary>
            Obsolete, use <see cref="F:Quantum.InstantReplaySettings.LengthSeconds"/> instead.
            </summary>
        </member>
        <member name="P:Quantum.InstantReplaySettings.Default">
            <summary>
            Create default settings, 3 seconds and 1 snapshot per second.
            </summary>
        </member>
        <member name="M:Quantum.InstantReplaySettings.FromLength(Photon.Deterministic.FP,System.Int32)">
            <summary>
            Create settings.
            </summary>
            <param name="length"><see cref="P:Quantum.InstantReplaySettings.LenghtSeconds"/></param>
            <param name="snapshotsPerSecond"><see cref="F:Quantum.InstantReplaySettings.SnapshotsPerSecond"/></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.InstantReplaySettings.ToString">
            <summary>
            Override ToString method to debug output readable class members.
            </summary>
            <returns>Debug string</returns>
        </member>
        <member name="T:Quantum.QuantumGameStartParameters">
            <summary>
            Parameters required to start a Quantum game.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.ResourceManager">
            <summary>
            The resource manager.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.AssetSerializer">
            <summary>
            The asset serializer.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.CallbackDispatcher">
            <summary>
            The callback dispatcher to subscribe to Quantum game callbacks.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.EventDispatcher">
            <summary>
            The event dispatcher to subscribe to Quantum game events.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.InstantReplaySettings">
            <summary>
            The instant replay recording settings.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.HeapExtraCount">
            <summary>
            The number of extra heaps to allocate.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.InitialDynamicAssets">
            <summary>
            The initial dynamic assets.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameStartParameters.GameFlags">
            <summary>
            The Quantum game flags (QuantumGameFlags).
            </summary>
        </member>
        <member name="T:Quantum.RecordingFlags">
            <summary>
            The Quantum game input recording flags.
            </summary>
        </member>
        <member name="F:Quantum.RecordingFlags.None">
            <summary>
            Record nothing.
            </summary>
        </member>
        <member name="F:Quantum.RecordingFlags.Input">
            <summary>
            Record input.
            </summary>
        </member>
        <member name="F:Quantum.RecordingFlags.Checksums">
            <summary>
            Record checksums.
            </summary>
        </member>
        <member name="F:Quantum.RecordingFlags.All">
            <summary>
            Record input and checksums.
            </summary>
        </member>
        <member name="F:Quantum.RecordingFlags.Default">
            <summary>
            Not used anymore.
            </summary>
        </member>
        <member name="T:Quantum.SimulationUpdateTime">
            <summary>
            The type of measuring time progressions to update the local simulation.
            </summary>
            <para>Caveat: Changing it will make every client use the setting which might be undesirable when only used for debugging.</para>
        </member>
        <member name="F:Quantum.SimulationUpdateTime.Default">
            <summary>
            Internal stopwatch. Recommended for releasing games.
            </summary>
        </member>
        <member name="F:Quantum.SimulationUpdateTime.EngineDeltaTime">
            <summary>
            Engine (Unity) delta time. Extremely useful when pausing the Unity simulation during debugging for example.
            </summary>
            Caveat: the setting can cause issues with time synchronization when initializing online matches: the time tracking can be inaccurate under load (e.g.level loading) and result in a lot of large extra time syncs request and canceled inputs for a client when starting an online game.
        </member>
        <member name="F:Quantum.SimulationUpdateTime.EngineUnscaledDeltaTime">
            <summary>
            Engine unscaled delta time.
            </summary>
        </member>
        <member name="T:Quantum.DictionaryEntryPrototype">
            <summary>
            Obsolete class.
            </summary>
        </member>
        <member name="T:Quantum.EditMeshScope">
            <summary>
            Scope for editing triangles of a mesh collider.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.EditMeshScope.EditData">
            <summary>
            The mesh collider being edited.
            </summary>
        </member>
        <member name="M:Quantum.EditMeshScope.#ctor(Quantum.Core.FrameBase,Quantum.DynamicMap,System.Int32)">
            <summary>
            Creates a new scope for editing the triangles of a mesh collider.
            </summary>
            <param name="frame">Current Frame instance. Must be a Verified Frame.</param>
            <param name="map">Dynamic map currently loaded by the physics engine.</param>
            <param name="colliderIndex">Index of the mesh collider in the <paramref name="map"/>.</param>
            <exception cref="T:System.InvalidOperationException">If the <paramref name="frame"/> is Predicted.</exception>
            <exception cref="T:System.InvalidOperationException">If the <paramref name="map"/> is not the same map currently loaded by the Physics Engine.</exception>
        </member>
        <member name="M:Quantum.EditMeshScope.ReserveTriangleCapacity(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Ensures that the mesh capacity is at least the specified <paramref name="requestedCapacity"/> value.
            </summary>
            <param name="f">Current Frame instance.</param>
            <param name="requestedCapacity">
            The requested capacity to be reserved.
            If smaller than the current capacity, nothing happens.
            </param>
            <returns>
            The new triangle capacity of the mesh.
            If the requested <paramref name="requestedCapacity"/> is smaller than or equal the current capacity, it returns the current capacity
            </returns>
        </member>
        <member name="M:Quantum.EditMeshScope.SetTriangle(System.Int32,Quantum.TriangleCCW@)">
            <summary>
            Sets a triangle within the used range of a mesh collider.
            </summary>
            <param name="index">The index of the triangle.</param>
            <param name="tri">The triangle to set.</param>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is out bounds, considering the capacity of this mesh.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="index"/> is out of the range of USED triangles.</exception>
            <example>
            How to set a triangle of a mesh collider:
            <code>
            using (var scope = dynamicMap.EditMeshTriangles(frame, colliderIndex)) {
              TriangleCCW triangle = new TriangleCCW { A = v0, B = v1, C = v2 };
              scope.SetTriangle(0, ref triangle);
            }
            </code>
            </example>
        </member>
        <member name="M:Quantum.EditMeshScope.TrySetTriangle(System.Int32,Quantum.TriangleCCW@)">
             <summary>
             Try setting a triangle within the used range of a mesh collider.
             </summary>
             <param name="index">The index of the triangle.</param>
             <param name="tri">The triangle to set.</param>
             <returns><see langword="false"/> if the <paramref name="index"/> is out of the range of USED triangles. <see langword="true"/> otherwise.</returns>
             <example>
             How to try setting a triangle of a mesh collider:
             <code>
             using (var scope = dynamicMap.EditMeshTriangles(frame, colliderIndex)) {
               TriangleCCW triangle = new TriangleCCW { A = v0, B = v1, C = v2 };
            
               if(scope.TrySetTriangle(0, ref triangle)) {
                 Log.Info("Triangle set successfully.");
               }
               else {
                LogError?.Log("Failed to set triangle.");
              }
             }
             </code>
             </example>
        </member>
        <member name="M:Quantum.EditMeshScope.SetTriangleUnchecked(System.Int32,Quantum.TriangleCCW@)">
            <summary>
            Setting a triangle of a mesh collider without checking the validity of the <paramref name="index"/>.
            </summary>
            <param name="index">The index of the triangle.</param>
            <param name="tri">The triangle to set.</param>
            <example>
            How to set a triangle of a mesh collider without checking the index:
            <code>
            using (var scope = dynamicMap.EditMeshTriangles(frame, colliderIndex)) {
              TriangleCCW triangle = new TriangleCCW { A = v0, B = v1, C = v2 };
              scope.SetTriangleUnchecked(0, ref triangle);
            }
            </code>
            </example>
        </member>
        <member name="M:Quantum.EditMeshScope.AddTriangle(Quantum.TriangleCCW@)">
            <summary>
            Adds a triangle to the mesh collider.
            </summary>
            <param name="tri">The triangle to be added.</param>
            <exception cref="T:System.InvalidOperationException">If all triangles within the mesh capacity are already being used.</exception>
            <example>
            How to add a triangle to a mesh collider:
            <code>
            using (var scope = dynamicMap.EditMeshTriangles(frame, colliderIndex)) {
              TriangleCCW triangle = new TriangleCCW { A = v0, B = v1, C = v2 };
              scope.AddTriangle(ref triangle);
            }
            </code>
            </example>
            <remarks>
            If the mesh collider is at capacity, an InvalidOperationException is thrown.
            </remarks>
            <seealso cref="M:Quantum.EditMeshScope.TryAddTriangle(Quantum.TriangleCCW@)"/>
        </member>
        <member name="M:Quantum.EditMeshScope.TryAddTriangle(Quantum.TriangleCCW@)">
             <summary>
             Tries to add a triangle to the mesh collider.
             </summary>
             <param name="tri">The triangle to be added.</param>
             <returns><see langword="false"/> if all triangles within the mesh capacity are already being used. <see langword="true"/> otherwise.</returns>
             <example>
             How to try adding a triangle to a mesh collider:
             <code>
             using (var scope = dynamicMap.EditMeshTriangles(frame, colliderIndex)) {
               TriangleCCW triangle = new TriangleCCW { A = v0, B = v1, C = v2 };
            
               if(scope.TryAddTriangle(ref triangle)) {
                 Log.Info("Triangle added successfully.");
               }
               else {
                LogError?.Log("Failed to add triangle.");
               }
             }
             </code>
             </example>
             <seealso cref="M:Quantum.EditMeshScope.AddTriangle(Quantum.TriangleCCW@)"/>
        </member>
        <member name="M:Quantum.EditMeshScope.SetUsedCount(System.Int32)">
            <summary>
            Set the triangle used count for this mesh.
            </summary>
            <param name="count"></param>
            <returns>
            <c>true</c> if the new <paramref name="count"/> is in the range [0, Capacity] and different from the previous count.
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Quantum.EditMeshScope.RemoveTriangle(System.Int32)">
            <summary>
            Removes a single triangle from the mesh collider.
            </summary>
            <param name="triangleIndex">The <see cref="F:Quantum.TriangleCCW.TriIndexInStaticData">index</see> of the triangle to remove.</param>
            <returns>True if the triangle was successfully removed, false otherwise.</returns>
        </member>
        <member name="M:Quantum.EditMeshScope.RemoveTriangles(System.Int32,System.Int32)">
            <summary>
            Removes multiple triangles from the mesh collider.
            </summary>
            <param name="start">The starting <see cref="F:Quantum.TriangleCCW.TriIndexInStaticData">index</see> of the triangles to remove.</param>
            <param name="count">The number of triangles to remove.</param>
            <returns>True if the triangles were successfully removed, false otherwise.</returns>
        </member>
        <member name="M:Quantum.EditMeshScope.GetTriangle(System.Int32)">
             <summary>
             Gets the triangle at the specified index from the edit data in the EditTrianglesScope.
             </summary>
             <param name="index">The index of the triangle to get.</param>
             <returns>The TriangleCCW object at the specified index.</returns>
             <exception cref="T:System.IndexOutOfRangeException">If the index is out of bounds for the collider, considering its capacity.</exception>
             <example>
             How to get a triangle from a mesh collider:
             <code>
             using (var scope = dynamicMap.EditMeshTriangles(frame, colliderIndex)) {
               TriangleCCW triangle = scope.GetTriangle(0);
             }
            
             </code>
             </example>
        </member>
        <member name="M:Quantum.EditMeshScope.Dispose">
            <summary>
            Releases the resources used by the EditTrianglesScope.
            </summary>
            <remarks>
            If the current frame is predicted, the method does nothing.
            Otherwise, it assigns the EditData to the collider at the specified index in the CollidersRuntimeTriangles dictionary
            and inserts the mesh collider into the physics engine scene using the TriangleReference obtained from Physics3D.SceneMesh.
            </remarks>
        </member>
        <member name="T:Quantum.DynamicMap">
            <summary>
            Used to dynamically edit and manage mesh colliders and their triangles at runtime. This is particularly useful in games with procedurally generated content or user-generated levels, where the environment can change dynamically. 
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.DynamicMap.SourceMap">
            <summary>
            The source map that was used to create this dynamic map.
            </summary>
        </member>
        <member name="F:Quantum.DynamicMap.FreeTrianglePool">
            <summary>
            Free triangles that can be used to store new triangles.
            </summary>
        </member>
        <member name="M:Quantum.DynamicMap.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Called when the map asset is loaded.
            </summary>
            <param name="resourceManager">The <see cref="T:Quantum.IResourceManager"/> for this asset.</param>
            <param name="allocator">The <see cref="T:Photon.Deterministic.Native.Allocator"/> for this asset.</param>
        </member>
        <member name="M:Quantum.DynamicMap.EditMeshTriangles(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Edits the triangles of a mesh collider within a specific scope. When the scope is disposed, the changes are applied to the map.
            </summary>
            <param name="f">The current Frame. Must be Verified.</param>
            <param name="meshColliderIndex">The index of the mesh collider to edit.</param>
            <returns>An instance of the EditTriangleScope struct that represents the editing scope.</returns>
            <inheritdoc cref="M:Quantum.EditMeshScope.#ctor(Quantum.Core.FrameBase,Quantum.DynamicMap,System.Int32)"/>
            <example>
            How to edit the triangles of a mesh collider:
            <code>
            using (var scope = dynamicMap.EditMeshTriangles(frame, colliderIndex)) {
              TriangleCCW triangle = new TriangleCCW { A = v0, B = v1, C = v2 };
              scope.SetTriangle(0, ref triangle);
            }
            </code>
            </example>
        </member>
        <member name="M:Quantum.DynamicMap.InitializeStaticTriangles(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Called when the map asset is loaded and the triangles are read into memory.
            </summary>
            <param name="resourceManager">The resource manager for this asset.</param>
            <param name="allocator">The allocator for this asset.</param>
        </member>
        <member name="M:Quantum.DynamicMap.WriteRuntimeTriangles(Quantum.ByteStream,Quantum.UnmanagedTriangleArray,System.Collections.Generic.SortedDictionary{System.Int32,Quantum.MeshUnmanagedTrianglesRef})">
            <summary>
            Writes the runtime triangles to the given stream.
            </summary>
            <param name="stream">The ByteStream used to write the information.</param>
            <param name="source">The buffer of triangles to read.</param>
            <param name="runtimeTriangles">The triangle dictionary lookup to read.</param>
        </member>
        <member name="M:Quantum.DynamicMap.SerializeRuntimeTriangles(Quantum.UnmanagedTriangleArray,System.Collections.Generic.SortedDictionary{System.Int32,Quantum.MeshUnmanagedTrianglesRef})">
            <summary>
            Serializes runtime triangle structures.
            </summary>
            <param name="tris">The destination for the read triangles.</param>
            <param name="meshes">The dictionary from collider index to triangle references.</param>
            <returns>Raw byte array with the serialized data.</returns>
        </member>
        <member name="M:Quantum.DynamicMap.ReadRuntimeTriangles(Quantum.ByteStream,System.Collections.Generic.SortedDictionary{System.Int32,Quantum.MeshUnmanagedTrianglesRef},Photon.Deterministic.Native.Allocator,Quantum.UnmanagedTriangleArray@)">
            <summary>
            Reads the runtime triangles from the given stream.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="dict">The dictionary to read the triangles into.</param>
            <param name="allocator">The allocator for this asset.</param>
            <param name="dest">The destination for the read triangles.</param>
        </member>
        <member name="M:Quantum.DynamicMap.DeserializeRuntimeTriangles(System.Byte[],Quantum.UnmanagedTriangleArray@,System.Collections.Generic.SortedDictionary{System.Int32,Quantum.MeshUnmanagedTrianglesRef},Photon.Deterministic.Native.Allocator)">
            <summary>
            Deserializes triangle data into runtime structures.
            </summary>
            <param name="data">Raw serialized data.</param>
            <param name="tris">The destination for the read triangles.</param>
            <param name="meshes">The dictionary from collider index to triangle references.</param>
            <param name="allocator">The allocator for this asset.</param>
        </member>
        <member name="M:Quantum.DynamicMap.ReserveMeshColliders(Quantum.Core.FrameBase,System.Int32,System.Int32,System.Nullable{Quantum.StaticColliderData}@,System.Boolean)">
            <summary>
            Pre-allocates space for a specified number of mesh colliders.
            </summary>
            <param name="f">The current Frame. Must be Verified.</param>
            <param name="count">Number of mesh colliders to reserve space for.</param>
            <param name="capacity">Triangle capacity for each mesh collider.</param>
            <param name="staticData">Optional static data template for the reserved colliders.</param>
            <param name="resetPhysics">If static physics data should be reset. Necessary after reserving all colliders.</param>
            <returns><see langword="true"/> if reservation was successful, <see langword="false"/> otherwise.</returns>
            <example>
            How to reserve space for mesh colliders:
            <code>
            // Basic usage - reserve space for 10 mesh colliders with 100 triangles each
            dynamicMap.ReserveMeshColliders(frame, 10, 100);
            </code>
            </example>
        </member>
        <member name="M:Quantum.DynamicMap.AddMeshCollider(Quantum.Core.FrameBase,System.Collections.Generic.IList{Photon.Deterministic.FPVector3},System.Collections.Generic.IList{System.Int32},System.Int32,System.Nullable{Quantum.StaticColliderData}@,System.Boolean,System.Nullable{Photon.Deterministic.FPVector3},System.Nullable{Photon.Deterministic.FPQuaternion},System.Nullable{Quantum.AssetRef{Quantum.PhysicsMaterial}},System.Boolean)">
             <summary>
             Adds a mesh collider to the map.
             </summary>
             <param name="f">The frame.</param>
             <param name="vertices">The vertices of the collider.</param>
             <param name="indices">The indices (or triangles) of the collider.</param>
             <param name="position">The position of the collider.</param>
             <param name="rotation">The rotation of the collider.</param>
             <param name="additionalCapacity">Extra empty triangles to allocate.</param>
             <param name="staticData">The static information for the created collider.</param>
             <param name="resetPhysics">If the physics engine should be reset after adding.</param>
             <param name="material">The physics material asset object. If null, it will use the default physics material.</param>
             <param name="smoothSphereCollisions">If the mesh collider should have smooth sphere collisions.</param>
             <returns>The collider index of the created collider. -1 if it failed to create.</returns>
             <example>
             How to add a mesh collider to a dynamic map:
             <code>
             var vertices = new List&lt;FPVector3&gt; {
             new FPVector3(0, 0, 0),
             new FPVector3(1, 0, 0),
             new FPVector3(0, 1, 0)
             };
            
             int meshColliderIndex = dynamicMap.AddMeshCollider(frame, vertices);
            
             if(meshColliderIndex == -1) {
               LogError?.Log("Failed to add mesh collider");
             }
             else {
               Log.Info("Added mesh collider with index: " + meshColliderIndex);
             }
             </code>
             </example>
        </member>
        <member name="M:Quantum.DynamicMap.RemoveMeshCollider(Quantum.Core.FrameBase,System.Int32,System.Boolean)">
            <summary>
            Removes a mesh collider from the map.
            </summary>
            <param name="f">The frame.</param>
            <param name="meshColliderId">The index of the collider to remove.</param>
            <param name="resetPhysics">If the physics engine should be updated.</param>
            <returns><see langword="true"/> if the removal was successful, <see langword="false"/> otherwise.</returns>
            <example>
            How to remove a mesh collider from a dynamic map:
            <code>
            if(dynamicMap.RemoveMeshCollider(frame, meshColliderIndex)) {
              Log.Info("Removed mesh collider with index: " + meshColliderIndex);
            }
            else {
              LogError?.Log("Failed to remove mesh collider with index: " + meshColliderIndex);
            }
            </code>
            </example>
        </member>
        <member name="M:Quantum.DynamicMap.AddCollider2D(Quantum.Core.FrameBase,Quantum.MapStaticCollider2D,System.Boolean)">
            <summary>
            Adds a 2D collider to the map.
            </summary>
            <param name="f">The frame.</param>
            <param name="collider">The collider to add.</param>
            <param name="resetPhysics">If the physics engine should be updated.</param>
            <returns>The collider index of the created collider. -1 if it failed to create.</returns>
            <example>
            How to add a 2D collider to a dynamic map:
            <code>
            var collider = new MapStaticCollider2D {
              ShapeType = Shape2DType.Circle,
              CircleRadius = 1
            };
            
            int colliderIndex = dynamicMap.AddCollider2D(frame, collider);
            </code>
            </example>
        </member>
        <member name="M:Quantum.DynamicMap.AddCollider3D(Quantum.Core.FrameBase,Quantum.MapStaticCollider3D,System.Boolean)">
             <summary>
             Adds a 3D collider (non-mesh) to the map.
             </summary>
             <param name="f">The frame.</param>
             <param name="collider">The collider to add.</param>
             <param name="resetPhysics">If the physics engine should be updated.</param>
             <returns>The collider index of the created collider. -1 if it failed to create.</returns>
             <example>
             How to add a 3D collider to a dynamic map:
             <code>
             var collider = new MapStaticCollider3D {
               ShapeType = Shape3DType.Box,
               BoxExtents = new FPVector3(1, 1, 1)
             }
            
             int colliderIndex = dynamicMap.AddCollider3D(frame, collider);
             </code>
             </example>
        </member>
        <member name="M:Quantum.DynamicMap.RemoveCollider3D(Quantum.Core.FrameBase,System.Int32,System.Boolean)">
            <summary>
            Removes a 3D collider from the map.
            </summary>
            <param name="f">The frame.</param>
            <param name="colliderId">The index of the collider to remove.</param>
            <param name="resetPhysics">If the physics engine should be updated.</param>
            <returns><see langword="true"/> if the removal was successful, <see langword="false"/> otherwise.</returns>
            <example>
            How to remove a 3D collider from a dynamic map:
            <code>
            if(dynamicMap.RemoveCollider3D(frame, colliderIndex)) {
              Log.Info("Removed 3D collider with index: " + colliderIndex);
            }
            else {
              LogError?.Log("Failed to remove 3D collider with index: " + colliderIndex);
            }
            </code>
            </example>
        </member>
        <member name="M:Quantum.DynamicMap.MoveLastColliderInfo3DToTarget(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Moves source to target, so that it can be safely removed.
            Source is always the last collider in the array.
            </summary>
            <param name="f"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.DynamicMap.RemoveAllColliders3D(Quantum.Core.FrameBase)">
            <summary>
            Removes all 3D colliders.
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:Quantum.DynamicMap.RemoveAllColliders2D(Quantum.Core.FrameBase)">
            <summary>
            Removes all 2D colliders.
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:Quantum.DynamicMap.RemoveCollider2D(Quantum.Core.FrameBase,System.Int32,System.Boolean)">
            <summary>
            Removes a 2D collider from the map.
            </summary>
            <param name="f">The frame.</param>
            <param name="colliderId">The collider index to remove.</param>
            <param name="resetPhysics">If the physics engine should be updated.</param>
            <returns><see langword="true"/> if the removal was successful, <see langword="false"/> otherwise.</returns>
            <example>
            How to remove a 2D collider from a dynamic map:
            <code>
            if(dynamicMap.RemoveCollider2D(frame, colliderIndex)) {
              Log.Info("Removed 2D collider with index: " + colliderIndex);
            }
            else {
              LogError?.Log("Failed to remove 2D collider with index: " + colliderIndex);
            }
            </code>
            </example>
        </member>
        <member name="M:Quantum.DynamicMap.FromStaticMap``1(Quantum.Map)">
            <summary>
            Converts a static map to a dynamic map.
            </summary>
            <param name="map">The map to copy.</param>
            <returns>The created dynamic version.</returns>
            <example>
            How to convert a static map to a dynamic map:
            <code>
            var dynamicMap = DynamicMap.FromStaticMap(f.Map);
            </code>
            </example>
        </member>
        <member name="M:Quantum.DynamicMap.OnBeforeSerialize">
            <summary>
            Unity serialization callback.
            </summary>
        </member>
        <member name="M:Quantum.DynamicMap.OnAfterDeserialize">
            <summary>
            Unity deserialization callback.
            </summary>
        </member>
        <member name="T:Quantum.MapStaticCollider2D">
            <summary>
            The data structure to hold 2D static colliders for a Quantum map.
            Static colliders are baked into the map and are used for efficient collision detection.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.MapStaticCollider2D.Rotation">
            <summary>
            Collider rotation in radians.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.Position">
            <summary>
            Collider world position.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.Height">
            <summary>
            Pseudo 3D collider height (used in conjunction with <see cref="T:Quantum.Transform2DVertical"/>).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.VerticalOffset">
            <summary>
            Pseudo 3D vertical position (used in conjunction with <see cref="T:Quantum.Transform2DVertical"/>).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.PhysicsMaterial">
            <summary>
            The physics material assigned to the static collider.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.Layer">
            <summary>
            The physics layer.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.ShapeType">
            <summary>
            The 2D shape type.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.CircleRadius">
            <summary>
            The 2D collider radius (used for circle shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.BoxExtents">
            <summary>
            The 2D box extents (used for box shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.CapsuleSize">
            <summary>
            The 2D capsule size (used for capsule shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.EdgeExtent">
            <summary>
            The 2D edge extent (used for edge shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.PolygonCollider">
            <summary>
            The 2D polygon collider data (used for polygon shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2D.StaticData">
            <summary>
            Additional static collider meta data.
            </summary>
        </member>
        <member name="P:Quantum.MapStaticCollider2D.CapsuleRadius">
            <summary>
            Calculated 2D capsule radius.
            </summary>
        </member>
        <member name="P:Quantum.MapStaticCollider2D.CapsuleExtent">
            <summary>
            Calculate the 2D capsule extent.
            </summary>
        </member>
        <member name="T:Quantum.MapStaticCollider2DPolygonData">
            <summary>
            Stores 2D polygon collider data used on static collider <see cref="T:Quantum.MapStaticCollider2D"/>.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.MapStaticCollider2DPolygonData.Vertices">
            <summary>
            The vertex array.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider2DPolygonData.Normals">
            <summary>
            Vertex normals stored in an array.
            </summary>
        </member>
        <member name="M:Quantum.MapStaticCollider2DPolygonData.Loaded(Photon.Deterministic.Native.Allocator)">
            <summary>
            The asset loaded callback to initialize runtime data. 
            Must be called from <see cref="M:Quantum.Map.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/>.
            </summary>
            <param name="allocator">Memory allocator</param>
        </member>
        <member name="M:Quantum.MapStaticCollider2DPolygonData.Disposed(Photon.Deterministic.Native.Allocator)">
            <summary>
            The asset dispose callback to release memory.
            </summary>
            <param name="allocator">Memory allocator</param>
        </member>
        <member name="T:Quantum.MapStaticCollider3D">
            <summary>
            The data structure to hold 3D static colliders for a Quantum map.
            Static colliders are baked into the map and are used for efficient collision detection.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.MapStaticCollider3D.Rotation">
            <summary>
            The 3D collider rotation.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.Position">
            <summary>
            The world position of the collider.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.PhysicsMaterial">
            <summary>
            The physics material assigned to the static collider.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.ShapeType">
            <summary>
            The 3D shape type.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.SphereRadius">
            <summary>
            The sphere radius (used for sphere shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.CapsuleRadius">
            <summary>
            The capsule radius (used for capsule shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.CapsuleHeight">
            <summary>
            The capsule height (used for capsule shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.BoxExtents">
            <summary>
            The box extents (used for box shapes).
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.SmoothSphereMeshCollisions">
            <summary>
            The physics solver will resolve sphere and capsule shapes against mesh collisions as if the mesh was a regular flat and smooth plane.
            </summary>
        </member>
        <member name="F:Quantum.MapStaticCollider3D.StaticData">
            <summary>
            Static collider meta data.
            </summary>
        </member>
        <member name="P:Quantum.MapStaticCollider3D.CapsuleExtent">
            <summary>
            Calculate the capsule extend.
            </summary>
        </member>
        <member name="T:Quantum.MeshUnmanagedTrianglesRef">
            <summary>
            A lightweight reference to a mesh in unmanaged memory.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.MeshUnmanagedTrianglesRef.Triangles">
            <summary>
            The unmanaged buffer containing all triangles.
            </summary>
        </member>
        <member name="F:Quantum.MeshUnmanagedTrianglesRef.First">
            <summary>
            The index of the first triangle of this mesh in the buffer.
            </summary>
        </member>
        <member name="F:Quantum.MeshUnmanagedTrianglesRef.UsedCount">
            <summary>
            The amount of triangles used.
            </summary>
        </member>
        <member name="F:Quantum.MeshUnmanagedTrianglesRef.Capacity">
            <summary>
            The capacity of the buffer.
            </summary>
        </member>
        <member name="P:Quantum.MeshUnmanagedTrianglesRef.Count">
            <summary>
            Obsolete. Use <see cref="F:Quantum.MeshUnmanagedTrianglesRef.UsedCount"/> instead.
            </summary>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.#ctor(Quantum.UnmanagedTriangleArray,System.Int32,System.Int32)">
            <summary>
            Obsolete. Use overload that takes 'capacity' parameter instead. See <see cref="T:Quantum.MeshUnmanagedTrianglesRef"/>.
            </summary>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.#ctor(Quantum.UnmanagedTriangleArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:Quantum.MeshUnmanagedTrianglesRef"/>.
            </summary>
            <param name="triangles">The unmanaged buffer containing all triangles.</param>
            <param name="first">The index of the first triangle of this mesh in the buffer.</param>
            <param name="capacity">The capacity of the buffer.</param>
            <param name="usedCount">The amount of triangles used.</param>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.#ctor">
            <summary>
            Creates an empty <see cref="T:Quantum.MeshUnmanagedTrianglesRef"/>.
            </summary>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.GetTriangles(System.Int32@)">
            <summary>
            Gets a pointer to the first triangle of the mesh and the number of used triangles.
            Mesh triangles are allocated in a contiguous buffer starting from the first triangle.
            </summary>
            <param name="usedCount">the number of used triangles in the mesh.</param>
            <returns>A pointer to first triangle in the mesh.</returns>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.GetTriangles(System.Int32@,System.Int32@)">
            <summary>
            Gets a pointer to the first triangle of the mesh, the number of used triangles and the capacity of the buffer.
            </summary>
            <param name="usedCount">The number of used triangles in the mesh.</param>
            <param name="capacity">The capacity of the buffer allocated for the mesh.</param>
            <returns>A pointer to first triangle in the mesh.</returns>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.TryGetTriangles(Quantum.TriangleCCW*@,System.Int32@)">
            <inheritdoc cref="M:Quantum.MeshUnmanagedTrianglesRef.TryGetTriangles(Quantum.TriangleCCW*@,System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.TryGetTriangles(Quantum.TriangleCCW*@,System.Int32@,System.Int32@)">
            <summary>
            Tries to get a buffer of the triangles on this mesh collider.
            </summary>
            <param name="triangles">A pointer to the first triangles in this mesh collider, if any. <see langword="null"/> otherwise.</param>
            <param name="usedCount">How many triangles are used.</param>
            <param name="capacity">The capacity of the buffer allocated for this mesh.</param>
            <returns><see langword="true"/> if this mesh collider has triangles. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.GetFreeTriangles(System.Int32@)">
            <summary>
            Gets a buffer of unused triangles on this mesh collider.
            </summary>
            <param name="freeCount">How many triangles are free.</param>
            <returns>A pointer to the first free triangles in this mesh collider, if any. <see langword="null"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.TryGetFreeTriangles(Quantum.TriangleCCW*@,System.Int32@)">
            <summary>
            Gets a buffer of unused triangles on this mesh collider.
            </summary>
            <param name="freeTriangles">A pointer to the first free triangles in this mesh collider, if any. <see langword="null"/> otherwise.</param>
            <param name="freeCount">How many triangles are free.</param>
            <returns><see langword="true"/> if this mesh collider has free triangles. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.MeshUnmanagedTrianglesRef.ToManagedTriangles(Quantum.MeshUnmanagedTrianglesRef)">
            <summary>
            Converts a MeshUnmanagedTrianglesRef to a MeshTriangleVerticesCcw.
            This is useful when needing to convert from runtime triangle data to an editor/managed format.
            </summary>
            <param name="unmanagedRef">The unmanaged triangles reference to convert</param>
            <returns>A new MeshTriangleVerticesCcw containing the converted data</returns>
        </member>
        <member name="T:Quantum.MapEntityId">
            <summary>
            Represents a Quantum entity that is part of a map.
            </summary>
        </member>
        <member name="F:Quantum.MapEntityId.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.MapEntityId.SceneIndexPlusOne">
            <summary>
            The index of the entity inside the map.
            Is 1-based, 0 means invalid.
            </summary>
        </member>
        <member name="P:Quantum.MapEntityId.SceneIndex">
            <summary>
            The index of the entity inside the map.
            </summary>
        </member>
        <member name="P:Quantum.MapEntityId.IsValid">
            <summary>
            Is the entity id valid.
            </summary>
        </member>
        <member name="P:Quantum.MapEntityId.Invalid">
            <summary>
            Returns a invalid entity id.
            </summary>
        </member>
        <member name="M:Quantum.MapEntityId.Create(System.Int32)">
            <summary>
            Creates a new entity id.
            </summary>
            <param name="sceneIndex">Scene index</param>
            <returns>Map entity id</returns>
        </member>
        <member name="M:Quantum.MapEntityId.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes an entity id that is used inside a component.
            E.g. <see cref="T:Quantum.MapEntityLink"/>.
            </summary>
            <param name="ptr">Entity id data pointer</param>
            <param name="serializer">Frame serializer</param>
        </member>
        <member name="M:Quantum.MapEntityId.Print(System.Void*,Quantum.FramePrinter)">
            <summary>
            Prints debug information about the entity id.
            </summary>
            <param name="ptr">Entity id pointer</param>
            <param name="printer">The printer</param>
        </member>
        <member name="M:Quantum.MapEntityId.ToString">
            <summary>
            Override ToString method to debug output readable class members.
            </summary>
            <returns>Debug string</returns>
        </member>
        <member name="M:Quantum.MapEntityId.Equals(Quantum.MapEntityId)">
            <summary>
            Equal operator.
            </summary>
            <param name="other">Other map entity id</param>
            <returns><see langword="true"/> is the map entities are equal.</returns>
        </member>
        <member name="M:Quantum.MapEntityId.GetHashCode">
            <summary>
            Override GetHashCode method to return the hash code of the entity id.
            </summary>
            <returns>Hash of the entity id</returns>
        </member>
        <member name="M:Quantum.MapEntityId.Equals(System.Object)">
            <summary>
            Override equals method to compare the entity id with another object.
            </summary>
            <param name="obj">Other map entity id object</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.MapEntityId.op_Equality(Quantum.MapEntityId,Quantum.MapEntityId)">
            <summary>
            Overload equals operator to compare two map entity ids.
            </summary>
            <param name="left">Map entity id a</param>
            <param name="right">Map entity id b</param>
            <returns><see langword="true"/> is a and b are equal.</returns>
        </member>
        <member name="M:Quantum.MapEntityId.op_Inequality(Quantum.MapEntityId,Quantum.MapEntityId)">
            <summary>
            Overload unequals operator to compare two map entity ids.
            </summary>
            <param name="left">Map entity id a</param>
            <param name="right">Map entity id b</param>
            <returns><see langword="true"/> is a and b are unequal.</returns>
        </member>
        <member name="T:Quantum.MapEntityLink">
            <summary>
            Map entity link can be used inside a component to reference an entity from the map.
            </summary>
        </member>
        <member name="F:Quantum.MapEntityLink.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.MapEntityLink.Index">
            <summary>
            The index of the entity inside the map.
            </summary>
        </member>
        <member name="M:Quantum.MapEntityLink.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serialized the map entity link on the snapshot.
            </summary>
            <param name="ptr">Pointer to data</param>
            <param name="stream">The stream to serialize to</param>
        </member>
        <member name="T:Quantum.Migration.IgnoreInAssetObjectCheckAttribute">
            <summary>
            Helper attribute used in Quantum migration.
            </summary>
        </member>
        <member name="T:Quantum.Migration.LegacyAssetObjectWrapper">
            <summary>
            Obsolete API.
            </summary>
        </member>
        <member name="P:Quantum.Migration.LegacyAssetObjectWrapper.AssetObject">
            <summary>
            Obsolete API.
            </summary>
        </member>
        <member name="P:Quantum.Migration.LegacyAssetObjectWrapper.AssetObjectPropertyPath">
            <summary>
            Obsolete API.
            </summary>
        </member>
        <member name="T:Quantum.IProgressBar">
            <summary>
            A progress bar that reports back during navmesh baking.
            </summary>
        </member>
        <member name="M:Quantum.IProgressBar.SetInfo(System.String)">
            <summary>
            The current task has changed.
            </summary>
            <param name="v">Task name</param>
        </member>
        <member name="M:Quantum.IProgressBar.SetProgress(System.Single)">
            <summary>
            The current progress of the current task.
            </summary>
            <param name="v">Progress from 0 to 1.</param>
        </member>
        <member name="T:Quantum.NavMeshBakeData">
            <summary>
            he MapNavMesh.BakeData is a complete mesh that is then further processed and converted to a Quantum navmesh.
            The mesh is build in the way of a triangle strip.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.Name">
            <summary>
            The name of the navmesh accessible inside the simulation by <see cref="F:Quantum.Map.NavMeshes"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.Position">
            <summary>
            The position of the navmesh. 
            Final navmesh vertices are stored in global space and their positions are translated by this during baking.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.AgentRadius">
            <summary>
            The radius of the largest agents that the navmesh is created for. 
            This value is only used to render debug graphics.
            Older versions of Quantum were permitting different agent radii, but that has been abolished. Now, agents can walk up until
            their pivot is on the edge of the navmesh. This way the margin agents should keep away from walls is baked into the triangles. 
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.Regions">
            <summary>
            All regions ids that are used in this navmesh. During baking the region ids will be added to the Region list of the Map asset 
            and their index is baked into the navmesh triangles region mask (NavMeshTriangle.Regions). The regions are aggregated on the map
            because a map can have multiple navmeshes that share the region ids.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.Vertices">
            <summary>
            The vertices of the navmesh.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.Triangles">
            <summary>
            The triangle of the navmesh. This is a regular mesh data structure where the triangles and vertices are kept in two separate arrays 
            and the triangle points into the vertex array to mark their 3 vertices.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.Links">
            <summary>
            Link between positions on the same navmesh.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.ClosestTriangleCalculation">
            <summary>
            The Quantum navmesh uses a grid for spatial partitioning. 
            Each grid cell will have a fallback triangle assigned. 
            The default search is quite slow (BruteForce) while SpiralOut is more efficient it could result in empty fallback triangles.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.ClosestTriangleCalculationDepth">
            <summary>
            The number of grid cells to expand the <see cref="F:Quantum.NavMeshBakeDataFindClosestTriangle.SpiralOut"/> search.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeData.EnableQuantum_XY">
            <summary>
            When enabled the navmesh baking will flip Y and Z components of the vertex positions to support navmeshes generated in the XY plane.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBakeData.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Asset serialization.
            </summary>
            <param name="stream">Input stream</param>
            <param name="write">Writing or reading.</param>
        </member>
        <member name="T:Quantum.NavMeshBakeDataFindClosestTriangle">
            <summary>
            A fallback triangle for each grid cell is searched. This type symbolized two different search algorithms.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataFindClosestTriangle.BruteForce">
            <summary>
            Iterates through all triangles because the triangle closest can be inside a neighbor cell.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataFindClosestTriangle.SpiralOut">
            <summary>
            Spiral around the current cell to find a closest triangle in neighbors.
            This could result in empty fallback triangles, which will unlikely cause any problems.
            Requires to set <see cref="F:Quantum.NavMeshBakeData.ClosestTriangleCalculationDepth"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataFindClosestTriangle.None">
            <summary>
            No fallback triangle search. 
            Will speed up navmesh baking considerably but make <see cref="M:Quantum.NavMesh.FindClosestTriangleFast(Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask@)"/> be not usable.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshBakeDataLink">
            <summary>
            Creates a extra link between two triangles on the navmesh.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.Start">
            <summary>
            Start position of the link. Must be on the same navmesh. 
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.End">
            <summary>
            End position of the link. Must be on the same navmesh.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.StartTriangle">
            <summary>
            The triangle id of the start.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.EndTriangle">
            <summary>
            The triangle id of the end.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.Bidirectional">
            <summary>
            Can the link be traversed from both directions.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.CostOverride">
            <summary>
            The cost of the connection.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.RegionId">
            <summary>
            The region id that the link belongs to. Default is <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataLink.Name">
            <summary>
            The name of the link. 
            Can be queried by <see cref="F:Quantum.NavMesh.Links"/> and <see cref="M:Quantum.NavMeshPathfinder.CurrentLink(Quantum.Core.FrameBase)"/>.Name
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBakeDataLink.Serialize(Quantum.ByteStream,System.Boolean,Quantum.NavMeshBakeDataLink@)">
            <summary>
            Asset serialization.
            </summary>
            <param name="stream">The input stream</param>
            <param name="write">Write or read</param>
            <param name="instance">The instance to serialize</param>
        </member>
        <member name="T:Quantum.NavMeshBakeDataTriangle">
            <summary>
            Triangles are expected to have clock-wise winding order. 
            Not all fields have to be filled out. Some of them are only needed for the legacy navmesh drawing tool.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataTriangle.VertexIds">
            <summary>
            Must have length of 3. 
            The referenced vertices as indices into the vertex array.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataTriangle.RegionId">
            <summary>
            The region that this triangle belongs to. Default is <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataTriangle.Cost">
            <summary>
            The cost of the triangle. Default should be FP._1.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataTriangle.Area">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBakeDataTriangle.Serialize(Quantum.ByteStream,System.Boolean,Quantum.NavMeshBakeDataTriangle@)">
            <summary>
            Asset serialization.
            </summary>
            <param name="stream">Input stream</param>
            <param name="write">Write or read</param>
            <param name="instance">Instance to serialize</param>
        </member>
        <member name="T:Quantum.NavMeshBakeDataVertex">
            <summary>
            Stores a 3D position.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakeDataVertex.Position">
            <summary>
            The position of the vertex.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBakeDataVertex.Serialize(Quantum.ByteStream,System.Boolean,Quantum.NavMeshBakeDataVertex@)">
            <summary>
            Asset serialization.
            </summary>
            <param name="stream">Input stream</param>
            <param name="write">Write or read</param>
            <param name="instance">The instance to serialize</param>
        </member>
        <member name="T:Quantum.NavMeshBaker">
            <summary>
            The NavMeshBaker turns the intermediate navmesh format <see cref="T:Quantum.NavMeshBakeData"/> into a Quantum <see cref="T:Quantum.NavMesh"/>.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBaker.BakeIntoExistingNavMesh(Quantum.NavMeshBakeData,Quantum.NavMesh,Quantum.IProgressBar)">
            <summary>
            Bake navmesh intermediate date (bake data) into an existing Quantum navmesh asset without passing a map.
            Used for example to update a navmesh that uses serialization type <see cref="F:Quantum.NavMeshSerializeType.BakeDataOnly"/>.
            </summary>
            <param name="bakeData">Bake data</param>
            <param name="progressBar">Progress bar instance, can be <see langword="null"/></param>
            <param name="existingNavmesh">Existing navmesh asset to update, can be <see langword="null"/></param>
        </member>
        <member name="M:Quantum.NavMeshBaker.BakeNavMesh(Quantum.Map,Quantum.NavMeshBakeData,Quantum.IProgressBar,Quantum.NavMesh)">
            <summary>
            Bake navmesh intermediate date (bake data) into a Quantum navmesh asset.
            </summary>
            <param name="map">Map asset that the navmesh belongs to, set this to <see langword="null"/> if you are updating an existing navmesh</param>
            <param name="bakeData">Bake data</param>
            <param name="progressBar">Progress bar instance, can be <see langword="null"/></param>
            <param name="existingNavmesh">Existing navmesh asset to update, can be <see langword="null"/></param>
            <returns>Baked navmesh asset</returns>
        </member>
        <member name="M:Quantum.NavMeshBaker.LocateGridCells(System.Int32@,System.Int32@,System.Int32@,System.Int32@,Photon.Deterministic.FPVector2,System.Int32,System.Int32,System.Int32,Photon.Deterministic.FPVector2[])">
            <summary>
            Find and set min and max grid cell indices for the given positions.
            </summary>
            <param name="xMin">Min x cell index</param>
            <param name="xMax">Max x cell index</param>
            <param name="yMin">Min y cell index</param>
            <param name="yMax">Max y cell index</param>
            <param name="worldOffset">World offset</param>
            <param name="gridNodeSize">Grid node size</param>
            <param name="gridSizeX">Grid size x of the navmesh</param>
            <param name="gridSizeY">Grid size y of the navmesh</param>
            <param name="positions">Positions to use as bounds for the resulting cell indecies</param>
            <returns></returns>
        </member>
        <member name="T:Quantum.NavMeshAvoidanceAgent">
            <summary>
            A component that will make the agent avoid other agents while calculating the navigation steering.
            Requires <see cref="T:Quantum.NavMeshSteeringAgent"/> and <see cref="T:Quantum.NavMeshPathfinder"/>.
            </summary>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.NavMeshAvoidanceAgent.SIZE">
            <summary>
            The component size in bytes.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceAgent.AvoidanceMask">
            <summary>
            Agent avoidance mask. Agents with layers outside this mask are ignored.
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceAgent.AvoidanceLayer">
            <summary>
            Agent avoidance layer. 
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceAgent.Priority">
            <summary>
            The avoidance priority level.
            </summary>
            <remarks>
            <para>Priority (in non-legacy/fast mode) is only compared and split 0.25 and 0.75 between agents (required by reciprocal avoidance).</para>
            <para>Most important = 0</para>
            <para>Least important = 99</para>
            </remarks>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="M:Quantum.NavMeshAvoidanceAgent.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Callback to serialize this component into a snapshot of the game state.
            </summary>
            <param name="p">The component pointer</param>
            <param name="serializer">The serializer</param>
        </member>
        <member name="T:Quantum.NavMeshAvoidanceObstacle">
            <summary>
            A component that represents a circle-shaped obstacle for navmesh agents to avoid.
            This is not altering the navmesh itself, but it is dynamic obstacle to be avoided by other agents steering.
            </summary>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.NavMeshAvoidanceObstacle.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceObstacle.IsActive">
            <summary>
            Enable or disable the obstacle.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceObstacle.AvoidanceLayer">
            <summary>
            Configure the avoidance layer of the obstacle.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceObstacle.Radius">
            <summary>
            Configure the radius of the obstacle.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshAvoidanceObstacle.Velocity">
            <summary>
            An optional velocity for the obstacle.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshAvoidanceObstacle.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Callback to serialize this component into a snapshot of the game state.
            </summary>
            <param name="p">The component pointer</param>
            <param name="serializer">The serializer</param>
        </member>
        <member name="T:Quantum.NavMeshPathfinder">
            <summary>
            The NavMeshAgent is an entity component for automated navmesh navigation and steering.
            Use <see cref="M:Quantum.NavMeshPathfinder.Create(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig)"/> to create pathfinder components.
            Also see <see cref="T:Quantum.NavMesh"/> and <see cref="T:Quantum.NavMeshAgentConfig"/>
            </summary>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.NavMeshPathfinder.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshPathfinder.RegionMask">
            <summary>
            Set individual region mask for this agent.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.ConfigId">
            <summary>
            Agent config asset.
            </summary>
            <remarks>Use see <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/> to change config during runtime.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.InternalTarget">
            <summary>
            Target position is potentially corrected and moved inside the navmesh (read only).
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.IsActive">
            <summary>
            The active state of the agent. 
            </summary>
            <remarks>Agent can be active and have no waypoints. That usually means, that the agent will try to find a path during the next tick.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.NavMeshGuid">
            <summary>
            Current assigned navmesh.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.Target">
            <summary>
            Input target position set by SetTarget(). (Read Only)
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointIndex">
            <summary>
            The current waypoint the agent steers towards or -1 if there are no stored waypoints.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointCount">
            <summary>
            The number of waypoints currently stored on the agent. 
            </summary>
            <remarks>The number of waypoints stored can be lower than the actual computed path (for performance reasons during copying the frame memory).</remarks>
            <remarks>The first waypoint is always the agent position when the path finding triggered.</remarks>
            <remarks>The last waypoint is a regular waypoint but a re-pathing is executed when the agent is steering toward it to reduce glitches during path recalculations.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointMaxCount">
            <summary>
            The maximum number of waypoint that can be stored on the agent.
            </summary>
            <remarks>Defined by <see cref="F:Quantum.NavMeshAgentConfig.CachedWaypointCount"/>.</remarks>
        </member>
        <member name="P:Quantum.NavMeshPathfinder.WaypointDetectionDistanceSqr">
            <summary>
            This value is used evaluate if a waypoint is reached and represents the squared distance an agent has traveled during the last tick.
            </summary>
            <remarks>It is automatically set when the entity has <see cref="T:Quantum.NavMeshSteeringAgent"/></remarks>
            <remarks>If not set the config value is used from <see cref="F:Quantum.NavMeshAgentConfig.DefaultWaypointDetectionDistance"/></remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.Create(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig)">
            <summary>
            Use this factory to correctly initialize internals.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Entity</param>
            <param name="config">Agent config</param>
            <returns>NavMeshPathfinder component that can be Set() on an entity</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.IsOnLink(Quantum.Core.FrameBase)">
            <summary>
            Agent is active and is currently traversing a link.
            </summary>
            <param name="f">Frame</param>
            <returns><see langword="true"/> is waypoint is active, agent has waypoints and the current waypoint is a link end</returns>
            <remarks>Its current waypoint has the <see cref="F:Quantum.Navigation.WaypointFlag.LinkEnd"/> flag.</remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.CurrentLink(Quantum.Core.FrameBase)">
            <summary>
            Returns the link that the agent currently is traversing.
            </summary>
            <param name="f">Frame</param>
            <returns>Link index pointing into Navmesh.Links[] or -1</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.CurrentWaypointHasFlag(Quantum.Core.FrameBase,Quantum.Navigation.WaypointFlag)">
            <summary>
            Test the current waypoint for a flag.
            </summary>
            <param name="f">Frame</param>
            <param name="waypointFlag">Flag to test for</param>
            <returns><see langword="true"/> if the agent is active, has waypoints and if the current waypoint has the provided flag.</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.GetWaypoint(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Get the waypoint position by waypoint index.
            </summary>
            <param name="f">Frame</param>
            <param name="index">Waypoint index</param>
            <returns>3D waypoint position, zero if waypoint index is not valid</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.GetWaypointFlags(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Access the waypoint flags by index.
            </summary>
            <param name="f">Frame</param>
            <param name="index">Waypoint index (0..MaxWaypoints)</param>
            <returns>Mask of <see cref="T:Quantum.Navigation.WaypointFlag"/></returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.GetWaypointLink(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Access the waypoint links by index.
            </summary>
            <param name="f">Frame</param>
            <param name="index">Waypoint index (0..MaxWaypoints)</param>
            <returns>Link index pointing into in Navmesh.Links[] or -1</returns>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)">
            <summary>
            Update the agent config during run-time. Uses the default config from the SimulationConfig when config is <see langword="null"/>.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Agent entity, required to forward the config to other agent components</param>
            <param name="config">Agent config asset</param>
            <param name="overwrite">Reset properties to their respective config values (e.g. NavMeshSteeringAgent.MaxSpeed, NavMeshAvoidanceAgent.Priority, ..)</param>
            <remarks>Will set the config for <see cref="T:Quantum.NavMeshSteeringAgent"/> and <see cref="T:Quantum.NavMeshAvoidanceAgent"/> components on this entity as well.</remarks>
            <remarks>This can trigger a repath when the waypoint count is changed.</remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.AssetRef{Quantum.NavMeshAgentConfig},System.Boolean)">
            <summary>
            Update the agent config during run-time. Will used default agent config from the SimulationConfig if the provided asset ref can not be resolved. Internally calls <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Agent entity, required to forward the config to other agent components</param>
            <param name="configAssetRef">Asset ref to navmesh config.</param>
            <param name="overwrite">Reset properties to their respective config values (e.g. NavMeshSteeringAgent.MaxSpeed, NavMeshAvoidanceAgent.Priority, ..)</param>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.SetTarget(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Quantum.NavMesh)">
            <summary>
            Set agent target position. Does nothing if the target is in <see cref="F:Quantum.NavMeshAgentConfig.StoppingDistance"/> range.
            </summary>
            <param name="f">Frame object</param>
            <param name="target">Target position will be saved as <see cref="P:Quantum.NavMeshPathfinder.Target"/> and clamped to the grid as <see cref="P:Quantum.NavMeshPathfinder.InternalTarget"/></param>
            <param name="navMesh">The navmesh the agent uses during navigation</param>
            <remarks>Will reset the current waypoint list.</remarks>
            <remarks>When the agent is currently on a link, the target position is saved but the waypoints are left intact. The current waypoint is then marked with <see cref="F:Quantum.Navigation.WaypointFlag.RepathWhenReached"/>.</remarks>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.ForceRepath(Quantum.Core.FrameBase)">
            <summary>
            Forces the agent to repath during the next Update(). Reset the waypoints and waypoint index internally.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.Stop(Quantum.Core.FrameBase,Quantum.EntityRef,System.Boolean)">
            <summary>
            Stops the pathfinder agent immediately and disables it and resets its waypoints.
            </summary>
            <param name="f">Frame</param>
            <param name="entity">Requires the entity to check for the SteeringAgent</param>
            <param name="resetVelocity">If <see langword="true"/> it will check for a SteeringAgent component and set the velocity to zero</param>
        </member>
        <member name="M:Quantum.NavMeshPathfinder.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Callback to serialize this component into a snapshot of the game state.
            </summary>
            <param name="p">The component pointer</param>
            <param name="serializer">The serializer</param>
        </member>
        <member name="T:Quantum.NavMeshSteeringAgent">
            <summary>
            A component to enable the steering toward a target position calculated by the navigation system.
            Requires <see cref="T:Quantum.NavMeshPathfinder"/> component.
            </summary>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.NavMeshSteeringAgent.SIZE">
            <summary>
            The component size in bytes.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.Acceleration">
            <summary>
            Agent acceleration value.
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.CurrentSpeed">
            <summary>
            The current speed per second that the agent is moving.
            </summary>
            <remarks>Performs FPMath.Sqrt or the Velocity internally.</remarks>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.MaxSpeed">
            <summary>
            Agent max speed value.
            </summary>
            <remarks>Is potentially set to its original config value <see cref="M:Quantum.NavMeshPathfinder.SetConfig(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.NavMeshAgentConfig,System.Boolean)"/>. </remarks>
        </member>
        <member name="P:Quantum.NavMeshSteeringAgent.Velocity">
            <summary>
            The current linear velocity of the agents. This is set from the internal steering.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshSteeringAgent.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Callback to serialize this component into a snapshot of the game state.
            </summary>
            <param name="p">The component pointer</param>
            <param name="serializer">The serializer</param>
        </member>
        <member name="T:Quantum.Navigation">
            <summary>
            Navigation API
            </summary>
            \ingroup NavigationApi
        </member>
        <member name="T:Quantum.Navigation.AvoidanceQuality">
            <summary>
            Quality settings for agent avoidance.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceQuality.Fast">
            <summary>
            Only a minimum of avoidance candidates are computed.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceQuality.Good">
            <summary>
            Reasonable number of candidates are calculated with the best cost-benefit ratio
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceQuality.Best">
            <summary>
            Maximum number of collision free candidates are generated
            </summary>
        </member>
        <member name="T:Quantum.Navigation.AvoidanceType">
            <summary>
            Avoidance type applied to the navmesh agent.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceType.None">
            <summary>
            Active avoidance disabled. But other agents would still be influenced.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AvoidanceType.Internal">
            <summary>
            Internal avoidance calculations using velocity obstacle model.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.MovementType">
            <summary>
            Defines how velocity is applied to the agent component.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.None">
            <summary>
            Not applied.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.Transform">
            <summary>
            Directly applied to <see cref="T:Quantum.Transform2D"/> or  <see cref="T:Quantum.Transform3D"/> of the agent.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.DynamicBody">
            <summary>
            Not used anymore.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.CharacterController3D">
            <summary>
            Not used anymore.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.MovementType.Callback">
            <summary>
            Does not move the agent but executes the MoveAgent signal.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.PathQuality">
            <summary>
            The quality of the A* heuristic function.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathQuality.Fast">
            <summary>
            Uses parent G and Manhattan Distance
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathQuality.Good">
            <summary>
            Creates a pivot point on the entry edge towards goal, recalculates G and Manhattan Distance
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathQuality.Best">
            <summary>
            Creates a pivot point on the entry edge towards goal, recalculates G with another pivot point towards start and Euclidean Distance
            </summary>
        </member>
        <member name="T:Quantum.Navigation.RawPathAllocationStrategy">
            <summary>
            In most cases the maximum raw path size set in <see cref="F:Quantum.Navigation.Config.RawPathSize"/> will suffice.
            Exceeding the size in Fixed mode will fail the pathfinding request.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.RawPathAllocationStrategy.Fixed">
            <summary>
            Fixed size allocation. Will fail if the path exceeds the maximum size.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.RawPathAllocationStrategy.Allocating">
            <summary>
            Growing the raw path size when needed.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.VerticalPositioningType">
            <summary>
            Defines how the agents y-position will be calculation in 3D.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.VerticalPositioningType.None">
            <summary>
            Not applied.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.VerticalPositioningType.Navmesh">
            <summary>
            The agents walk on the navmesh.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.VerticalPositioningType.Physics">
            <summary>
            The agents walks on 3D physics geometry.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.WaypointFlag">
            <summary>
            Flags stored with each navmesh agent waypoint.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.Target">
            <summary>
            The waypoint is the target
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.LinkStart">
            <summary>
            The waypoint is the start of a off-mesh link
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.LinkEnd">
            <summary>
            The waypoint is the end of a off-mesh link
            </summary>
        </member>
        <member name="F:Quantum.Navigation.WaypointFlag.RepathWhenReached">
            <summary>
            The agent will perform a repath when reaching the waypoint
            </summary>
        </member>
        <member name="P:Quantum.Navigation.NavigationConfig">
            <summary>
            Access the navigation config used for the navigation originated from the SimulationConfig.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.Dispose">
            <summary>
            Dispose the navigation API.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.Update(Quantum.Core.FrameBase,Photon.Deterministic.FP,Quantum.INavigationCallbacks,Quantum.Task.TaskHandle)">
            <summary>
            Update the multi-threaded navigation API.
            </summary>
            <param name="frame">Frame object</param>
            <param name="deltaTime">Delta time</param>
            <param name="callbacks">Callback object to use (can be <see langword="null"/>)</param>
            <param name="handle">The task handle to add tasks to</param>
            <returns>Update handle.</returns>
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMesh,Quantum.NavMeshRegionMask@)">
            <summary>
            Find a path (thread-safe). Uses automatic target correction with radius 1 and PathQuality Good.
            </summary>
            <param name="frame">Frame object.</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMesh,Quantum.NavMeshRegionMask@,System.Boolean,Photon.Deterministic.FP,Quantum.Navigation.PathQuality)">
            <summary>
            Find a path (thread-safe). 
            </summary>
            <param name="frame">Frame object.</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <param name="automaticTargetCorrection">If the target is outside the navmesh the position will be tried to be corrected.</param>
            <param name="automaticTargetCorrectionRadius">The range to validated the start and target position.</param>
            <param name="quality">The path quality</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.NavMesh,Quantum.NavMeshRegionMask@)">
            <summary>
            Find a path (thread-safe). 
            </summary>
            <param name="frame">Frame object</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.NavMesh,Quantum.NavMeshRegionMask@,System.Boolean,Photon.Deterministic.FP,Quantum.Navigation.PathQuality)">
            <summary>
            Find a path (thread-safe). 
            </summary>
            <param name="frame">Frame object</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="navmesh">The navmesh to operate on</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <param name="automaticTargetCorrection">If the target is outside the navmesh the position will be tried to be corrected.</param>
            <param name="automaticTargetCorrectionRadius">The range to validate the start and target position.</param>
            <param name="quality">The path quality</param>
            <returns>The corrected start position</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.LineOfSight(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.NavMeshRegionMask@,Quantum.NavMesh,System.Int32,System.Int32)">
            <summary>
            Check line of sight inside the navmesh. This also works in 3D and creates a funnel through the navmesh triangles. Start and destination must be inside the navmesh.
            </summary>
            <param name="positionStart">Start position</param>
            <param name="positionDestination">Target position</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh to check</param>
            <param name="triangleStart">Optionally provide the triangle that the start position is on</param>
            <param name="triangleDestination">Optionally provide the triangle that the destination position is on</param>
            <returns><see langword="true"/> if there is an unobstructed line of sight on the navmesh</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.LineOfSight(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.NavMeshRegionMask@,Quantum.NavMesh,System.Int32,System.Int32)">
            <summary>
            Check line of sight inside the navmesh. This also works in 3D and creates a funnel through the navmesh triangles. Start and destination must be inside the navmesh.
            </summary>
            <param name="positionStart">Start position</param>
            <param name="positionDestination">Target position</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh to check</param>
            <param name="triangleStart">Optionally provide the triangle that the start position is on</param>
            <param name="triangleDestination">Optionally provide the triangle that the destination position is on</param>
            <returns><see langword="true"/> if there is a unobstructed line of sight on the navmesh</returns>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.Navigation.Raycast2D(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.NavMesh,Photon.Deterministic.FPVector2@,System.Int32@)">
            <summary>
            Raycast through the navmesh. Only works 2D, even when the navmesh is 3D. The ray is tested against navmesh borders.
            </summary>
            <param name="frame">Frame object</param>
            <param name="origin">Ray origin</param>
            <param name="direction">Ray direction</param>
            <param name="distance">Ray length</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh</param>
            <param name="hit">Position of the closest hit</param>
            <param name="borderIndex">Index of the border that was hit (Navmesh.Borders[i])</param>
            <returns><see langword="true"/> is a hit was generated.</returns>
        </member>
        <member name="M:Quantum.Navigation.Raycast2D(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.NavMesh,Photon.Deterministic.FPVector2@,System.Int32@)">
            <summary>
            Raycast through the navmesh. Only works 2D, even when the navmesh is 3D. The ray is tested against navmesh borders.
            </summary>
            <param name="frame">Frame object</param>
            <param name="origin">Ray origin</param>
            <param name="direction">Ray direction</param>
            <param name="distance">Ray length</param>
            <param name="regionMask">Region mask to identify enabled or disabled regions</param>
            <param name="navmesh">Navmesh</param>
            <param name="hit">Position of the closest hit</param>
            <param name="borderIndex">Index of the border that was hit (Navmesh.Borders[i])</param>
            <returns><see langword="true"/> is a hit was generated.</returns>
        </member>
        <member name="M:Quantum.Navigation.Raycast2D(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.NavMesh,Photon.Deterministic.FPVector2@)">
            <summary>
            Obsolete method.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.Raycast2D(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.NavMesh,Photon.Deterministic.FPVector2@)">
            <summary>
            Obsolete method.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.GetPathFinderData(Quantum.FrameThreadSafe)">
            <summary>
            Access the pathfinder data after running Navigation.FindPath(). Don't save the IPathFinderData object anywhere, copy the needed.
            </summary>
            <param name="f">Frame object</param>
            <returns>PathFinder data read interface.</returns>
        </member>
        <member name="M:Quantum.Navigation.GetDebugInformation(System.Int32)">
            <summary>
            Access read-only debug pathfinder information for thread index.
            </summary>
            <param name="threadIndex">Thread index</param>
            <returns>Debug information about the pathfinder state.</returns>
        </member>
        <member name="T:Quantum.Navigation.Constants">
            <summary>
            Global navigation constants.
            </summary>
            <remarks>Most of the values are kept in static form to enable being set from the outside.</remarks>
            \ingroup NavigationApi
        </member>
        <member name="F:Quantum.Navigation.Constants.PathFinderSize">
            <summary>
            Default number of open nodes for the pathfinder (re-allocated automatically).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.ActiveVertexDefaultSize">
            <summary>
            Default number of active nodes the pathfinder works with (re-allocated automatically).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.FunnelBufferSize">
            <summary>
            The default size of the buffer used for funneling nodes (re-allocated automatically).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.MaxFunnelPathSize">
            <summary>
            The maximum size of the funneled path.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.MaxRegions">
            <summary>
            The maximum amount of regions per map.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Constants.MaxWaypoints">
            <summary>
            The maximum amount of waypoints that can be stored on a navmesh agent.
            </summary>
            The value set in <see cref="F:Quantum.NavMeshAgentConfig.CachedWaypointCount"/> is clamped to this.
        </member>
        <member name="F:Quantum.Navigation.Constants.MinStoppingDistance">
            <summary>
            Defines the minimum possible stopping distance of an agent.
            </summary>
            <remarks><see cref="F:Quantum.NavMeshAgentConfig.StoppingDistance"/> is clamped to this.</remarks>
        </member>
        <member name="F:Quantum.Navigation.Constants.GenerateFunnelPathNormals">
            <summary>
            Set this to <see langword="true"/> to generate funnel path normals based on the proximity of borders.
            The option is off by default to save processing power.
            This is a legacy option, the normals are internally not needed anymore.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.Constants.Reset">
            <summary>
            Reset all static fields to their default values.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.IPathFinderData">
            <summary>
            An interface to access a few selected internal pathfinding data.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.IPathFinderData.PathSize">
            <summary>
            The path size.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.IPathFinderData.Path">
            <summary>
            The path.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.IPathFinderData.RawPathSize">
            <summary>
            The raw path size.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.IPathFinderData.RawPath">
            <summary>
            The raw, unfunneled path
            </summary>
        </member>
        <member name="T:Quantum.Navigation.PathFinder">
            <summary>
            Navmesh TA* pathfinder class.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.PathFinder.RawPathSize">
            <summary>
            The size of the <see cref="P:Quantum.Navigation.PathFinder.RawPath"/>.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.PathFinder.RawPath">
            <summary>
            The un-funneled raw path.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.#ctor(Photon.Deterministic.Native.Allocator,System.Int32,System.Int32,Quantum.Navigation.RawPathAllocationStrategy)">
            <summary>
            Create a pathfinder object.
            </summary>
            <param name="allocator">Allocator</param>
            <param name="openNodesSize">The maximum number of open nodes the A* can work with (usually <see cref="F:Quantum.Navigation.Constants.PathFinderSize"/></param>
            <param name="rawPathSize">The raw path size</param>
            <param name="rawPathAllocationStrategy">Fail path or allocate when above rawPathSize</param>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.#ctor(Photon.Deterministic.Native.Allocator,Quantum.NavMesh,System.Int32,Quantum.Navigation.RawPathAllocationStrategy)">
            <summary>
            Create a pathfinder for a certain navmesh.
            </summary>
            <remarks>Uses the triangle count as pathfinder size.</remarks>
            <param name="allocator">Allocator</param>
            <param name="navmesh">Navmesh object</param>
            <param name="rawPathSize">The raw path size</param>
            <param name="rawPathAllocationStrategy">Fail path or allocate when above rawPathSize</param>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.SetNavMesh(Quantum.NavMesh)">
            <summary>
            Bind a navmesh to a pathfinder.
            </summary>
            <param name="navmesh">Navmesh object</param>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.Dispose">
            <summary>
            Dispose the pathfinder object.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Boolean,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.Navigation.PathQuality,Quantum.NavMesh)">
            <summary>
            Find path.
            </summary>
            <param name="frame">The frame object.</param>
            <param name="start">Starting position</param>
            <param name="end">Target position</param>
            <param name="automaticTargetCorrection">If the target is outside the navmesh the position will be tried to be corrected.</param>
            <param name="automaticTargetCorrectionRadius">The range of cells used to validated the target position.</param>
            <param name="regionMask">Region mask is used to check if navmesh parts are active or inactive</param>
            <param name="quality">The path quality</param>
            <param name="navmesh">The navmesh to operate on</param>
            <returns>The corrected end position</returns>
        </member>
        <member name="M:Quantum.Navigation.PathFinder.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Boolean,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.Navigation.PathQuality,Quantum.NavMesh)">
            <summary>
            See <see cref="M:Quantum.Navigation.PathFinder.FindPath(Quantum.FrameThreadSafe,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Boolean,Photon.Deterministic.FP,Quantum.NavMeshRegionMask@,Quantum.Navigation.PathQuality,Quantum.NavMesh)"/>
            </summary>
        </member>
        <member name="P:Quantum.Navigation.PathFinder.PathSize">
            <summary>
            The funneled path size.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.PathFinder.Path">
            <summary>
            THe funneled path.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.PathVertex">
            <summary>
            The data structure for the internal path waypoints.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathVertex.Index">
            <summary>
            The triangle index of this waypoint in <see cref="F:Quantum.NavMesh.Triangles"/>.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathVertex.Point">
            <summary>
            The world position of this waypoint.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathVertex.Normal">
            <summary>
            The normal of an optional border that the waypoint touches. Default is <see cref="P:Photon.Deterministic.FPVector3.Zero"/>.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.PathVertex.Link">
            <summary>
            The index of the link in <see cref="F:Quantum.NavMesh.Links"/> that this waypoint is connected to.
            Default is -1.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.AngularSpeedInstantRotationThreshold">
            <summary>
            We can shortcut the angular acceleration by using this threshold
            </summary>
        </member>
        <member name="T:Quantum.Navigation.FindPathResult">
            <summary>
            The result object for FindPath requests.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.FindPathResult.Code">
            <summary>
            The result codes for FindPath requests.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.Code.Success">
            <summary>
            Find path was successful.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.Code.InvalidStartPosition">
            <summary>
            Find path failed because the start position could not be moved on to the navmesh.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.Code.InvalidEndPosition">
            <summary>
            Find path failed because the end position could not be moved on to the navmesh. 
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.Code.NoPathFound">
            <summary>
            Find path failed because the pathfinding could not create a path.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.Code.PathTooLong">
            <summary>
            Indicates that the path was larger than SimulationConfig.Navigation.RawPathSize and the allocation strategy is set to Fixed.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.FindPathResult.CreateSuccess(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Create a successful FindPathResult.
            </summary>
            <param name="correctedStartPosition">The corrected (<see cref="F:Quantum.NavMeshAgentConfig.AutomaticTargetCorrection"/>) start position.</param>
            <param name="correctedEndPosition">The corrected (<see cref="F:Quantum.NavMeshAgentConfig.AutomaticTargetCorrection"/>) end position.</param>
            <returns>Configured FindPathResult object</returns>
        </member>
        <member name="M:Quantum.Navigation.FindPathResult.CreateError(Quantum.Navigation.FindPathResult.Code)">
            <summary>
            Create a failed FindPathResult.
            </summary>
            <param name="errorCode">Error code</param>
            <returns>Configured FindPathResult object</returns>
        </member>
        <member name="P:Quantum.Navigation.FindPathResult.PathFinderData">
            <summary>
            Set the internal pathfinder data for this result.
            Access is granted through <see cref="P:Quantum.Navigation.FindPathResult.PathSize"/> etc.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.Result">
            <summary>
            Pathfinding result.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.CorrectedStartPosition">
            <summary>
            The possibly corrected or unchanged start position.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.FindPathResult.CorrectedEndPosition">
            <summary>
            The corrected or unchanged end position.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.FindPathResult.PathSize">
            <summary>
            The size of the path.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.FindPathResult.Path">
            <summary>
            The funneled and optimized path. Never cache this array it's only valid after one FindPath() call.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.FindPathResult.RawPathSize">
            <summary>
            The raw path size.
            </summary>
        </member>
        <member name="P:Quantum.Navigation.FindPathResult.RawPath">
            <summary>
            The raw unoptimized a* path. Never cache this array it's only valid after one FindPath() call.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.Config">
            <summary>
            Global navmesh configurations which are part of the <see cref="!:SimulationConfig"/>.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.DefaultNavMeshAgent">
            <summary>
            The default navmesh agent config used by every agent that does not set an explicit one.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.EnableNavigationCallbacks">
            <summary>
            Enabled navigation callbacks and signals.
            </summary>
            <remarks>Callbacks are always executed from the main thread.</remarks>
        </member>
        <member name="F:Quantum.Navigation.Config.HeightThresholdForWaypoints">
            <summary>
            Used in 3D to decide whether the actor and target are on the same height. Should be around the height of the character.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.HeightThresholdForAvoidance">
            <summary>
            Used in 3D to quickly filter out agents on other height levels. Should be around the height of the character.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.RawPathSize">
            <summary>
            The default size of the raw path generated by the pathfinder.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.RawPathAllocationStrategy">
            <summary>
            Strategy to execute when paths are attempted with more nodes than <see cref="F:Quantum.Navigation.Config.RawPathSize"/>. Fixed will fail pathfinding and Allocate will allocate more memory. Default is Fixed.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.EnableAvoidance">
            <summary>
            A global settings to remove all avoidance task scheduling (disable to optimize for performance).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.AvoidanceRange">
            <summary>
            Defines the distance between two agents (minus their combined radius) used to determine if they are considering each other for further avoidance calculations (broad phase).
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.MaxAvoidanceCandidates">
            <summary>
            A global setting for the maximum number of avoidance candidates used by each agent. More candidates requires more memory and CPU time but can increase the quality.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.Config.VelocityObstacleTruncationFactor">
            <summary>
             The default factor non-moving velocity obstacles are truncated with.
            </summary>
        </member>
        <member name="T:Quantum.Navigation.ThreadLocal">
            <summary>
            An internal class that stored multi-threading related navigation context.
            </summary>
        </member>
        <member name="F:Quantum.Navigation.ThreadLocal.PathFinder">
            <summary>
            The path finder instance.
            </summary>
        </member>
        <member name="M:Quantum.Navigation.ThreadLocal.#ctor(Photon.Deterministic.Native.Allocator,System.Int32,Quantum.Navigation.RawPathAllocationStrategy)">
            <summary>
            Creates a new thread local instance.
            </summary>
            <param name="allocator">Allocator to use.</param>
            <param name="rawPathSize">Default raw path size.</param>
            <param name="rawPathAllocationStrategy">Default raw path allocation strategy.</param>
        </member>
        <member name="M:Quantum.Navigation.ThreadLocal.AllocateMailboxBuffer(Quantum.NavMesh)">
            <summary>
            Allocates the mailbox buffer which is used to hold temporary memory for pathfinding calls for individual threads.
            </summary>
            <param name="navmesh">Navmesh to use</param>
        </member>
        <member name="M:Quantum.Navigation.ThreadLocal.Dispose">
            <summary>
            Dispose pathfinder and mailbox buffer and release the memory.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshAgentSteeringData">
            <summary>
            Navmesh agent steering data passed into callbacks.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentSteeringData.Waypoint">
            <summary>
            Current waypoint position.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentSteeringData.Flags">
            <summary>
            Is the current waypoint the target.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshAgentSteeringData.DesiredDirection">
            <summary>
            The velocity the agent desires to move influenced by avoidance (if enabled). The velocity is normalized over the current speed.
            </summary>
        </member>
        <member name="T:Quantum.INavigationCallbacks">
            <summary>
            Basic callbacks from the navigation system to Quantum systems.
            </summary>
        </member>
        <member name="M:Quantum.INavigationCallbacks.OnWaypointReached(Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.Navigation.WaypointFlag,System.Boolean@)">
            <summary>
            Callback is executed when a waypoint has been reached.
            Set resetAgent parameter to <see langword="true"/> when a new target for the agent was issued inside this callback.
            </summary>
            <param name="entity">Agent entity</param>
            <param name="waypoint">World position waypoint</param>
            <param name="waypointFlags">Waypoint flags</param>
            <param name="resetAgent">A flag to prevent resetting the agent after this callback.</param>
        </member>
        <member name="M:Quantum.INavigationCallbacks.OnSearchFailed(Quantum.EntityRef,System.Boolean@)">
            <summary>
            The path finding request issued by <see cref="M:Quantum.NavMeshPathfinder.SetTarget(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Quantum.NavMesh)"/> failed.
            Set resetAgent parameter to <see langword="true"/> when a new target for the agent was issued inside this callback.
            </summary>
            <param name="entity">Agent entity</param>
            <param name="resetAgent">A flag to prevent resetting the agent after this callback.</param>
        </member>
        <member name="M:Quantum.INavigationCallbacks.OnMoveAgent(Quantum.EntityRef,Photon.Deterministic.FPVector2)">
            <summary>
            This callback is only called when <see cref="F:Quantum.NavMeshAgentConfig.MovementType"/> is set to <see cref="F:Quantum.Navigation.MovementType.Callback"/>."/>
            It can be used to implement a custom steering behavior for the agent using the desiredDirection which is an outcome of the pathfinding and avoidance systems.
            </summary>
            <param name="entity">Agent entity</param>
            <param name="desiredDirection">Desired movement direction</param>
        </member>
        <member name="T:Quantum.NavMeshPortal">
            <summary>
            The Quantum navmesh stores connections between neighboring triangles as portals.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshPortal.LeftVertex">
            <summary>
            The left vertex index of the portal.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshPortal.RightVertex">
            <summary>
            The right vertex index of the portal.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshPortal.Neighbor">
            <summary>
            The neighbor triangle index.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshPortal.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Serialize the portal from the <see cref="F:Quantum.NavMesh.DataAsset"/>.
            </summary>
            <param name="stream">Data asset stream</param>
            <param name="write">Write or read</param>
        </member>
        <member name="T:Quantum.NavMeshTriangle">
            <summary>
            The navmesh triangle data structure.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Vertex0">
            <summary>
            Vertex index 0 pointing into the <see cref="F:Quantum.NavMesh.Vertices"/> array.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Vertex1">
            <summary>
            Vertex index 1 pointing into the <see cref="F:Quantum.NavMesh.Vertices"/> array.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Vertex2">
            <summary>
            Vertex index 2 pointing into the <see cref="F:Quantum.NavMesh.Vertices"/> array.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Neighbors">
            <summary>
            All neighboring triangles.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Links">
            <summary>
            All links from this triangle pointing into <see cref="F:Quantum.NavMesh.Links"/>"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Borders">
            <summary>
            All borders on this navmesh triangle pointing into <see cref="F:Quantum.NavMesh.Borders"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Area">
            <summary>
            The area code of the triangle.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Regions">
            <summary>
            The region mask of this triangle. 
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Cost">
            <summary>
            The cost modifier of the triangle.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Normal">
            <summary>
            The normal of this triangle.
            May be computed during loading if <see cref="F:Quantum.NavMesh.SerializeType"/> is not <see cref="F:Quantum.NavMeshSerializeType.FullWithMetaData"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangle.Center">
            <summary>
            The center of this triangle.
            May be computed during loading if <see cref="F:Quantum.NavMesh.SerializeType"/> is not <see cref="F:Quantum.NavMeshSerializeType.FullWithMetaData"/>.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshTriangle.ComputeNormal(Quantum.NavMesh)">
            <summary>
            Computes the normal of the triangle and stores the result in <see cref="F:Quantum.NavMeshTriangle.Normal"/>.
            This is performed during baking or during loading if <see cref="F:Quantum.NavMesh.SerializeType"/> is not <see cref="F:Quantum.NavMeshSerializeType.FullWithMetaData"/>.
            </summary>
            <param name="navMesh">Navmesh to lookup vertices.</param>
        </member>
        <member name="M:Quantum.NavMeshTriangle.ComputeCenter(Quantum.NavMesh)">
            <summary>
            Computes the center of the navmesh and stores the result in <see cref="F:Quantum.NavMeshTriangle.Center"/>.
            This is performed during baking or during loading if <see cref="F:Quantum.NavMesh.SerializeType"/> is not <see cref="F:Quantum.NavMeshSerializeType.FullWithMetaData"/>.
            </summary>
            <param name="navMesh">Navmesh to look up vertices.</param>
        </member>
        <member name="M:Quantum.NavMeshTriangle.Serialize(Quantum.ByteStream,System.Boolean,Quantum.NavMesh)">
            <summary>
            Serializes the triangle data.
            </summary>
            <param name="stream">Stream</param>
            <param name="write">Write or read</param>
            <param name="navMesh">The navmesh this triangle belongs to.</param>
        </member>
        <member name="T:Quantum.NavMeshVertex">
            <summary>
            The navmesh vertex data structure is saves as an array in the <see cref="F:Quantum.NavMesh.Vertices"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshVertex.Point">
            <summary>
            The world position of the navmesh vertex.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshVertex.Borders">
            <summary>
            The borders that are connected to the vertex are pointing into <see cref="F:Quantum.NavMesh.Borders"/>.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshVertex.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Serialize or deserialize the vertex data.
            </summary>
            <param name="stream">Stream</param>
            <param name="write">Write or read</param>
        </member>
        <member name="M:Quantum.NavMeshVertex.CalculateNormal(System.Int32,Quantum.NavMesh,Quantum.NavMeshRegionMask@)">
            <summary>
            Computes the normal of the vertex against all adjacent borders.
            </summary>
            <param name="vertexIndex">The vertex index</param>
            <param name="navmesh">The navmesh</param>
            <param name="regionMask">The region mask to include or exclude borders.</param>
            <returns>The normal agaist all borders at the vertex or <see cref="P:Photon.Deterministic.FPVector3.Zero"/>.</returns>
        </member>
        <member name="T:Quantum.NavMeshBorder">
            <summary>
            The navmesh border data structure.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorder.V0">
            <summary>
            Vertex index 0 pointing into <see cref="F:Quantum.NavMesh.Vertices"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorder.V1">
            <summary>
            Vertex index 1 pointing into <see cref="F:Quantum.NavMesh.Vertices"/>.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorder.Regions">
            <summary>
            The region mask that this border belongs to.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorder.RegionsOffmesh">
            <summary>
            The region mask that the other side of the border belongs to.
            Borders can be manifested between two regions when one of them in enabled and the other disabled.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorder.Normal">
            <summary>
            The normal of the border based on the two connected vertices.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBorder.ComputeNormal(Quantum.NavMesh)">
            <summary>
            Computed the normal of the border based on the two connected vertices.
            </summary>
            <param name="navMesh">Navmesh</param>
        </member>
        <member name="M:Quantum.NavMeshBorder.Serialize(Quantum.ByteStream,System.Boolean,Quantum.NavMesh)">
            <summary>
            Serialize or deserialize the vertex data to an asset.
            </summary>
            <param name="stream">Asset stream</param>
            <param name="write">Write or read</param>
            <param name="navMesh">Navmesh instance</param>
        </member>
        <member name="T:Quantum.NavMeshBorderNode">
            <summary>
            The navmesh border node data structure that stores all borders inside a 2D grid for global raycasts for example.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorderNode.Borders">
            <summary>
            All border indices pointint into <see cref="F:Quantum.NavMesh.Borders"/>
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBorderNode.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Serialize or deserialize the vertex data to an asset.
            </summary>
            <param name="stream">The asset stream</param>
            <param name="write">Write or read</param>
        </member>
        <member name="T:Quantum.NavMeshTriangleNode">
            <summary>
            A grid or all triangles used for quick lookups.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangleNode.Triangles">
            <summary>
            All triangles inside this grid cell, point into <see cref="F:Quantum.NavMesh.Triangles"/>.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshTriangleNode.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Serialize or deserialize the vertex data to an asset.
            </summary>
            <param name="stream">Asset stream</param>
            <param name="write">Write or read</param>
        </member>
        <member name="T:Quantum.NavMeshLink">
            <summary>
            The navmesh link data structure.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshLink.Start">
            <summary>
            The world position of the start of the link.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshLink.End">
            <summary>
            The world position of the end of the link.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshLink.Triangle">
            <summary>
            The triangle of the end position.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshLink.CostOverride">
            <summary>
            The cost override.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshLink.Region">
            <summary>
            The region mask that can enabled or disable this link during run-time.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshLink.Name">
            <summary>
            The name of the link.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshLink.Serialize(Quantum.ByteStream,System.Boolean,System.Int32)">
            <summary>
            Serialize or deserialize the vertex data to an asset.
            </summary>
            <param name="stream">Asset stream</param>
            <param name="write">Write or read</param>
            <param name="regionBlockCount">Make transition from 2 to 8 mask blocks non-breaking.</param>
        </member>
        <member name="T:Quantum.NavMeshTriangleCenterGridNode">
            <summary>
            This grid stores one fallback triangle per cell.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshTriangleCenterGridNode.Triangles">
            <summary>
            All triangle of different regions inside this grid cell, point into <see cref="F:Quantum.NavMesh.Triangles"/>.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshTriangleCenterGridNode.Serialize(Quantum.ByteStream,System.Boolean)">
            <summary>
            Serialize or deserialize the vertex data to an asset.
            </summary>
            <param name="stream">Asset stream</param>
            <param name="write">Write or read</param>
        </member>
        <member name="T:Quantum.NavMeshRegionMask">
            <summary>
            Internally stores a unsigned long to be able to toggle 512 different regions. 
            </summary>
            <remarks>When instantiating a NavMeshRegionMask, all regions are toggled off.</remarks>
            <remarks>Use <see cref="P:Quantum.NavMeshRegionMask.Default"/> to create a mask with all regions toggled on.</remarks>
            <example><code>
            // Toggle a region per frame
            f.NavMeshRegionMask->ToggleRegion(cmd.Region, !f.NavMeshRegionMask->IsRegionEnabled(cmd.Region));
            // Check if a region id is active
            var isRegionActive = f.NavMeshRegionMask-&gt;IsRegionEnabled(regionId);
            // Check if a NavMeshRegionMask (found on the pathfinder component) is active
            var isTriangleActive = f.Unsafe.GetPointer&lt;NavMeshPathfinder&gt;(entity)-&gt;RegionMask.Overlaps(*f.NavMeshRegionMask);
            </code></example>
        </member>
        <member name="F:Quantum.NavMeshRegionMask.SIZE">
            <summary>
            The size on the struct.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshRegionMask.MAX_REGIONS">
            <summary>
            The maximum number of regions.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshRegionMask.BLOCK_COUNT">
            <summary>
            The number of 4 byte blocks that the mask uses.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.Default">
            <summary>
            Default mask with all regions toggled on.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.MainArea">
            <summary>
            Mask that includes only the main area.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.Empty">
            <summary>
            Mask that includes no area.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Combine(Quantum.NavMeshRegionMask,Quantum.NavMeshRegionMask@)">
            <summary>
            Combine two region masks. 
            </summary>
            <param name="a">A</param>
            <param name="b">B</param>
            <returns>A region must be active in both masks for be toggled on on the resulting mask.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Callback to serialize this component into a snapshot of the game state.
            </summary>
            <param name="ptr">The component pointer</param>
            <param name="serializer">The serializer</param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Print(System.Void*,Quantum.FramePrinter)">
            <summary>
            Callback to print this component data.
            </summary>
            <param name="ptr">The component pointer</param>
            <param name="printer">The printer</param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.#ctor(System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Constructor with all flag masks.
            This method could change in the future if the max regions count is increased again.
            </summary>
            <param name="regionMask1"></param>
            <param name="regionMask2"></param>
            <param name="regionMask3"></param>
            <param name="regionMask4"></param>
            <param name="regionMask5"></param>
            <param name="regionMask6"></param>
            <param name="regionMask7"></param>
            <param name="regionMask8"></param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Create(System.Int32)">
            <summary>
            Create a NavMeshRegionMask with one region enabled.
            </summary>
            <param name="region">Region id to enabled.</param>
            <returns>Region Mask</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Create(System.Int32[])">
            <summary>
            Create a mask using a list of region ids.
            </summary>
            <param name="regionList">List of region ids/indices</param>
            <returns>Region mask</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Create(System.Collections.Generic.List{System.Int32})">
            <summary>
            Create a mask using a list of region ids.
            </summary>
            <param name="regionList">List of region ids/indices</param>
            <returns>Region mask</returns>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.HasValidRegions">
            <summary>
            Returns <see langword="true"/> if the mask has at least one valid region set including the main area.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.HasValidNoneMainRegion">
            <summary>
            Returns <see langword="true"/> if the mask includes a region other than the main area.
            </summary>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.IsMainArea">
            <summary>
            Checks if the mask only contains the main area
            </summary>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.ToggleRegion(System.Int32,System.Boolean)">
            <summary>
            Toggle a region by id (or index).
            </summary>
            <param name="region">Region id (defined by the region list inside the Map)</param>
            <param name="enabled">Toggle region on or off</param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Add(System.Int32)">
            <summary>
            Add a region id to the mask.
            </summary>
            <param name="region">Region index</param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Remove(System.Int32)">
            <summary>
            Remove a region from the mask.
            </summary>
            <param name="region">Region index</param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.IsRegionEnabled(System.Int32)">
            <summary>
            Check if a region is active.
            </summary>
            <param name="region">Region id (or index)</param>
            <returns><see langword="true"/> if the region is active.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.IsSubset(Quantum.NavMeshRegionMask@)">
            <summary>
            Check if the region mask is included inside the other.
            </summary>
            <param name="other">Other mask, usually the one from Frame</param>
            <returns><see langword="true"/> if all regions are included in other</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.IsSuperset(Quantum.NavMeshRegionMask@)">
            <summary>
            Check is the region mask of other is included in ours.
            </summary>
            <param name="other">Other region mask</param>
            <returns><see langword="true"/> if all regions inside the other mask are also active in ours</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Overlaps(Quantum.NavMeshRegionMask@)">
            <summary>
            Returns <see langword="true"/> if the mask and <paramref name="other"/> have at least one region in common.
            </summary>
            <param name="other">Other region mask</param>
            <returns><see langword="true"/> if masks have one region in common</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Clear">
            <summary>
            This sets all regions to active.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Equals(Quantum.NavMeshRegionMask)">
            <summary>
            Equality check.
            </summary>
            <param name="other">Other mask</param>
            <returns><see langword="true"/>, if both masks are equal.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Equals(Quantum.NavMeshRegionMask@)">
            <summary>
            Equality check.
            </summary>
            <param name="other">Other mask</param>
            <returns><see langword="true"/>, if both masks are equal.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Equals(System.Object)">
            <summary>
            Equality check.
            </summary>
            <param name="obj">Other object</param>
            <returns><see langword="true"/>, is both masks are equal.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.GetHashCode">
            <summary>
            Get hash code override.
            </summary>
            <returns>Hashcode of this mask.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.ToString">
            <summary>
            ToString override.
            </summary>
            <returns>A debug string representation of the mask.</returns>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.Serialize(Quantum.ByteStream,System.Boolean,System.Int32)">
            <summary>
            Serialize the mask into a byte stream, used by asset serialization and deserialization.
            </summary>
            <param name="stream">Stream object.</param>
            <param name="write">Write or read.</param>
            <param name="blockCount">Optionally customize block count.</param>
        </member>
        <member name="M:Quantum.NavMeshRegionMask.#ctor(System.UInt64)">
            <summary>
            Constructor.
            </summary>
            <param name="regions">Raw region mask</param>
        </member>
        <member name="P:Quantum.NavMeshRegionMask.Mask">
            <summary>
            Access to underlying bit mask.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshSerializeType">
            <summary>
            How to serialize the NavMesh data.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshSerializeType.Full">
            <summary>
            Default value. Serialize the full NavMesh data and recompute metadata on deserialize.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshSerializeType.FullWithMetaData">
            <summary>
            Serialize the full NavMesh data and keep the metadata.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshSerializeType.BakeDataOnly">
            <summary>
            Serialize only the <see cref="T:Quantum.NavMeshBakeData"/> and recreate the NavMesh at runtime. 
            This option is useful when using runtime generated frame assets, the runtime baking is taking a bit and there may be hiccups.
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.PhysicsEngine2D">
            <summary>
            2D Physics API
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.PhysicsEngine2D.Api">
            <summary>
            2D Physics API
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi">
            <summary>
            Struct to provide thread-safe access to the physics functions.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.GetCallbacks(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetCallbacks(Quantum.EntityRef)"/>
        </member>
        <member name="P:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.Map">
            <inheritdoc cref="P:Quantum.Physics2D.PhysicsEngine2D.Api.Map"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.AllocatePersistentHitCollection(System.Int32)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.FreePersistentHitCollection(Quantum.Physics2D.HitCollection*)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.FreePersistentHitCollection(Quantum.Physics2D.HitCollection*)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.IsValidQueryRef(Quantum.PhysicsQueryRef@)">
            <summary>
            Checks if a given broad-phase physics query reference is valid for result retrieval.
            Broad-phase queries must be injected before the Physics system Update, their Ref stored and the results
            retrieved after the Physics Update, on the same frame.
            </summary>
            <param name="queryRef">The query ref to be checked.</param>
            <returns><see langword="true"/> if the query ref is valid and query results can be retrieved from it this frame. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.GetQueryHits(System.Int32)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.GetQueryHits(Quantum.PhysicsQueryRef@)">
            <summary>
            Gets the results of a broad-phase query added to the 2D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <returns>A <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.TryGetQueryHits(System.Int32,Quantum.Physics2D.HitCollection@)">
            <summary>
            Obsolete. Use 'TryGetQueryHits(in PhysicsQueryRef, out HitCollection)' overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.TryGetQueryHits(Quantum.PhysicsQueryRef@,Quantum.Physics2D.HitCollection@)">
            <summary>
            Tries to get the results of a broad-phase query added to the 2D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <param name="queryHits">The <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits. Default if the index is not valid.</param>
            <returns><see langword="true"/> if the index is valid, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.GetAllQueriesHits(Quantum.Physics2D.HitCollection*@,System.Int32@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetAllQueriesHits(Quantum.Physics2D.HitCollection*@,System.Int32@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Physics2D.HitCollection*,Quantum.Shape2D*,Quantum.Transform2D*,Quantum.Physics2D.Hit*)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Physics2D.HitCollection*,Quantum.Shape2D*,Quantum.Transform2D*,Quantum.Physics2D.Hit*)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D*,Quantum.Transform2D*,Quantum.Physics2D.Hit*)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D*,Quantum.Transform2D*,Quantum.Physics2D.Hit*)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Obsolete. Use the <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/> overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Obsolete. Use the <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/> overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Obsolete. Use the <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)"/> overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Shape2D.CircleShape,Quantum.Transform2D*,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Obsolete. Use the <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)"/> overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.Raycast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.Raycast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.Raycast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.Raycast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.Linecast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.Linecast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.Linecast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.Linecast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.RaycastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.RaycastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.RaycastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.RaycastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.LinecastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.LinecastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.LinecastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.LinecastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.ShapeCast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.ShapeCastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.OverlapShape(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.OverlapShape(Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.OverlapShape(Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ThreadSafeApi.OverlapShape(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)">
            <summary>
            Sets which 2D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider2D component attached to be able to collide with other physics entries.</remarks>
            <remarks>For receiving the callbacks, set the <see cref="T:Quantum.CallbackFlags"/> and implement the corresponding signal on a system.</remarks>
            </summary>
            <param name="entity">An entity with a PhysicsCollider2D component attached.</param>
            <param name="flags">The <see cref="T:Quantum.CallbackFlags"/> of the desired collision callbacks.</param>
            <code>frame.Physics2D.SetCallbacks(entity, CallbackFlags.OnDynamicCollision | CallbackFlags.OnStaticTriggerEnter);</code>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetCallbacks(Quantum.EntityRef)">
            <summary>
            Get the flags that represent which 2D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider2D component attached to be able to collide with other physics entries.</remarks>
            <remarks>To modify the callbacks, use <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            </summary>
            <param name="entity">The entity from which to get the callback flags.</param>
            <returns>The callback flags set to a given entity. Default if the entity did not have callback flags set.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ResetCallbacks(Quantum.EntityRef)">
            <summary>
            Resets the tracking history of collisions the <paramref name="entity"/> might have.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.#ctor(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Initializes an Api object to provide the physics functions.
            </summary>
            <param name="frame">The reference of a frame.</param>
            <param name="threadCount">The number of threads.</param>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Init">
            <summary>
            Initializes the game scene and creates all the physics static entries using the settings from the map. 
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Init(Quantum.AssetRef{Quantum.Map})">
            <summary>
            Initializes the game scene by cleaning all physics data and settings and create the new static physics entries for each static collider component in the <paramref name="mapRef"/>. 
            </summary>
            <param name="mapRef">The Map asset for loading static collider data and other physics settings.</param>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ResetScene">
            <summary>
            Resets the entries buffer and removes all the dynamic entries of the scene. Also, joints, queries and collision data are cleaned.
            The <see cref="T:Quantum.PhysicsCommon.MapPhysicsData"/> is changed to default and the <see cref="T:Quantum.PhysicsSceneSettings"/> is changed to initial state.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Update(Quantum.Core.ICollisionCallbacks2D,Photon.Deterministic.FP,Quantum.Task.TaskHandle)">
            <summary>
            Schedules all tasks that compose the 2D Physics Update loop.
            If the frame map changed, the static part of the physics engine is also reset.
            </summary>
            <param name="callbacks">A listener of physics collision callbacks.</param>
            <param name="dt">Delta-time of the physics update loop</param>
            <param name="taskHandle">Handle of the last task scheduled in the graph.</param>
            <returns>The task handle of the last task scheduled by the physics engine.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ResetMap">
            <summary>
            Resets 2D physics scene map asset guid.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.PhysicsEngine2D.Api.Map">
            <summary>
            Retrieves the map asset currently used on the physics scene.
            <remarks>
            The map currently used by the physics scene is only updated during verified simulations,
            so this map can be different from the frame Map during predictions, when the latter is changed. 
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)">
            <summary>
            Allocates a persistent <see cref="T:Quantum.Physics2D.HitCollection"/> on the heap with an initial capacity.
            To free an allocated persistent collection of 2D hits, use <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.FreePersistentHitCollection(Quantum.Physics2D.HitCollection*)"/>.
            </summary>
            <param name="defaultCapacity">The initial <see cref="T:Quantum.Physics2D.Hit"/> buffer capacity allocated for the hit collection.</param>
            <returns>A pointer to the allocated hit collection.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.FreePersistentHitCollection(Quantum.Physics2D.HitCollection*)">
            <summary>
            Free a persistent <see cref="T:Quantum.Physics2D.HitCollection"/> previously allocated on the heap.
            To allocate a persistent collection of 2D hits, use <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.
            </summary>
            <param name="collection">A pointer to the persistent hit collection to be freed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the hit collection was not allocated as persistent.</exception>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.IsValidQueryRef(Quantum.PhysicsQueryRef@)">
            <summary>
            Checks if a given broad-phase physics query reference is valid for result retrieval.
            Broad-phase queries must be injected before the Physics system Update, their Ref stored and the results
            retrieved after the Physics Update, on the same frame.
            </summary>
            <param name="queryRef">The query ref to be checked.</param>
            <returns><see langword="true"/> if the query ref is valid and query results can be retrieved from it this frame. <see langword="false"/> otherwise.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(Quantum.PhysicsQueryRef@)">
            <summary>
            Gets the results of a broad-phase query added to the 2D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <returns>A <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetQueryHits(System.Int32)">
            <summary>
            Obsolete. Use 'GetQueryHits(in PhysicsQueryRef)' overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.TryGetQueryHits(Quantum.PhysicsQueryRef@,Quantum.Physics2D.HitCollection@)">
            <summary>
            Tries to get the results of a broad-phase query added to the 2D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <param name="queryHits">The <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits. Default if the index is not valid.</param>
            <returns><see langword="true"/> if the index is valid, <see langword="false"/> otherwise.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.TryGetQueryHits(System.Int32,Quantum.Physics2D.HitCollection@)">
            <summary>
            Obsolete. Use 'TryGetQueryHits(in PhysicsQueryRef, out HitCollection)' overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.GetAllQueriesHits(Quantum.Physics2D.HitCollection*@,System.Int32@)">
            <summary>
            Gets all the results for all the broad-phase queries added to the 2D physics scene this frame.
            </summary>
            <param name="queriesHits">A buffer of <see cref="T:Quantum.Physics2D.HitCollection"/> with <paramref name="queriesCount"/> elements, one for each broad-phase query added.</param>
            <param name="queriesCount">The number of elements in the <paramref name="queriesHits"/> buffer, also matching the number on broad-phase queries added.</param>
            <returns><see langword="true"/> if at least one broad-phase query has been added from a system that runs before the physics engine.</returns>
            <example>
            Example of how to iterate over added broad-phase queries results.
            <code>
            if (f.Physics2D.GetAllQueriesHits(out var queriesHits, out var queriesCount)) {
              for (var i = 0; i &lt; queriesCount; i++) {
                var queryHits = queriesHits + i;
                Log.Info($"Preemptive query {i} has {queryHits->Count} hits.");
              }
            }
            </code>
            </example>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Physics2D.HitCollection*,Quantum.Shape2D*,Quantum.Transform2D*,Quantum.Physics2D.Hit*)">
            <summary>
            Checks if the shape of the hit overlaps another shape and add the results in a <see cref="T:Quantum.Physics2D.HitCollection"/>.
            </summary>
            <param name="hits">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="transform">A 2D transform component pointer, with Position and Rotation info of the shape overlap.</param>
            <param name="hit">A 2D hit as reference to an entity that has shape and transform to be overlapped.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D*,Quantum.Transform2D*,Quantum.Physics2D.Hit*)">
            <summary>
            Checks if the shape of the hit overlaps another shape.
            </summary>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="transform">A 2D transform component pointer, with Position and Rotation info of the shape overlap.</param>
            <param name="hit">A 2D hit as reference to an entity that has shape and transform to be overlapped</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a box shape overlaps with another box shape.
            </summary>
            <param name="boxShapeA">The 2D box shape to be overlapped.</param>
            <param name="transformA">A 2D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="boxShapeB">The 2D box shape that will overlap.</param>
            <param name="transformB">A 2D transform component pointer, with Position and Rotation info of the box shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a circle shape overlaps with another circle shape.
            </summary>
            <param name="circleShapeA">The 2D circle shape to be overlapped.</param>
            <param name="circlePositionA">The position in which the circle shape is overlapped.</param>
            <param name="circleShapeB">The 2D  shape that will overlap.</param>
            <param name="circlePositionB">The position at which the circle shape will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a circle shape overlaps with a box shape.
            </summary>
            <param name="circleShape">The 2D circle shape to be overlapped.</param>
            <param name="circlePosition">The position in which the circle shape is overlapped.</param>
            <param name="boxShape">The 2D box shape that will overlap.</param>
            <param name="boxTransform">A 2D transform component pointer, with Position and Rotation info of the box shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a box shape overlaps with a circle shape.
            </summary>
            <param name="boxShape">The 2D box shape to be overlapped.</param>
            <param name="boxTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="circleShape">The 2D circle shape that will overlap.</param>
            <param name="circlePosition">The position at which the circle shape will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a box shape overlaps with edge box shape.
            </summary>
            <param name="boxShape">The 2D box shape to be overlapped.</param>
            <param name="boxTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="edgeShape">The 2D edge shape that will overlap.</param>
            <param name="edgeTransform">A 2D transform component pointer, with Position and Rotation info of the edge shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a edge shape overlaps with a box shape.
            </summary>
            <param name="edgeShape">The 2D edge shape to be overlapped.</param>
            <param name="edgeTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped edge shape.</param>
            <param name="boxShape">The 2D box shape that will overlap.</param>
            <param name="boxTransform">A 2D transform component pointer, with Position and Rotation info of the box shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a capsule shape overlaps with a box shape.
            </summary>
            <param name="capsuleShape">The 2D capsule shape to be overlapped.</param>
            <param name="capsuleTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="boxShape">The 2D box shape that will overlap.</param>
            <param name="boxTransform">A 2D transform component pointer, with Position and Rotation info of the box shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a box shape overlaps with a capsule shape.
            </summary>
            <param name="boxShape">The 2D box shape to be overlapped.</param>
            <param name="boxTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="capsuleShape">The 2D capsule shape that will overlap.</param>
            <param name="capsuleTransform">A 2D transform component pointer, with Position and Rotation info of the capsule shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a capsule shape overlaps with another capsule shape.
            </summary>
            <param name="capsuleShapeA">The 2D capsule shape to be overlapped.</param>
            <param name="capsuleTransformA">A 2D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="capsuleShapeB">The 2D capsule shape that will overlap.</param>
            <param name="capsuleTransformB">A 2D transform component pointer, with Position and Rotation info of the capsule shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a capsule shape overlaps with a circle shape.
            </summary>
            <param name="capsuleShape">The 2D capsule shape to be overlapped.</param>
            <param name="capsuleTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="circleShape">The 2D circle shape that will overlap.</param>
            <param name="circlePosition">The position at which the circle shape will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a circle shape overlaps with a capsule shape.
            </summary>
            <param name="circleShape">The 2D circle shape to be overlapped.</param>
            <param name="circlePosition">The position in which the circle shape is overlapped.</param>
            <param name="capsuleShape">The 2D capsule shape that will overlap.</param>
            <param name="capsuleTransform">A 2D transform component pointer, with Position and Rotation info of the capsule shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a capsule shape overlaps with a edge shape.
            </summary>
            <param name="capsuleShape">The 2D capsule shape to be overlapped.</param>
            <param name="capsuleTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="edgeShape">The 2D edge shape that will overlap.</param>
            <param name="edgeTransform">A 2D transform component pointer, with Position and Rotation info of the edge shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a edge shape overlaps with a capsule shape.
            </summary>
            <param name="edgeShape">The 2D edge shape to be overlapped.</param>
            <param name="edgeTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped edge shape.</param>
            <param name="capsuleShape">The 2D capsule shape that will overlap.</param>
            <param name="capsuleTransform">A 2D transform component pointer, with Position and Rotation info of the capsule shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a circle shape overlaps with a edge shape.
            </summary>
            <param name="circleShape">The 2D circle shape to be overlapped.</param>
            <param name="circlePosition">The position in which the circle shape is overlapped.</param>
            <param name="edgeShape">The 2D edge shape that will overlap.</param>
            <param name="edgeTransform">A 2D transform component pointer, with Position and Rotation info of the edge shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a edge shape overlaps with a circle shape.
            </summary>
            <param name="edgeShape">The 2D edge shape to be overlapped.</param>
            <param name="edgeTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped edge shape.</param>
            <param name="circleShape">The 2D circle shape that will overlap.</param>
            <param name="circlePosition">The position at which the circle shape will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a edge shape overlaps with another edge shape.
            </summary>
            <param name="edgeShapeA">The 2D edge shape to be overlapped.</param>
            <param name="edgeTransformA">A 2D transform component pointer, with Position and Rotation info of the overlapped edge shape.</param>
            <param name="edgeShapeB">The 2D edge shape that will overlap.</param>
            <param name="edgeTransformB">A 2D transform component pointer, with Position and Rotation info of the edge shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CapsuleShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a capsule shape overlaps with a polygon shape.
            </summary>
            <param name="capsuleShape">The 2D capsule shape to be overlapped.</param>
            <param name="capsuleTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="polygonShape">The 2D polygon shape that will overlap.</param>
            <param name="polygonTransform">A 2D transform component pointer, with Position and Rotation info of the polygon shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.CircleShape,Photon.Deterministic.FPVector2,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a circle shape overlaps with a polygon shape.
            </summary>
            <param name="circleShape">The 2D circle shape to be overlapped.</param>
            <param name="circlePosition">The position in which the circle shape is overlapped.</param>
            <param name="polygonShape">The 2D polygon shape that will overlap.</param>
            <param name="polygonTransform">A 2D transform component pointer, with Position and Rotation info of the polygon shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.BoxShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a box shape overlaps with a polygon shape.
            </summary>
            <param name="boxShape">The 2D box shape to be overlapped.</param>
            <param name="boxTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="polygonShape">The 2D polygon shape that will overlap.</param>
            <param name="polygonTransform">A 2D transform component pointer, with Position and Rotation info of the polygon shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.EdgeShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a edge shape overlaps with a polygon shape.
            </summary>
            <param name="edgeShape">The 2D edge shape to be overlapped.</param>
            <param name="edgeTransform">A 2D transform component pointer, with Position and Rotation info of the overlapped edge shape.</param>
            <param name="polygonShape">The 2D polygon shape that will overlap.</param>
            <param name="polygonTransform">A 2D transform component pointer, with Position and Rotation info of the polygon shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.CheckOverlap(Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Shape2D.PolygonShape,Quantum.Transform2D*,Quantum.Physics2D.CollisionResultInfo2D@)">
            <summary>
            Checks if a polygon shape overlaps with another polygon shape.
            </summary>
            <param name="polygonAssetA">The 2D polygon shape to be overlapped.</param>
            <param name="transformA">A 2D transform component pointer, with Position and Rotation info of the overlapped polygon shape.</param>
            <param name="polygonAssetB">The 2D polygon shape that will overlap.</param>
            <param name="transformB">A 2D transform component pointer, with Position and Rotation info of the polygon shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddRaycastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase raycast query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the ray <paramref name="origin"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddLinecastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase line cast query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the line <paramref name="start"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Raycast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast and returns the closest hit to the ray origin, if any.
            </summary>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the closest hit to the ray origin, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Raycast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast and adds the closest hit to the ray origin, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Linecast(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast and returns the closest hit to the line start, if any.
            </summary>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the closest hit to the line start, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.Linecast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast and adds the closest hit to the line start, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.RaycastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast, returning all hits.
            </summary>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.RaycastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a ray cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 2D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.LinecastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast, returning all hits.
            </summary>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.LinecastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a line cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 2D world space.</param>
            <param name="end">The line end point, in a 2D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase shape cast query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The cast start point, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="firstHitOnly">If the query results should return only the hit with the smallest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,Photon.Deterministic.FPVector2,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Boolean,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast and returns the hit with the shortest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any.
            </summary>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the smallest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCast(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast and adds the hit with the shortest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A nullable <see cref="T:Quantum.Physics2D.Hit"/> with the smallest <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>, if any.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast, returning all hits.
            </summary>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.ShapeCastAll(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D*,Photon.Deterministic.FPVector2,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 2D world space.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddOverlapShapeQuery(Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="transformVertical">A vertical transform component, with Vertical Position and Height info of the shape overlap on a 2.5D context.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            <remarks>When using a vertical transform, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddOverlapShapeQuery(Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.AddOverlapShapeQuery(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Adds a broad-phase shape overlap query to the 2D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="transformVertical">A vertical transform component, with Vertical Position and Height info of the shape overlap on a 2.5D context.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            <remarks>When using vertical transform, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Physics2D.HitCollection*,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics2D.HitCollection"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.AllocatePersistentHitCollection(System.Int32)"/>.</param>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Transform2D,Quantum.Transform2DVertical,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="transformVertical">A vertical transform component, with Vertical Position and Height info of the shape overlap on a 2.5D context.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>When using vertical transform, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Quantum.Transform2D,Quantum.Shape2D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="transform">A 2D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.OverlapShape(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Quantum.Shape2D,System.Int32,Quantum.QueryOptions,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene with a shape overlap.
            </summary>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The rotation of the shape, in radians.</param>
            <param name="shape">The 2D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <param name="verticalPosition">The position of the query on the vertical axis, on a 2.5D context.</param>
            <param name="verticalHeight">The height of the query from the vertical position on the positive sense of the vertical axis.</param>
            <returns>A temporary <see cref="T:Quantum.Physics2D.HitCollection"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            <remarks>If using vertical position and/or height, make sure "Use Vertical Transform" is set on the Simulation Config.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetStaticColliderEnabled(System.Int32,System.Boolean)">
            <summary>
            Set a toggleable 2D static collider enabled state to <paramref name="enabled"/>.
            Disabled static colliders are not considered for collisions or on query resolutions.
            <remarks>The static collider state is only changed on Verified frames.</remarks>
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders2D">StaticColliders2D</see> array.</param>
            <param name="enabled">If the static should be enabled (true) or disabled (false).</param>
            <exception cref="T:System.InvalidOperationException">If the static collider is baked as Immutable.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="M:Quantum.Physics2D.PhysicsEngine2D.Api.IsStaticColliderEnabled(System.Int32)">
            <summary>
            Returns the current state of a 2D static collider.
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders2D">StaticColliders2D</see> array.</param>
            <returns><see langword="false"/> if the static is not Immutable and is currently disabled, <see langword="true"/> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="T:Quantum.Physics2D.JointType">
            <summary>
            Defines the type of a 2D <see cref="T:Quantum.Physics2D.Joint"/>.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.JointType.None">
            <summary>
            Defines a Joint of no specific type, which are not solved by the Physics Engine.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.JointType.DistanceJoint">
            <summary>
            Defines the type of a <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.JointType.SpringJoint">
            <summary>
            Defines the type of a <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.JointType.HingeJoint">
            <summary>
            Defines the type of a <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.Joint">
            <summary>
            Defines a connection between a 2D Physics Body and an anchor, according to velocity and/or position constraints.
            The connected anchor can be a world-space position or another entity with at least a transform component. 
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.Joint.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.UserTag">
            <summary>
            A numerical tag that can be used to identify a joint or a group of joints.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.Anchor">
            <summary>
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.ConnectedAnchor">
            <summary>
            If the joint has a <see cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.ConnectedEntity">
            <summary>
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.SpringJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics2D.Joint.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.DistanceJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics2D.Joint.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Joint.HingeJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics2D.Joint.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Joint.Type">
            <summary>
            The type of this joint, indicating which type-specific settings should be accessed.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Joint.Enabled">
            <summary>
            If the constraints of this joint should be considered and resolved by the 2D Physics Engine. 
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.Joint.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics2D.Joint"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics2D.Joint"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics2D.Joint.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics2D.DistanceJoint">
            <summary>
            A <see cref="T:Quantum.Physics2D.Joint"/> that connects a Physics Body to an anchor and attempts to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.DistanceJoint.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.DistanceJoint.Anchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.Anchor"/>
            @copydoc Joint.Anchor
        </member>
        <member name="F:Quantum.Physics2D.DistanceJoint.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/>
            @copydoc Joint.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics2D.DistanceJoint.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>
            @copydoc Joint.ConnectedEntity
        </member>
        <member name="P:Quantum.Physics2D.DistanceJoint.MinDistance">
            <summary>
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics2D.DistanceJoint.MaxDistance"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.DistanceJoint.MaxDistance">
            <summary>
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics2D.DistanceJoint.MinDistance"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.DistanceJoint.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics2D.DistanceJoint"/> struct.
            Use <see cref="M:Quantum.Physics2D.DistanceJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/> instead to create a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.DistanceJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics2D.DistanceJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.
            </summary>
            <param name="minDistance">
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics2D.DistanceJoint.MaxDistance"/>.
            </param>
            <param name="maxDistance">
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics2D.DistanceJoint.MinDistance"/>.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.DistanceJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.DistanceJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.DistanceJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics2D.DistanceJoint.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics2D.DistanceJoint"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics2D.DistanceJoint"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics2D.DistanceJoint.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics2D.HingeJoint">
            <summary>
            A <see cref="T:Quantum.Physics2D.Joint"/> that attaches a Physics Body to an anchor around which it can rotate.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            The rotation can happen freely or, optionally, with limiting angles and/or a motor torque.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.Anchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.Anchor"/>
            @copydoc Joint.Anchor
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/>
            @copydoc Joint.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>
            @copydoc Joint.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.LowerLimitRad">
            <summary>
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.UpperLimitRad">
            <summary>
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.MotorSpeed">
            <summary>
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.HingeJoint.MaxMotorTorque">
            <summary>
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics2D.HingeJoint.MotorSpeed"/>.
            Set to <see cref="P:Photon.Deterministic.FP.UseableMax"/> in order to allow "unlimited" torque while respecting the FP usable range.
            Set <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.HingeJoint.UseAngleLimits">
            <summary>
            If the <see cref="F:Quantum.Physics2D.HingeJoint.LowerLimitRad"/> and <see cref="F:Quantum.Physics2D.HingeJoint.UpperLimitRad"/> limiting constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.HingeJoint.UseMotor">
            <summary>
            If the <see cref="F:Quantum.Physics2D.HingeJoint.MotorSpeed"/> and <see cref="F:Quantum.Physics2D.HingeJoint.MaxMotorTorque"/> constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.HingeJoint.#ctor(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics2D.HingeJoint"/> struct.
            Use <see cref="M:Quantum.Physics2D.HingeJoint.CreateJoint(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/> instead to create a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.HingeJoint.CreateJoint(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics2D.HingeJoint.CreateJoint(Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.
            </summary>
            <param name="lowerLimitRad">
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an upper limiting angle is set, the lower angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMin"/>.
            If both limiting angles are <see langword="null"/>, <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="upperLimitRad">
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an lower limiting angle is set, the upper angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both limiting angles are <see langword="null"/>, <see cref="P:Quantum.Physics2D.HingeJoint.UseAngleLimits"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="motorSpeed">
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            If none is provided, i.e. default(NullableFP), and a maximum motor toque is set, the target motor speed will be set to 0.
            If both motor speed and maximum torque are <see langword="null"/>, <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="maxMotorTorque">
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics2D.HingeJoint.MotorSpeed"/>.
            If none is provided, i.e. default(NullableFP), and a target motor speed is set, the maximum torque will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both motor speed and maximum torque are <see langword="null"/>, <see cref="P:Quantum.Physics2D.HingeJoint.UseMotor"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.HingeJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.HingeJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.HingeJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics2D.HingeJoint.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics2D.HingeJoint"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics2D.HingeJoint"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics2D.HingeJoint.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics2D.SpringJoint">
            <summary>
            A <see cref="T:Quantum.Physics2D.Joint"/> that attaches a Physics Body to an anchor as if connected by a spring, trying to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Anchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.Anchor"/>
            @copydoc Joint.Anchor
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedAnchor"/>
            @copydoc Joint.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics2D.Joint.ConnectedEntity"/>
            @copydoc Joint.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Spring">
            <summary>
            The stiffness of the spring, in Newtons per meter (N/m).
            To get or set the frequency (Hz) at which the spring will attempt to oscillate, given the physics body(ies) involved, use <see cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics2D.SpringJoint.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Damper">
            <summary>
            The damper capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            To get or set the damping RATIO, given the physics body(ies) involved, use <see cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics2D.SpringJoint.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.SpringJoint.Distance">
            <summary>
            The distance between the anchor points that the joint will attempt to maintain.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics2D.SpringJoint"/> struct.
            Use CreateJoint overloads instead to create a <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.SpringJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
            <param name="spring">
            The stiffness of the spring, in Newtons per meter (N/m).
            </param>
            <param name="damper">
            The damping capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.EntityRef,Quantum.PhysicsBody2D*,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a 2D <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.
            </summary>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the joint entity.
            The body mass affects the spring rate necessary to achieve the target oscillation frequency.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform2D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody2D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the <paramref name="connectedEntity"/>, if it exists and has one.
            Can be <see langword="null"/>, in which case the spring/damper rates will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics2D.SpringJoint.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics2D.Joint"/> of type <see cref="F:Quantum.Physics2D.JointType.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="frequency"/> and <paramref name="dampingRatio"/> based on the joint <see cref="F:Quantum.Physics2D.SpringJoint.Spring"/> and <see cref="F:Quantum.Physics2D.SpringJoint.Damper"/> capacities, given the physics body(ies) involved. 
            </summary>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the joint entity.
            The body mass affects the resultant oscillation frequency, given the joint spring stiffness.
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody2D"/> component of the entity connected to the joint, if it exists and has one.
            Can be <see langword="null"/>, in which case the frequency and damping ratio will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <exception cref="T:System.NullReferenceException">If the <paramref name="jointBody"/> is null.</exception>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*)">
            <summary>
            Computes and sets the <see cref="F:Quantum.Physics2D.SpringJoint.Spring"/> and <see cref="F:Quantum.Physics2D.SpringJoint.Damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="spring"/> and <paramref name="damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics2D.SpringJoint.GetStiffness(Quantum.PhysicsBody2D*,Quantum.PhysicsBody2D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics2D.SpringJoint"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics2D.SpringJoint"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics2D.SpringJoint.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics2D.CollisionResultInfo2D">
            <summary>
            A structure for containing all the result information from the collision between two shapes.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Physics2D.CollisionResultInfo2D.Penetration">
            <summary>
            The collision penetration in the <see cref="F:Quantum.Physics2D.CollisionResultInfo2D.Normal"/> direction.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.CollisionResultInfo2D.Normal">
            <summary>
            The contact normal.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.CollisionResultInfo2D.ContactPoints(Quantum.Physics2D.CollisionResultInfo2D*)">
            <summary>
            Gets a pointer to the contact points buffer. Use this pointer to get the other contact points in a for loop.
            </summary>
            <param name="CollisionResultInfo2D">The <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> reference.</param>
            <returns>A pointer to the beginning of the contact points vector buffer.</returns>
            <example>
            How to iterate over the contact points:
            <code>
            for (int i = 0; i &lt; result->ContactPointsCount; i++) {
                FPVector2 contactPoint = CollisionResultInfo2D.ContactPoints(result)[i];
            }
            </code>
            </example>
        </member>
        <member name="P:Quantum.Physics2D.CollisionResultInfo2D.ContactPointsCount">
            <summary>
            The number of found contact points.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.CollisionResultInfo2D.AddContactPoint(Quantum.Physics2D.CollisionResultInfo2D*,Photon.Deterministic.FPVector2)">
            <summary>
            Adds to the buffer of contact points a new contact point.
            For a 2D collision, the maximum number of contact point is <see cref="F:Quantum.Physics2D.CollisionManifold2D.MAX_CONTACT_POINTS"/>.
            </summary>
            <param name="result">The <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> reference.</param>
            <param name="cp">The contact point value.</param>
        </member>
        <member name="M:Quantum.Physics2D.CollisionResultInfo2D.GetPoint(Quantum.Physics2D.CollisionResultInfo2D*)">
            <summary>
            Gets the average point between all the contact points computed.
            </summary>
            <param name="result">The <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> reference.</param>
            <returns>The mid point of all contact points.</returns>
        </member>
        <member name="M:Quantum.Physics2D.CollisionResultInfo2D.UpdateHitWithResult(Quantum.Physics2D.CollisionResultInfo2D*,Quantum.Physics2D.Hit@)">
            <summary>
            Updates all the hit fields with the equivalent results of the collision.
            </summary>
            <param name="result">The <see cref="T:Quantum.Physics2D.CollisionResultInfo2D"/> reference.</param>
            <param name="hit">The <see cref="T:Quantum.Physics2D.Hit"/> reference.</param>
            <returns>A copy of the hit with the values updated.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Scene2D.Task_CreateEntriesMapping(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)">
            <summary>
            Creates a mapping from EntityRef to Entry (usable for Joints, for instance).
            Must run after <see cref="M:Quantum.Physics2D.Scene2D.Task_CreateEntries(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)"/> and in a single thread.
            </summary>
        </member>
        <member name="T:Quantum.Physics2D.Hit">
            <summary>
            Information returned from a valid hit of a physics query.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Physics2D.Hit.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.ShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> field of the shape hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.OverlapPenetration">
            <summary>
            The penetration of a shape overlap query on the collider that was hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options
            and only applies to Shape Overlap queries.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.CastDistanceNormalized">
            <summary>
            A normalized value (0 to 1) of the feature being casted when the hit occurs, relative to its full cast distance.
            <remarks>
            This field only applies to Ray, Line or Shape casts.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics2D.Hit.OverlapPenetration"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.Point">
            <summary>
            The point in world space where the collider is hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics2D.Hit.Normal">
            <summary>
            The surface normal of the hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.IsDynamic">
            <summary>
            If the collider hit by the query is not static, i.e. it belongs to an <see cref="P:Quantum.Physics2D.Hit.Entity"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.IsStatic">
            <summary>
            If the collider hit by the query is static.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.StaticColliderIndex">
            <summary>
            0-based index of the static collider on the <see cref="F:Quantum.Map.StaticColliders2D"/> array of the map referenced by <see cref="P:Quantum.Physics2D.Hit.StaticColliderMapRef"/>.
            If the hit <see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>, this value is -1.
            Tip: use <see cref="M:Quantum.Physics2D.Hit.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider2D@)"/>, <see cref="M:Quantum.Physics2D.Hit.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)"/>, <see cref="M:Quantum.Physics2D.Hit.GetStaticCollider(Quantum.Core.FrameBase)"/> or <see cref="M:Quantum.Physics2D.Hit.GetStaticData(Quantum.Core.FrameBase)"/>
            in order to safely and conveniently access info about a static collider hit.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.StaticColliderMapRef">
            <summary>
            The reference to the map used by the physics engine when a static collider is hit.
            Otherwise, this value is default (hit <see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>).
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.IsTrigger">
            <summary>
            If the collider hit by the query is Trigger.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.OffsetInCompound">
            <summary>
            The physics entry index from the entry touched by a the query.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.Hit.Entity">
            <summary>
            The reference of the entity hit by the query, <see cref="P:Quantum.EntityRef.None"/> if hitting a static collider (<see cref="P:Quantum.Physics2D.Hit.IsDynamic"/> <see langword="false"/>).
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetShape(Quantum.Core.FrameBase)">
            <summary>
            Gets the shape of the entity. If the entity is a compound, it returns the specific shape of the compound. 
            </summary>
            <param name="f">The frame.</param>
            <returns>The entity's <see cref="T:Quantum.Shape2D"/> pointer.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.TryGetShape(Quantum.Core.FrameBase,Quantum.Shape2D*@)">
            <summary>
            Checks if the hit is valid and outs the shape of the entity. Otherwise, it will return false. 
            If the entity is a compound, it returns the specific shape of the compound. 
            </summary>
            <param name="f">The frame.</param>
            <param name="shape">The shape pointer.</param>
            <returns>True if the hit is valid.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.SetHitEntity(Quantum.EntityRef)">
            <summary>
            Sets the entity that was hit. Automatically resets <see cref="P:Quantum.Physics2D.Hit.StaticColliderIndex"/> to -1.
            </summary>
            <param name="entity">The entity reference.</param>
        </member>
        <member name="M:Quantum.Physics2D.Hit.SetHitStaticCollider(System.Int32,Quantum.AssetRef{Quantum.Map})">
            <summary>
            Sets the index of the static collider hit on the <see cref="F:Quantum.Map.StaticColliders2D"/> array of the referenced map.
            </summary>
            <param name="staticColliderIndex">A valid index of the static collider on the array of the map.</param>
            <param name="mapRef">A reference to the map where the static collider hit is located.</param>
        </member>
        <member name="M:Quantum.Physics2D.Hit.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider2D@)">
            <summary>
            Tries to access the static collider that was hit.
            </summary>
            <param name="f">Current frame.</param>
            <param name="collider">A copy of the static collider data found. Default if the metadata is not valid (returns <see langword="false"/>).</param>
            <returns><see langword="false"/> if the collider hit is not static or the collide index or referenced map are not valid. <see langword="true"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.TryGetStaticCollider(Quantum.FrameThreadSafe,Quantum.MapStaticCollider2D@)">
            <inheritdoc cref="M:Quantum.Physics2D.Hit.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider2D@)"/>
        </member>
        <member name="M:Quantum.Physics2D.Hit.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)">
            <summary>
            Tries to access the data of the static collider that was hit (<see cref="F:Quantum.MapStaticCollider2D.StaticData"/>).
            </summary>
            <param name="f">Current frame.</param>
            <param name="data">A copy of the static collider data found. Default if the metadata is not valid (returns <see langword="false"/>).</param>
            <returns><see langword="false"/> if the collider hit is not static or the collide index or referenced map are not valid. <see langword="true"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.TryGetStaticData(Quantum.FrameThreadSafe,Quantum.StaticColliderData@)">
            <inheritdoc cref="M:Quantum.Physics2D.Hit.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)"/>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetStaticCollider(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the static collider hit. Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics2D.Hit.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetStaticCollider(Quantum.FrameThreadSafe)">
            <inheritdoc cref="M:Quantum.Physics2D.Hit.GetStaticCollider(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetStaticData(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the data of the static collider hit (<see cref="F:Quantum.MapStaticCollider2D.StaticData"/>). Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics2D.Hit.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics2D.Hit.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetStaticData(Quantum.FrameThreadSafe)">
            <inheritdoc cref="M:Quantum.Physics2D.Hit.GetStaticData(Quantum.Core.FrameBase)"/>
        </member>
        <member name="M:Quantum.Physics2D.Hit.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics2D.Hit"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics2D.Hit"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics2D.Hit.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics2D.HitCollection">
            <summary>
            Collection of hits returned from a physics query.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.Physics2D.HitCollection.Count">
            <summary>
            The amount of hits in the collection.
            </summary>
        </member>
        <member name="P:Quantum.Physics2D.HitCollection.Item(System.Int32)">
            <summary>
            Returns a <see cref="T:Quantum.Physics2D.Hit"/> in collection by the <paramref name="index"/>.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">When the specified index is out of the collection boundaries.</exception>
        </member>
        <member name="P:Quantum.Physics2D.HitCollection.HitsBuffer">
            <summary>
            Returns the <see cref="T:Quantum.Physics2D.Hit"/> pointer to the buffer of hits. 
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.ToArray">
            <summary>
            Converts the hit collection to a managed array of hits. 
            </summary>
            <returns>An array of hits.</returns>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.Sort(Photon.Deterministic.FPVector2)">
            <summary>
            Sort all hits in the collection, in ascending order, based on the distance from the <see cref="F:Quantum.Physics2D.Hit.Point"/> to the target <paramref name="point"/>.
            <remarks>
            Queries must have the <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> option set in order to compute hit Points and Cast Distance.
            Include this flag if intending to sort the query results.
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.SortCastDistance">
            <summary>
            Sort all hits in the collection, in ascending order, based on the <see cref="F:Quantum.Physics2D.Hit.CastDistanceNormalized"/>.
            <remarks>
            Queries must have the <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> option set in order to compute hit Points and Cast Distance.
            Include this flag if intending to sort the query results.
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.Free(Photon.Deterministic.Native.Allocator)">
            <summary>
            Frees the values and resets the hit collection metadata.
            </summary>
            <param name="allocator">The native memory allocator.</param>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.Reset">
            <summary>
            Resets the <see cref="T:Quantum.Physics2D.HitCollection"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.Add(Quantum.Physics2D.Hit,Quantum.Core.FrameContext)">
            <summary>
            Adds a hit to the list collection.
            </summary>
            <param name="hit">The <see cref="T:Quantum.Physics2D.Hit"/> instance to be added to the collection.</param>
            <param name="context">The <see cref="T:Quantum.Core.FrameContext"/>.</param>
        </member>
        <member name="M:Quantum.Physics2D.HitCollection.ExpandCapacity(System.Int32,Quantum.Core.FrameContext)">
            <summary>
            Expands the hit collection capacity.
            </summary>
            <param name="newCapacity">The amount of new capacity.</param>
            <param name="context">The <see cref="T:Quantum.Core.FrameContext"/>.</param>
        </member>
        <member name="T:Quantum.PolygonColliderRuntimeData">
            <summary>
            The buffers with runtime data for the vertices and normals. They are loaded when the asset is added or replaced.
            </summary>
        </member>
        <member name="P:Quantum.PolygonColliderRuntimeData.IsValid">
            <summary>
            Checks if the vertices and normal buffers are valid for usage. 
            </summary>
        </member>
        <member name="F:Quantum.PolygonColliderRuntimeData.VerticesBuffer">
            <summary>
            The pointer to the vertices' runtime data.
            </summary>
        </member>
        <member name="F:Quantum.PolygonColliderRuntimeData.NormalsBuffer">
            <summary>
            The pointer to the normals' runtime data.
            </summary>
        </member>
        <member name="M:Quantum.PolygonColliderRuntimeData.#ctor(Photon.Deterministic.FPVector2*,Photon.Deterministic.FPVector2*)">
            <summary>
            Sets the pointers to the runtime data of the polygon.
            </summary>
            <param name="verticesBuffer">The pointer to the vertices' runtime data.</param>
            <param name="normalsBuffer">The pointer to the normals' runtime data.</param>
        </member>
        <member name="M:Quantum.PolygonColliderRuntimeData.Create(Photon.Deterministic.FPVector2[],Photon.Deterministic.FPVector2[],Photon.Deterministic.Native.Allocator)">
            <summary>
            Initializes the polygon runtime data into creating a buffer for the <paramref name="vertices"/> and <paramref name="normals"/>.
            </summary>
            <param name="vertices">The managed array of vertices that define the polygon collider</param>
            <param name="normals">The managed array of the normals of all polygon sides</param>
            <param name="allocator">The allocator to use for managing memory.</param>
            <returns>Returns a struct with the buffers for the runtime data of a polygon.</returns>
        </member>
        <member name="M:Quantum.PolygonColliderRuntimeData.Free(Photon.Deterministic.Native.Allocator)">
            <summary>
            Frees the runtime data in the memory of a polygon's vertices and normal buffers. 
            </summary>
            <param name="allocator">The allocator to use for managing memory.</param>
            <returns></returns>
        </member>
        <member name="T:Quantum.IKCCCallbacks2D">
            <summary>
            The interface receives the interaction callbacks from the character controller system. 
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.IKCCCallbacks2D.OnCharacterCollision2D(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics2D.Hit)">
            <summary>
            Allows to receive a <paramref name="hit"/> as result of the collision with other colliders.
            </summary>
            <param name="frame">The current frame.</param>
            <param name="character">The entity of the character.</param>
            <param name="hit">The <see cref="T:Quantum.Physics2D.Hit"/> with the collision info.</param>
            <returns>True if the collision should be considered. False otherwise.</returns>
        </member>
        <member name="M:Quantum.IKCCCallbacks2D.OnCharacterTrigger2D(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics2D.Hit)">
            <summary>
            Allows to receive a <paramref name="hit"/> as result of the collision with other trigger colliders.
            </summary>
            <returns></returns>
            <inheritdoc cref="M:Quantum.IKCCCallbacks2D.OnCharacterCollision2D(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics2D.Hit)"/>
        </member>
        <member name="T:Quantum.CharacterController2DMovement">
            <summary>
            Result of a 2D KCC raw movement query.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Type">
            <summary>
            Recommended type of movement based on found collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.NearestNormal">
            <summary>
            Surface normal of the nearest collision.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.AvgNormal">
            <summary>
            Average normal of all collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.GroundNormal">
            <summary>
            Surface normal of the closest collision that qualifies as ground, if any.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Tangent">
            <summary>
            Surface tangent (recommended movement direction) in case there's a desired direction passed.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.SlopeTangent">
            <summary>
            Surface tangent (recommended movement direction) in case of a slope (based on gravity).
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Correction">
            <summary>
            Full correction vector to move out of collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Penetration">
            <summary>
            Magnitude of the penetration over the nearest normal.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Grounded">
            <summary>
            <see langword="true"/> if at least one collision (not necessarily closest) qualifies as ground.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2DMovement.Contacts">
            <summary>
            Total number of collisions found in this execution of the movement query.
            </summary>
        </member>
        <member name="T:Quantum.CharacterController2D">
            <summary>
            A component for kinematic character controller prototyping that uses a circle as a shape.
            You can quickly add this to an entity and set a <see cref="T:Quantum.CharacterController2DConfig"/>, then call the <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/> method in a system update.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.CharacterController2D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2D.BroadPhaseQuery">
            <summary>
            Broad-Phase Query index of the last query added by calling <see cref="M:Quantum.CharacterController2D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})"/>.
            To use Broad-Phase queries, call <see cref="M:Quantum.CharacterController2D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})"/> before the Physics system Update runs.
            When Move() is called and a broad-phase query has been added, the method will not perform a new query,
            but retrieve and use the results of the broad-phase query previously injected.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2D.MaxSpeed">
            <summary>
            The character's maximum horizontal speed will be clamped by this value.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController2D.Velocity">
            <summary>
            The current accumulated velocity of the character controller.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2D.Config">
            <summary>
            Returns the <see cref="T:Quantum.CharacterController2DConfig">Character Controller</see> config asset.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2D.Grounded">
            <summary>
            Returns true if the character controller is touching the floor.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2D.Jumped">
            <summary>
            If the character jumped this frame. See <see cref="M:Quantum.CharacterController2D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})"/>.
            <remarks>This state is consumed in the default steering method <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CharacterController2D.BroadPhaseQueryIndex">
            <summary>
            Obsolete. Use <see cref="F:Quantum.CharacterController2D.BroadPhaseQuery"/> instead.
            </summary>
        </member>
        <member name="M:Quantum.CharacterController2D.Init(Quantum.Core.FrameBase,Quantum.CharacterController2DConfig)">
            <summary>
            Initializes the 2D character controller component.
            <remarks>
            Use <see cref="M:Quantum.CharacterController2D.SetConfig(Quantum.Core.FrameBase,Quantum.CharacterController2DConfig)">SetConfig</see> instead
            in order to set or change the KCC config without resetting other fields.
            This method is not thread-safe: use the thread-safe overload if calling from a multi-threaded context.
            </remarks>
            </summary>
            <param name="frame">The current Frame.</param>
            <param name="config">
            The KCC <see cref="T:Quantum.CharacterController2DConfig"/> asset.
            If none is provided, the default config asset is used.
            </param>
        </member>
        <member name="M:Quantum.CharacterController2D.Init(Quantum.FrameThreadSafe,Quantum.CharacterController2DConfig)">
            <inheritdoc cref="M:Quantum.CharacterController2D.Init(Quantum.Core.FrameBase,Quantum.CharacterController2DConfig)"/>
        </member>
        <member name="M:Quantum.CharacterController2D.SetConfig(Quantum.Core.FrameBase,Quantum.CharacterController2DConfig)">
            <summary>
            Sets or changes this KCC's config.
            <remarks>
            This method does not reset other values like <see cref="P:Quantum.CharacterController2D.Grounded"/> and <see cref="F:Quantum.CharacterController2D.Velocity"/>:
            use <see cref="M:Quantum.CharacterController2D.Init(Quantum.Core.FrameBase,Quantum.CharacterController2DConfig)">Init</see> for that.
            This method is not thread-safe: use the thread-safe overload if calling from a threaded context.
            </remarks>
            </summary>
            <param name="frame">The current Frame.</param>
            <param name="config">
            The KCC <see cref="T:Quantum.CharacterController2DConfig"/> asset.
            If none is provided, the default config asset is used.
            </param>
        </member>
        <member name="M:Quantum.CharacterController2D.SetConfig(Quantum.FrameThreadSafe,Quantum.CharacterController2DConfig)">
            <inheritdoc cref="M:Quantum.CharacterController2D.SetConfig(Quantum.Core.FrameBase,Quantum.CharacterController2DConfig)"/>
        </member>
        <member name="M:Quantum.CharacterController2D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Applies a vertical impulse to the KCC velocity.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>No steering is performed at this stage. To actually move the character, use <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            <param name="frame">The frame object.</param>
            <param name="ignoreGrounded">If the <see cref="P:Quantum.CharacterController2D.Grounded"/> state of the KCC should be ignored.</param>
            <param name="impulse">The amount of impulse applied to the KCC. If none is provided, the <see cref="F:Quantum.CharacterController2DConfig.BaseJumpImpulse"/> of the KCC config is used.</param>
        </member>
        <member name="M:Quantum.CharacterController2D.Jump(Quantum.FrameThreadSafe,System.Boolean,System.Nullable{Photon.Deterministic.FP})">
            <inheritdoc cref="M:Quantum.CharacterController2D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})"/>
        </member>
        <member name="M:Quantum.CharacterController2D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})">
            <summary>
            Adds a Broad-phase query to the 2D Physics scene, according to the KCC config settings, and store the query ref in <see cref="F:Quantum.CharacterController2D.BroadPhaseQuery"/>.
            This ref will be used on the next time Move or ComputeRawMovement is called to retrieve the resolved query results and perform the KCC logic.
            </summary>
            <remarks>
            The added BP-Query must be retrieve on the same frame. To cancel the addition of a BP-Query and perform a regular one when moving the KCC, set <see cref="F:Quantum.CharacterController2D.BroadPhaseQuery"/> to default. 
            </remarks>
            <param name="frame">The current frame object.</param>
            <param name="entity">
            The entity that represents the character. It must have a <see cref="T:Quantum.Transform2D"/> component, which will be used to compute the query position,
            along with a <see cref="T:Quantum.Transform2DVertical"/> (optional), if the entity has one.
            </param>
            <param name="layerMask">A mask that specifies which layers should be considered by the query. If <see langword="null"/> (default), the layer maks defined in the KCC config will be used.</param>
            <returns>The index of the added query.</returns>
        </member>
        <member name="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Queries the 2D physics scene with <see cref="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform2D*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},Photon.Deterministic.FP,Photon.Deterministic.FP)"/>, computes a default steering in the desired <paramref name="direction"/> and moves the <paramref name="entity"/>.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>The entity must have a Transform2D component.</remarks>
            <param name="frame">The frame in which the entity is being moved.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks. If calling from a system that implements the interface, you can use the "this" keyword.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If <see langword="null"/> is passed, the layer maks defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If <see langword="false"/>, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController2DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <param name="deltaTime">The delta timed used to integrate the kcc velocity. If no value is provided, the <paramref name="frame"/> delta time is used.</param>
        </member>
        <member name="M:Quantum.CharacterController2D.Move(Quantum.FrameThreadSafe,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})">
            <inheritdoc cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>
        </member>
        <member name="M:Quantum.CharacterController2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.CharacterController2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="p">The pointer to the <see cref="T:Quantum.CharacterController2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform2D*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Queries the 2D physics scene in the <paramref name="transform"/> position, using the <paramref name="kcc"/> config, and computes movement data.
            The movement data can be used to apply a custom steering to the character based on its surrounding environment.
            For using the default steering, use <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <param name="frame">The frame in which the physics scene is being queried.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="transform">A pointer to a Transform2D component that has the position where the scene will be queried at, usually being the <paramref name="entity"/> transform.</param>
            <param name="kcc">A pointer to a CharacterController2D component that has the config used by the query, usually being the <paramref name="entity"/> kcc component.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks.
            <remarks>If calling from a system that implements the interface, you can use the "this" keyword.</remarks>
            </param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If <see langword="null"/> is passed, the layer mask defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If <see langword="false"/>, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController2DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <param name="verticalPosition">The 2.5D vertical position where the 2D KCC query will be performed.</param>
            <param name="verticalHeight">The 2.5D vertical height with which the 2D KCC query will be performed.</param>
            <returns>A <see cref="T:Quantum.CharacterController2DMovement"/> struct with raw movement data that can be used to compute a custom steering.</returns>
        </member>
        <member name="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform2D*,Quantum.Transform2DVertical*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <summary>
            Queries the 2D physics scene in the <paramref name="transform"/> position, using the <paramref name="kcc"/> config, and computes movement data.
            The movement data can be used to apply a custom steering to the character based on its surrounding environment.
            For using the default steering, use <see cref="M:Quantum.CharacterController2D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.
            </summary>
            <param name="frame">The frame in which the physics scene is being queried.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="transform">A pointer to a Transform2D component that has the position where the scene will be queried at, usually being the <paramref name="entity"/> transform.</param>
            <param name="tVertical">A pointer to a Transform2DVertical that has the position where the scene will be queried at, usually being the <paramref name="entity"/> transform.</param>
            <param name="kcc">A pointer to a CharacterController2D component that has the config used by the query, usually being the <paramref name="entity"/> kcc component.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks.</param>
            <param name="layerMask">>A mask that specifies which layers will be checked against in the raw movement computation.
            If <see langword="null"/> is passed, the layer mask defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If <see langword="false"/>, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController2DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <returns>A <see cref="T:Quantum.CharacterController2DMovement"/> struct with raw movement data that can be used to compute a custom steering.</returns>
        </member>
        <member name="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.FrameThreadSafe,Quantum.EntityRef,Quantum.Transform2D*,Quantum.Transform2DVertical*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <inheritdoc cref="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform2D*,Quantum.Transform2DVertical*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean})"/>
        </member>
        <member name="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.FrameThreadSafe,Quantum.EntityRef,Quantum.Transform2D*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.CharacterController2D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform2D*,Quantum.CharacterController2D*,Photon.Deterministic.FPVector2,Quantum.IKCCCallbacks2D,System.Nullable{System.Int32},System.Nullable{System.Boolean},Photon.Deterministic.FP,Photon.Deterministic.FP)"/>
        </member>
        <member name="T:Quantum.PhysicsBody2D">
            <summary>
            Adds physics motion to an entity with a <see cref="T:Quantum.PhysicsCollider2D"/> driven by the built-in physics systems. 
            You can customize how the movement of the physics body will works by changing the <see cref="P:Quantum.PhysicsBody2D.Mass"/>, <see cref="P:Quantum.PhysicsBody2D.GravityScale"/> or <see cref="P:Quantum.PhysicsBody2D.Drag"/>.
            A <see cref="P:Quantum.PhysicsBody2D.IsKinematic">Kinematic</see> body will not have linear and angular velocities integrated, but those values are still perceived and taken into
            account when resolving the collision with other dynamic bodies.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.PhysicsBody2D.ConfigFlags">
            <summary>
            The flags to set up how the physics body will behave in the physics systems.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.Default">
            <summary>IsAllowedToSleep | IsAwakenedByForces | ResetInertiaOnAdded | ResetCenterOfMassOnAdded</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.IsKinematic">
            <summary>Prevents linear and angular velocities from being integrated.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.FreezeRotation">
            <summary>Prevents the physics update to apply changes to the rotation.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.IsAllowedToSleep">
            <summary>Allows the physics body to sleep after some time at rest.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.IsAwakenedByForces">
            <summary>Allows sleeping physic bodies to be awakened by dynamic interactions.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.IsAwakenedByKinematics">
            <summary>Allows sleeping physic bodies to be awakened by kinematic interaction.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.ResetInertiaOnAdded">
            <summary>Allows the physics body to compute the inertia automatically when it is added to an entity.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.ResetCenterOfMassOnAdded">
            <summary>Resets the <see cref="F:Quantum.PhysicsBody2D.CenterOfMass"/> to the shape <see cref="F:Quantum.Shape2D.Centroid"/> when the physics body is added to an entity.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.ConfigFlags.UseContinuousCollisionDetection">
            <summary>Prevents the physics body from passing through other objects when at high velocity.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.AngularVelocity">
            <summary>
            The rate of change of physics rotation in radians per second.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.Velocity">
            <summary>
            The rate of change of physics body position in units per second. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsBody2D.CenterOfMass">
            <summary>
            The center of mass position relative to the transform's origin.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.Force">
            <summary>
            The accumulated forces by the <see cref="M:Quantum.PhysicsBody2D.AddForce(Photon.Deterministic.FPVector2,System.Nullable{Photon.Deterministic.FPVector2})"/> method that will be integrated into delta velocity on the next Physics Update.
            This value is reset after the integration.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.Torque">
            <summary>
            The accumulated torques by the <see cref="M:Quantum.PhysicsBody2D.AddTorque(Photon.Deterministic.FP)"/> method that will be integrated into delta angular velocity on the next Physics Update.
            This value is reset after the integration.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.Enabled">
            <summary>
            If this physics body component should be taken into consideration by the physics engine.
            If false, the entity will have as if not having a physics body component.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.AllowSleeping">
            <summary>
            Allows the physics body to sleep after some time at rest. When sleeping, it will not integrate the velocity until other forces awaken it.
            See <see cref="T:Quantum.PhysicsSceneSettings"/> to setup the time to sleep and the tolerances for linear and angular velocity. 
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.IsAwakenedByKinematics">
            <summary>
            Allows sleeping physic bodies to be awakened when interacting with other colliders or kinematic bodies.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.IsSleeping">
            <summary>
            Returns true if the object is sleeping. 
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.Drag">
            <summary>
            The rate of linear velocity that the physics body will lose per second. The higher the drag, the faster the object slows down.
            Drag affects velocity every frame according to the following pseudo-code:
            <code>
            Velocity *= FP._1 - Drag * deltaTime;
            </code>
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.AngularDrag">
            <summary>
            The rate of angular velocity that the physics body will lose per second. The higher the drag, the faster the object slows down.
            Angular Drag affects angular velocity every frame according to the following pseudo-code:
            <code>
            AngularVelocity *= FP._1 - AngularDrag * deltaTime;
            </code>
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.FreezeRotation">
            <summary>
            Prevents the physics update to apply changes to the rotation of the physics body. 
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.UseContinuousCollisionDetection">
            <summary>
            Prevents the physics body from passing through other objects when at high velocity.
            <remarks>
            The Continuous Collision Detection uses the GJK algorithm to check the distance between the objects. 
            See <see cref="T:Quantum.CCDSettings"/> to update the settings and improve the collision detection or performance. 
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.Mass">
            <summary>
            The value of the body mass property. If zero, the physics body becomes kinematic body.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.MassInverse">
            <summary>
            The inverse value of the body mass property (1/mass).
            The inverse mass value is what is stored internally on the component, so accessing or
            modifying this value directly instead of through the regular <see cref="P:Quantum.PhysicsBody2D.Mass"/> can
            prevent inaccuracies from being introduced in the conversion of values.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.GravityScale">
            <summary>
            The multiplier for the gravity force applied at this physics body. 
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.InertiaScale">
            <summary>
            A multiplier for the body inertia tensor.
            When setting a value, the inertia tensor is immediately updated. 
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody2D.IsKinematic">
            <summary>
            Prevents the physics update integrating the linear and angular velocities of this physics body.
            Other non-kinematic body in contact with this physics body will still take those velocities into consideration.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody2D.GetInertia">
            <summary>
            Gets the physics body inertia, the resistance to changes in angular velocity.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody2D.GetInertiaInverse">
            <summary>
            Returns the inverse form of the inertia tensor, as it is stored internally.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.PhysicsBody2D.SetInertia(Photon.Deterministic.FP,Photon.Deterministic.NullableFP)">
            <summary>
            Sets the inertia tensor value. The greater the value of inertia, the more torque will be required to achieve the
            same delta angular velocity. This value is automatically recomputed when the value of mass is set.
            </summary>
            <param name="inertia">The inertia tensor value. This value is scaled by the <see cref="P:Quantum.PhysicsBody2D.InertiaScale"/>
            or by <paramref name="resetInertiaScale"/> if provided and its inverse value is stored on the component.
            </param>
            <param name="resetInertiaScale">
            If specified, resets the body <see cref="P:Quantum.PhysicsBody2D.InertiaScale"/> and immediately applies the new scale to the
            provided <paramref name="inertia"/>.
            </param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.CreateDynamic(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,System.Boolean,System.Boolean,System.Boolean,System.Nullable{Photon.Deterministic.FPVector2},Photon.Deterministic.NullableFP)">
            <summary>
            Creates a dynamic <see cref="T:Quantum.PhysicsBody2D"/>.
            </summary>
            <param name="mass">The mass of the physics body.</param>
            <param name="drag">The drag of the physics body.</param>
            <param name="angularDrag">The angular drag of the physics body.</param>
            <param name="allowSleeping">Allows the physics body to sleep.</param>
            <param name="awakenByKinematics">Allows the physics body to be awaken by an interaction with kinematic bodies.</param>
            <param name="freezeRotation">Freezes rotation of the physics body.</param>
            <param name="centerOfMass">The center of mass position relative to the transform's origin.</param>
            <param name="gravityScale">The multiplier for the gravity force applied for this physics body.</param>
            <returns>A <see cref="T:Quantum.PhysicsBody2D"/> component.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.PhysicsBody2D.CreateDynamic(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D.ConfigFlags,System.Nullable{Photon.Deterministic.FPVector2},Photon.Deterministic.NullableFP)">
            <inheritdoc cref="M:Quantum.PhysicsBody2D.CreateDynamic(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,System.Boolean,System.Boolean,System.Boolean,System.Nullable{Photon.Deterministic.FPVector2},Photon.Deterministic.NullableFP)"/>
        </member>
        <member name="M:Quantum.PhysicsBody2D.CreateKinematic">
            <summary>
            Creates a kinematic <see cref="T:Quantum.PhysicsBody2D"/>. The mass, drag and angular drag are not considered in kinematic interactions and have 0 as value.
            </summary>
            <returns>A <see cref="T:Quantum.PhysicsBody2D"/> component.</returns>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.PhysicsBody2D.InitBody(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody2D.ConfigFlags,System.Nullable{Photon.Deterministic.FPVector2},Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP)">
            <summary>
            Initializes a <see cref="T:Quantum.PhysicsBody2D"/> component with custom settings.
            </summary>
            <param name="bodyMass">The mass of the physics body.</param>
            <param name="drag">The drag of the physics body.</param>
            <param name="angularDrag">The angular drag of the physics body.</param>
            <param name="bodyConfig">The <see cref="T:Quantum.PhysicsBody2D.ConfigFlags"/> used in the physics body.</param>
            <param name="centerOfMass">The center of mass position relative to the transform's origin.</param>
            <param name="gravityScale">The multiplier for the gravity force applied for this physics body.</param>
            <param name="inertiaScale">A multiplier for the inertia tensor value.</param>
            <param name="inertia">
            An optional value for the body's inertia tensor.
            If not specified AND the <see cref="F:Quantum.PhysicsBody2D.ConfigFlags.ResetInertiaOnAdded"/> is set in the <paramref name="bodyConfig"/>,
            then the inertia tensor will be computed when the body component is added to an entity, based on the shape of the
            collider, assuming uniform mass distribution.
            </param>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.PhysicsBody2D.ResetInertia(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the inertia on this physics body component based on its mass and the shape of a
            <see cref="T:Quantum.PhysicsCollider2D"/> component on the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody2D"/> component is added to an entity, unless the body <see cref="F:Quantum.PhysicsBody2D.ConfigFlags.ResetInertiaOnAdded"/> flag is not set.
            The body's center of mass affects the computation of the inertia, so consider calling
            <see cref="M:Quantum.PhysicsBody2D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)"/> before resetting the inertia, specially if the collider shape has changed.
            More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="frame">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider shape will be retrieved, necessary for computing the inertia.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the <see cref="F:Quantum.PhysicsBody2D.CenterOfMass"/> of physics body component to the shape <see cref="F:Quantum.Shape2D.Centroid"/>
            of a <see cref="T:Quantum.PhysicsCollider2D"/> component attached to the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody2D"/> component is added to an entity,
            unless the body <see cref="F:Quantum.PhysicsBody2D.ConfigFlags.ResetCenterOfMassOnAdded"/> flag is not set.
            When changing the collider shape in runtime, consider resetting the center of mass and inertia of the attached physics body,
            in this order. More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="f">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider component and shape will be retrieved.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddLinearImpulse(Photon.Deterministic.FPVector2,System.Nullable{Photon.Deterministic.FPVector2})">
            <summary>
            Applies the given <paramref name="amount"/> of linear impulse to the body.
            The amount of delta-velocity generated by the impulse is inversely proportional to the mass of the body.
            If the impulse is applied in a <paramref name="relativePoint"/> that is different than zero, it will also generate a delta angular velocity.
            </summary>
            <param name="amount">The impulse vector to be applied.</param>
            <param name="relativePoint">A vector in world space that represents the distance from the center of mass to the point where the impulse is being applied.</param>
            <seealso cref="M:Quantum.PhysicsBody2D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.Transform2D)"/>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.Transform2D)">
            <inheritdoc cref="M:Quantum.PhysicsBody2D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.Transform2D*)"/>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.Transform2D*)">
            <summary>
            Applies the given linear <paramref name="impulse"/> to the body at a given <paramref name="position"/> in world space.
            </summary>
            <param name="impulse">The impulse vector to be applied.</param>
            <param name="position">
            The point in world space where the impulse is being applied.
            This position should be withing the collider shape in order to prevent unrealistic behavior.
            </param>
            <param name="transform">The current transform of the entity that owns this physics body.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddAngularImpulse(Photon.Deterministic.FP)">
            <summary>
            Applies the given <paramref name="amount"/> of angular impulse to the body.
            The amount of delta angular velocity generated by the angular impulse is inversely proportional to the inertia of the body.
            </summary>
            <param name="amount">The angular impulse to be applied.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.ClearForce">
            <summary>
            Clears all the accumulated forces in this body.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddForce(Photon.Deterministic.FPVector2,System.Nullable{Photon.Deterministic.FPVector2})">
            <summary>
            Increases the <see cref="P:Quantum.PhysicsBody2D.Force"/> value with the <paramref name="amount"/> vector.
            The force is integrated into delta velocity on the next Physics Update. The amount of delta-velocity produced
            by the accumulated force is directly proportional do the delta-time and inversely proportional do the Mass of the body.
            If the impulse is applied at a <paramref name="relativePoint"/> that is different than zero, it will also generate <see cref="P:Quantum.PhysicsBody2D.Torque"/>.
            </summary>
            <param name="amount">The force vector in world coordinates.</param>
            <param name="relativePoint">A vector in world space that represents the distance from the center of mass to the point where the impulse is being applied.</param>
            <seealso cref="M:Quantum.PhysicsBody2D.AddTorque(Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddForceAtPosition(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.Transform2D)">
            <inheritdoc cref="M:Quantum.PhysicsBody2D.AddForceAtPosition(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.Transform2D*)"/>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddForceAtPosition(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Quantum.Transform2D*)">
            <summary>
            Applies the given <paramref name="force"/> to the body at a given <paramref name="position"/> in world space.
            </summary>
            <param name="force">The force vector to be applied.</param>
            <param name="position">
            The point in world space where the impulse is being applied.
            This position should be withing the collider shape in order to prevent unrealistic behavior.
            </param>
            <param name="transform">The current transform of the entity that owns this physics body.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.ClearTorque">
            <summary>
            Clears all the accumulated torques in this body.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody2D.AddTorque(Photon.Deterministic.FP)">
            <summary>
            Accumulates a given <paramref name="amount"/> of torque, to be integrated into angular velocity on the next Physics Update.
            The amount of delta angular velocity produced by the angular impulse is directly proportional to the Update delta-time and
            inversely proportional to the body inertia on each axis.
            </summary>
            <param name="amount">The torque to be accumulated.</param>
        </member>
        <member name="M:Quantum.PhysicsBody2D.GetPointVelocity(Photon.Deterministic.FPVector2,Quantum.Transform2D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined in world space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in world space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 2D vector representing the computed velocity, also in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody2D.GetRelativePointVelocity(Photon.Deterministic.FPVector2,Quantum.Transform2D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined on its local space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in local space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 2D vector representing the computed velocity, in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody2D.WakeUp">
            <summary>
            Wakes up a sleeping physics body and resets the accumulated time within sleeping thresholds.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody2D.Sleep">
            <summary>
            Puts an enabled physics body into a sleeping state.
            <remarks>
            If set during a physics collision callback, the body might be awakened by the solver if the collision is not ignored.  
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsBody2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsBody2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsCallbacks2D">
            <summary>
            A component that tracks the collisions (trigger and non-trigger) this entity is involved in.
            The tracked metadata is used to raise physics callbacks according to the callback <see cref="F:Quantum.PhysicsCallbacks2D.Flags"/> set.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.PhysicsCallbacks2D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCallbacks2D.Flags">
            <summary>
            Represents which collision callbacks will be called for the entity. See <see cref="T:Quantum.CallbackFlags"/> for more information.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsCallbacks2D.IsCollidingWith(Quantum.Core.FrameBase,Quantum.EntityRef,System.Int32@)">
            <summary>
            Checks if a collision between the entity owner of this component and another <paramref name="entity"/>
            is already being tracked.
            </summary>
            <param name="f">The frame.</param>
            <param name="entity">The other entity reference.</param>
            <param name="index">The index of the <see cref="T:Quantum.PhysicsCommon.CollisionCallbackInfo"/> in the list. -1 if the collision is not yet being tracked.</param>
            <returns>Returns true if it find the entity in the <see cref="T:Quantum.PhysicsCommon.CollisionCallbackInfo"/> list.</returns>
        </member>
        <member name="M:Quantum.PhysicsCallbacks2D.IsCollidingWith(Quantum.Core.FrameBase,Quantum.AssetGuid,System.Int32,System.Int32@)">
            <summary>
            Checks if a collision between the entity owner of this component and a given static collider is already being tracked.
            </summary>
            <param name="f">The frame.</param>
            <param name="mapGuid">The map guid of a scene.</param>
            <param name="staticColliderId">The static collier id to find.</param>
            <param name="index">The index of the <see cref="T:Quantum.PhysicsCommon.CollisionCallbackInfo"/> of the list. -1 if the collision is not yet being tracked.</param>
            <returns>Returns true if it find the index in the <see cref="T:Quantum.PhysicsCommon.CollisionCallbackInfo"/> list.</returns>
        </member>
        <member name="M:Quantum.PhysicsCallbacks2D.AddCollision(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Adds a collision with an <paramref name="entity"/> to the collisions tracked by this component. 
            </summary>
            <param name="f">The frame.</param>
            <param name="entity">The Entity to add to the tracking list.</param>
        </member>
        <member name="M:Quantum.PhysicsCallbacks2D.AddCollision(Quantum.Core.FrameBase,Quantum.AssetGuid,System.Int32,System.Boolean)">
            <summary>
            Adds a collision with a static collider to the collisions tracked by this component
            using the <paramref name="staticColliderId"/> as reference.
            </summary>
            <param name="f">The frame.</param>
            <param name="mapGuid">The map guid of a scene.</param>
            <param name="staticColliderId">The static collier id.</param>
            <param name="isTrigger">If the collider is trigger.</param>
        </member>
        <member name="P:Quantum.PhysicsCallbacks2D.ListCount">
            <summary>
            The number of collisions currently being tracked.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCallbacks2D.ListBufferPtr">
            <summary>
            The pointer to the list of metadata of collisions being tracked.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsCallbacks2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsCallbacks2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsCallbacks2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.StaticColliderData">
            <summary>
            Information about a static collider.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Name">
            <summary>
            The name of the static baked into the map asset. By default is the name of the GameObject that has the static collider component.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Tag">
            <summary>
            The tag of the static baked into the map asset. By default is the tag of the GameObject that has the static collider component.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Layer">
            <summary>
            The layer of the static baked into the map asset. By default is the layer of the GameObject that has the static collider component.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.Asset">
            <summary>
            A reference to an asset that can be linked to the static collider. By default, no asset is linked to the collider.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.IsTrigger">
            <summary>
            If the static collider is trigger.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.ColliderIndex">
            <summary>
            0-based index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders2D"/> or <see cref="F:Quantum.Map.StaticColliders3D"/> array.
            </summary>
        </member>
        <member name="F:Quantum.StaticColliderData.MutableMode">
            <summary>
            If the static collider can be enabled/disabled in runtime and, if so, its starting state. 
            </summary>
        </member>
        <member name="T:Quantum.PhysicsCollider2D">
            <summary>
            A component with a shape used to represent 2D physics objects in the physics simulation. 
            You can use <see cref="T:Quantum.PhysicsCollider2D.Flags">flags</see> and <see cref="P:Quantum.PhysicsCollider2D.Layer">layers</see> to setup how the object interacts with other colliders.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.PhysicsCollider2D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCollider2D.Shape">
            <summary>
            The <see cref="T:Quantum.Shape2D"/> used by the collider.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCollider2D.Layer">
            <summary>
            The index of the layer this collider belongs to.
            <remarks>
            The collision matrix between layers can be configured in the Simulation Config.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCollider2D.IsTrigger">
            <summary>
            If the collider is trigger.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCollider2D.Material">
            <summary>
            The asset reference of the physics material used by this collider. See <see cref="T:Quantum.PhysicsMaterial"/> for more details.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCollider2D.Enabled">
            <summary>
            If this component should be considered by the Physics Engine.
            <remarks>
            Disabling a collider has immediate effect: queries will not find it, nor will collisions be solved nor callbacks called.
            If a collider is re-enabled after the Physics system has already run on this frame, the collider will be re-enabled on the next frame.
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.PhysicsCollider2D.Create(Quantum.Core.FrameBase,Quantum.Shape2D,Quantum.PhysicsMaterial,System.Boolean,System.Int32)">
            <summary>
            Creates a physics collider component with a <see cref="T:Quantum.Shape2D"/>.
            </summary>
            <param name="f">The frame.</param>
            <param name="shape">
            The shape to be used by this collider. If the provided shape is a <see cref="T:Quantum.Shape2D.CompoundShape2D"/>, this
            collider will create a deep, persistent copy of the provided compound, which will be disposed automatically when
            this component is removed from an entity.
            </param>
            <param name="material">The physics material asset object. If null, it will use the default physics material.</param>
            <param name="isTrigger">If the collider is trigger. False by default.</param>
            <param name="layer">The index of the layer the collider belongs to.</param>
            <returns>An instance of physics collider component.</returns>
        </member>
        <member name="M:Quantum.PhysicsCollider2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsCollider2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsCollider2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsJoints2D">
            <summary>
            A component holding one or more <see cref="T:Quantum.Physics2D.Joint"/>,
            defining connections between a 2D Physics Body and anchors according to velocity and/or position constraints.
            </summary>
            \ingroup PhysicsJoints2D
        </member>
        <member name="P:Quantum.PhysicsJoints2D.Count">
            <summary>
            The current amount of joints tracked by the component.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.Capacity">
            <summary>
            The number of joints the currently allocated buffer can hold before having to be resized.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@)">
            <summary>
            Adds a <see cref="T:Quantum.Physics2D.Joint"/> to the component.
            If the buffer is at full <see cref="P:Quantum.PhysicsJoints2D.Capacity"/>, a new buffer will be allocated with double the capacity and existing entries are copied over.
            In that case, the previous buffer is not disposed immediately and cached pointers are still valid, although outdated.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joint">The joint that will be added to the component.</param>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.RemoveJoints(Quantum.Core.FrameBase,System.Nullable{System.Int32})">
            <summary>
            Removes all joints in the component that have a <see cref="F:Quantum.Physics2D.Joint.UserTag"/> field matching the specified <paramref name="userTag"/>.
            If none is specified, all joints are removed.
            </summary>
            <remarks>
            This method does not keep the order of remaining elements in the buffer.
            To achieve that instead, use <see cref="M:Quantum.PhysicsJoints2D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints2D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> while iterating the buffer in reverse order.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="userTag">
            A numerical tag that can be used to identify a joint or a group of joints.
            Any joint in the component that matches the tag will be removed.
            If none is specified, all joints are removed.
            </param>
            <returns><see langword="true"/> if at least one joint has been removed.</returns>
            <code>
            const int removeJointsUserTag = 42;
            
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            if (removeAll) {
              jointsComponent->RemoveJoints(f);
            } else {
              jointsComponent->RemoveJoints(f, removeJointsUserTag);
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.RemoveAt(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer, while keeping the order of the remaining objects.
            If the remaining elements do not need to be kept in order, <see cref="M:Quantum.PhysicsJoints2D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)"/> is a cheaper option.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics2D.JointType.DistanceJoint) {
                  // removes the element at the current index, keeping the order of the remaining ones
                  jointsComponent->RemoveAt(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer.
            The order of the elements with indices greater than <paramref name="index"/> is not kept.
            If the order must be kept, use <see cref="M:Quantum.PhysicsJoints2D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> instead.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics2D.JointType.DistanceJoint) {
                  // removes the element at the current index
                  // the order of the elements with index greater than i is not ensured
                  jointsComponent->RemoveAtUnordered(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics2D.Joint*@,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints, if it has one.
            See also <see cref="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joints">The allocated buffer for the component joints. <see langword="null"/> if the buffer is not allocated.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called. 0 if the buffer is not allocated.</param>
            <returns><see langword="true"/> if the buffer is allocated.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              for (var i = 0; i &lt; count; i++) {
                var current = joints + i;
                Log.Info($"Joint Type {i}: {current->Type}");
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.GetJoints(Quantum.Core.FrameBase,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints.
            See also <see cref="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called.</param>
            <returns>The allocated buffer for the component joints.</returns>
            <exception cref="T:System.NullReferenceException">If the buffer is not allocated.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            var joints = jointsComponent->GetJoints(f, out var count);
            
            for (var i = 0; i &lt; count; i++) {
              var current = joints + i;
              Log.Info($"Joint Type {i}: {current->Type}");
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsJoints2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsJoints2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsJoints2D.JointsIterator">
            <summary>
            An auxiliary struct to iterate over the joints on a <see cref="T:Quantum.PhysicsJoints2D"/> component.
            Use <see cref="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to acquire an iterator for the component's joint buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints2D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = <see langword="true"/>;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics2D.JointType.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
            \ingroup PhysicsJoints2D
        </member>
        <member name="M:Quantum.PhysicsJoints2D.JointsIterator.GetEnumerator">
            <summary>
            The iterator is also an enumerator.
            This method is useful for accessing the elements in a foreach loop, for instance.
            </summary>
            <returns>A copy of this iterator on its current state.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.JointsIterator.MoveNext">
            <summary>
            Moves to the next joint.
            </summary>
            <returns><see langword="true"/> if there is a next element.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.JointsIterator.Reset">
            <summary>
            Resets the iterator to its original state.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.JointsIterator.CurrentUnsafe">
            <summary>
            A pointer to the current joint being iterated.
            This allows modifications to the element in the actual buffer of joints.
            </summary>
            <exception cref="T:System.NullReferenceException">If the iterator buffer is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the iterator current index is outside the valid range of the buffer: [0, count).</exception>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.JointsIterator.Current">
            <summary>
            A copy of the current joint being iterated.
            To modify the actual element in the buffer, use <see cref="P:Quantum.PhysicsJoints2D.JointsIterator.CurrentUnsafe"/> instead.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints2D.JointsIterator.CurrentIndex">
            <summary>
            The index on the buffer of the element currently being iterated.
            The index is out of the valid range if the iterator has just been created on <see cref="M:Quantum.PhysicsJoints2D.JointsIterator.Reset"/>.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints2D.GetIterator(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Gets an auxiliary struct to iterate over the joints in this component.
            See also <see cref="M:Quantum.PhysicsJoints2D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics2D.Joint*@,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints2D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> to have direct access to the buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints2D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics2D.Joint@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="reverseOrder">
            If the buffer elements should be iterated in reverse order.
            If <see langword="true"/>, allows the removal of elements while iterating without it causing some elements to be skipped.
            </param>
            <returns>A <see cref="T:Quantum.PhysicsJoints2D.JointsIterator"/> for the buffer of joints in this component.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints2D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = <see langword="true"/>;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics2D.JointType.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
        </member>
        <member name="T:Quantum.ExitInfo2D">
            <summary>
            Info about two entities that were colliding in the 2D Physics.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo2D"/> for 2D collisions and <see cref="T:Quantum.TriggerInfo2D"/> for 2D trigger collisions.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.ExitInfo2D.Entity">
            <summary>
            The main entity that was involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo2D.Other">
            <summary>
            The other entity that was involved in the collision if the <see cref="P:Quantum.ExitInfo2D.Entity"/> was NOT colliding with a static (check <see cref="P:Quantum.ExitInfo2D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.ExitInfo2D.Entity"/> was colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo2D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.ExitInfo2D.Entity"/> was touching a static collider.
            If so, <see cref="P:Quantum.ExitInfo2D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.ExitInfo2D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.ExitInfo2D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.ExitInfo2D.Entity"/> was colliding with a static (check <see cref="P:Quantum.ExitInfo2D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.CollisionInfo2D">
            <summary>
            Info about a collision between two 2D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo3D"/> for 3D collisions and <see cref="T:Quantum.TriggerInfo2D"/> for 2D trigger collisions.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.CollisionInfo2D.ContactPointIterator2D">
            <summary>
            A helper for safety interaction through the contact point buffer.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactPointIterator2D.Count">
            <summary>
            The number of contact points on this collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactPointIterator2D.Average">
            <summary>
            The average contact point on this collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactPointIterator2D.First">
            <summary>
            The first contact point computed on this collision.
            <remarks>Contact points are computed in NO particular order.</remarks>
            </summary>
        </member>
        <member name="M:Quantum.CollisionInfo2D.ContactPointIterator2D.Next(Photon.Deterministic.FPVector2@)">
            <summary>
            Iterates through the contact points of a collision.
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <returns><see langword="true"/> if there is still a <paramref name="contactPoint"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var cp) {
              Draw.Circle(cp, FP._0_10);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo2D.ContactPointIterator2D.Next(Photon.Deterministic.FPVector2@,Photon.Deterministic.FPVector2@)">
            <summary>
            Iterates through the contact points of a collision, also accessing the contact normal.
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <param name="contactNormal">The contact normal. Default if the iteration is over.</param>
            <returns><see langword="true"/> if there is still a <paramref name="contactPoint"/> and <paramref name="contactNormal"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var contactPoint, out var contactNormal) {
               Draw.Circle(contactPoint, FP._0_10);
               Draw.Ray(contactPoint, contactNormal);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo2D.ContactPointIterator2D.ResetIterator">
            <summary>
            Resets the iterator.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.IgnoreCollision">
            <summary>
            If the collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="F:Quantum.CollisionInfo2D.ContactPoints">
            <summary>
            Data about the contact points of the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.ContactNormal">
            <summary>
            The contact normal, from the <see cref="P:Quantum.CollisionInfo2D.Entity"/> perspective.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.Penetration">
            <summary>
            The collision penetration in the <see cref="P:Quantum.CollisionInfo2D.ContactNormal"/> direction.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is touching a static collider.
            If so, <see cref="P:Quantum.CollisionInfo2D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.CollisionInfo2D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.CollisionInfo2D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.CollisionInfo2D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.CollisionInfo2D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.CollisionInfo2D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo2D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.CollisionInfo2D.Entity"/> is colliding with a static (check <see cref="P:Quantum.CollisionInfo2D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.Shape2D">
            <summary>
            Defines a 2D shape with <see cref="P:Quantum.Shape2D.Type"/> and data disposed in a union-like structure.
            All shapes have a <see cref="F:Quantum.Shape2D.UserTag"/>, <see cref="F:Quantum.Shape2D.BroadRadius"/> and <see cref="F:Quantum.Shape2D.Centroid"/>.
            All non-compound shapes have a <see cref="F:Quantum.Shape2D.LocalTransform"/> and their <see cref="F:Quantum.Shape2D.Centroid"/> always match their local transform position.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.Shape2D.CompoundShape2D">
            <summary>
            A 2D shape type that can reference a group of other 2D shapes (including other compounds).
            Compound shape overlaps and physics colliders with compound shapes are supported.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.CompoundShape2D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.CompoundShape2D.IsPersistent">
            <summary>
            If the buffer of shapes is persistently allocated.
            </summary>
            <remarks>Persistently allocated memory is not disposed automatically. Call <see cref="M:Quantum.Shape2D.CompoundShape2D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)"/> when done using a persistent compound.</remarks>
        </member>
        <member name="P:Quantum.Shape2D.CompoundShape2D.Count">
            <summary>
            The number of shapes in the compound buffer.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.CompoundShape2D.Capacity">
            <summary>
            The current number of shapes that can be held by the compound buffer.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.CopyFrom(Quantum.Core.FrameBase,Quantum.Shape2D@)">
            <summary>
            Creates a copy of another compound <paramref name="shape"/>'s and any nested compound's buffers.
            The resultant shapes will not share data.
            </summary>
            <remarks>Any existing persistent compounds in this shape's hierarchy are disposed before copying.</remarks>
            <param name="f">The current frame being simulated.</param>
            <param name="shape">The compound shape that will be copied from.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.AddShape(Quantum.Core.FrameBase,Quantum.Shape2D@,System.Boolean)">
            <summary>
            Adds the <paramref name="shape"/> to the compound buffer.
            </summary>
            <remarks>Trying to add a compound shape that holds a buffer already reference in this shape's hierarchy will throw an error in debug mode.</remarks>
            <param name="f">The frame currently being simulated.</param>
            <param name="shape">The shape being added to the compound.</param>
            <param name="updateCompoundMeta">If the compound meta data (e.g. broad radius and centroid) should be automatically updated.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.RemoveShapes(Quantum.Core.FrameBase,System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Removes all shapes in a compound that have a <see cref="F:Quantum.Shape2D.UserTag"/> field matching the specified <paramref name="userTag"/>.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="userTag">
            A tag that specifies a shape or group of shapes.
            Any shape in a compound that has a matching <see cref="F:Quantum.Shape2D.UserTag"/> field will be removed.
            If none is specified, all shapes are removed.
            </param>
            <param name="resetCompoundMeta">If the compound meta data (e.g. broad radius, centroid) should be automatically reset if any shapes are removed.</param>
            <param name="removeFromNested">If shapes should also be removed from any compound shape nested inside this.</param>
            <returns><see langword="true"/> if at least one shape has been removed by this method.</returns>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.GetShapes(Quantum.Core.FrameBase,Quantum.Shape2D*@,System.Int32@)">
            <summary>
            Gets a pointer to the buffer of shapes added to this compound.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="shapesBuffer">A pointer to the buffer of shapes added to this compound. <see langword="null"/> if the compound doesn't have shapes.</param>
            <param name="count">The number of shapes in the <paramref name="shapesBuffer"/>.</param>
            <returns><see langword="true"/> if the buffer has at least one shape</returns>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.ResetCompoundMeta(Quantum.Core.FrameBase)">
            <summary>
            Recomputes the compound shape broad radius, centroid and area sum (the later is used internally).
            </summary>
            <param name="f">The frame currently being simulated.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Dispose any persistently allocated memory for this compound shape.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="freeNestedPersistent">If nested compound shapes should also have persistent buffers disposed.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.ReserveCapacity(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Ensures that this compound shape capacity can hold at least <paramref name="capacity"/> shapes.
            </summary>
            <param name="f">The current Frame instance</param>
            <param name="capacity">The desired capacity. The resultant capacity can be greater than or equal this value.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.AssertExistingReference(Quantum.Core.FrameBase,Quantum.Ptr)">
            <summary>
            Returns <see langword="true"/> if this compound shape doesn't already reference the <paramref name="ptr"/> in it's hierarchy. 
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape2D.CompoundShape2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape2D.CompoundShape2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Shape2D.CompoundShape2D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape2D.CircleShape">
            <summary>
            Defines a 2D circle in its local space.
            In order to create a <see cref="T:Quantum.Shape2D"/> of type <see cref="F:Quantum.Shape2DType.Circle"/>, use <see cref="M:Quantum.Shape2D.CreateCircle(Photon.Deterministic.FP,Photon.Deterministic.FPVector2)"/>. 
            <seealso cref="T:Quantum.Shape2D"/>
            <seealso cref="T:Quantum.Shape2DType"/>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Shape2D.CircleShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.CircleShape.Radius">
            <summary>
            Value of the radius that defines the circle.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.CircleShape.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape2D.CircleShape"/> into an instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape2D.CircleShape"/>.</param>
            <param name="serializer">The instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.</param>
        </member>
        <member name="M:Quantum.Shape2D.CircleShape.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape2D.PolygonShape">
            <summary>
            References a Polygin shape by the <see cref="T:Quantum.AssetRef`1"/> of its <see cref="T:Quantum.PolygonCollider"/> asset.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Shape2D.PolygonShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.PolygonShape.AssetRef">
            <summary>
            Returns a <see cref="T:Quantum.PolygonCollider"/> asset reference.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.PolygonShape.BroadRadius">
            <summary>
            The smallest radius of a circle centered at the polygon <see cref="P:Quantum.Shape2D.PolygonShape.Centroid"/> that encloses the polygon. 
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.PolygonShape.Centroid">
            <summary>
            The point representing the geometric center of a shape or object.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.PolygonShape.SetPolygonCollider(Quantum.PolygonCollider)">
            <summary>
            Sets a polygon collider meta data to <see cref="T:Quantum.Shape2D.PolygonShape"/>
            </summary>
            <param name="collider"></param>
        </member>
        <member name="M:Quantum.Shape2D.PolygonShape.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape2D.PolygonShape"/> into an instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape2D.PolygonShape"/>.</param>
            <param name="serializer">The instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.</param>
        </member>
        <member name="M:Quantum.Shape2D.PolygonShape.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape2D.BoxShape">
            <summary>
            Defines a 2D box in its local space.
            In order to create a <see cref="T:Quantum.Shape2D"/> of type <see cref="F:Quantum.Shape2DType.Box"/>, use <see cref="M:Quantum.Shape2D.CreateBox(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)"/>. 
            <seealso cref="T:Quantum.Shape2D"/>
            <seealso cref="T:Quantum.Shape2DType"/>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Shape2D.BoxShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.BoxShape.BroadRadius">
            <summary>
            The smallest radius of a circle centered at the box centroid that encloses the box. 
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.BoxShape.Extents">
            <summary>
            Vector that defines the distance from the box centroid to the furthest point in the
            positive direction of each axis.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.BoxShape.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape2D.BoxShape"/> into an instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape2D.BoxShape"/>.</param>
            <param name="serializer">The instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.</param>
        </member>
        <member name="M:Quantum.Shape2D.BoxShape.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape2D.EdgeShape">
            <summary>
            Defines a 2D edge in its local space.
            In order to create a <see cref="T:Quantum.Shape2D"/> of type <see cref="F:Quantum.Shape2DType.Edge"/>, use <see cref="M:Quantum.Shape2D.CreateEdge(Photon.Deterministic.FP,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)"/>. 
            <seealso cref="T:Quantum.Shape2D"/>
            <seealso cref="T:Quantum.Shape2DType"/>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Shape2D.EdgeShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.EdgeShape.Extent">
            <summary>
            Defines the distance from the edge centroid to the furthest point in either direction of its elongated axis.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.EdgeShape.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape2D.EdgeShape"/> into an instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape2D.EdgeShape"/>.</param>
            <param name="serializer">The instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.</param>
        </member>
        <member name="M:Quantum.Shape2D.EdgeShape.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape2D.CapsuleShape">
            <summary>
            Defines a 2D capsule in its local space.
            In order to create a <see cref="T:Quantum.Shape2D"/> of type <see cref="F:Quantum.Shape2DType.Capsule"/>, use <see cref="M:Quantum.Shape2D.CreateCapsule(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)"/>. 
            <seealso cref="T:Quantum.Shape2D"/>
            <seealso cref="T:Quantum.Shape2DType"/>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Shape2D.CapsuleShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.CapsuleShape.Radius">
            <summary>
            The radius of the capsule's top and bottom semi-spheres.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.CapsuleShape.Extent">
            <summary>
            The distance from the capsule's centroid to the center of the top or bottom semi-sphere.
            <seealso cref="P:Quantum.Shape2D.CapsuleShape.Height"/> 
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.CapsuleShape.Diameter">
            <summary>
            Twice the value of the capsule <see cref="F:Quantum.Shape2D.CapsuleShape.Radius"/>.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.CapsuleShape.Height">
            <summary>
            The distance from the bottommost to the topmost points in the capsule along its elongated axis.
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.CapsuleShape.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape2D.CapsuleShape"/> into an instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape2D.CapsuleShape"/>.</param>
            <param name="serializer">The instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.</param>
        </member>
        <member name="M:Quantum.Shape2D.CapsuleShape.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="F:Quantum.Shape2D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.UserTag">
            <summary>
            Set a number tag to identify a shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.LocalTransform">
            <summary>
            The offset position and rotation of the shape related to the entity's transform.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.Centroid">
            <summary>
            The offset position of the shape center related to the entity's position.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.Compound">
            <summary>
            The <see cref="T:Quantum.Shape2D.CompoundShape2D"/> in the shape if it's <see cref="T:Quantum.Shape2DType">type</see> of compound.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.BroadRadius">
            <summary>
            The radius of an abstract circle that rounds the shape. Used to check the possibility of collision.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.Circle">
            <summary>
            The <see cref="T:Quantum.Shape2D.CircleShape"/> in the shape if it's <see cref="T:Quantum.Shape2DType">type</see> of circle.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.Box">
            <summary>
            The <see cref="T:Quantum.Shape2D.BoxShape"/> in the shape if it's <see cref="T:Quantum.Shape2DType">type</see> of box.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.Polygon">
            <summary>
            The <see cref="T:Quantum.Shape2D.PolygonShape"/> in the shape if it's <see cref="T:Quantum.Shape2DType">type</see> of polygon.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.Edge">
            <summary>
            The <see cref="T:Quantum.Shape2D.EdgeShape"/> in the shape if it's <see cref="T:Quantum.Shape2DType">type</see> of edge.
            </summary>
        </member>
        <member name="F:Quantum.Shape2D.Capsule">
            <summary>
            The <see cref="T:Quantum.Shape2D.CapsuleShape"/> in the shape if it's <see cref="T:Quantum.Shape2DType">type</see> of capsule.
            </summary>
        </member>
        <member name="P:Quantum.Shape2D.Type">
            <summary>
            Returns the <see cref="T:Quantum.Shape2DType">type</see> of the shape. 
            </summary>
        </member>
        <member name="M:Quantum.Shape2D.CreateCircle(Photon.Deterministic.FP,Photon.Deterministic.FPVector2)">
            <summary>
            Creates a 2D circle shape.
            </summary>
            <param name="radius">The radius of the circle</param>
            <param name="posOffset">The offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <returns>A <see cref="T:Quantum.Shape2D"/> with the setup and type of a <see cref="T:Quantum.Shape2D.CircleShape"/>.</returns>
        </member>
        <member name="M:Quantum.Shape2D.CreatePolygon(Quantum.PolygonCollider,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Creates a 2D polygon shape using a polygon collider <paramref name="asset"/>.
            </summary>
            <param name="asset">The asset the defines the polygon</param>
            <param name="posOffset">The position offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <param name="rotOffset">The rotation offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <returns>A <see cref="T:Quantum.Shape2D"/> with the setup and type of a <see cref="T:Quantum.Shape2D.PolygonShape"/>.</returns>
        </member>
        <member name="M:Quantum.Shape2D.CreatePolygon(Quantum.MapStaticCollider2DPolygonData,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <inheritdoc cref="M:Quantum.Shape2D.CreatePolygon(Quantum.PolygonCollider,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Shape2D.CreateBox(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Creates a 2D box shape defined by <paramref name="extents"/>.
            </summary>
            <param name="extents">
            The box extents, a vector that defines the distance from the box centroid to the furthest point in the
            positive direction of each axis.
            </param>
            <param name="posOffset">The position offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <param name="rotOffset">The rotation offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <returns>A <see cref="T:Quantum.Shape2D"/> with the setup and type of a <see cref="T:Quantum.Shape2D.BoxShape"/>.</returns>
        </member>
        <member name="M:Quantum.Shape2D.CreateEdge(Photon.Deterministic.FP,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Creates a 2D edge shape defined by an <paramref name="extent"/>.
            </summary>
            <param name="extent">
            The edge extent, a value that defines the distance from the edge centroid to the furthest point in either
            direction of its elongated axis.
            </param>
            <param name="posOffset">The position offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <param name="rotOffset">The rotation offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <returns>A <see cref="T:Quantum.Shape2D"/> with the setup and type of an <see cref="T:Quantum.Shape2D.EdgeShape"/>.</returns>
        </member>
        <member name="M:Quantum.Shape2D.CreateCapsule(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Creates a 2D capsule shape defined by a <paramref name="radius"/> and an <paramref name="extent"/>.
            <remarks>
            The 'extent' of the capsule is defined as the distance from the center of the shape to the center of any semi-sphere. 
            </remarks>
            </summary>
            <param name="radius">The radius of the capsule's top and bottom semi-spheres.</param>
            <param name="extent">The distance from the capsule's centroid to the center of the top or bottom semi-sphere.</param>
            <param name="posOffset">The position offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <param name="rotOffset">The rotation offset of the shape in the <see cref="F:Quantum.Shape2D.LocalTransform"/>.</param>
            <returns>A <see cref="T:Quantum.Shape2D"/> with the setup and type of an <see cref="T:Quantum.Shape2D.CapsuleShape"/>.</returns>
        </member>
        <member name="M:Quantum.Shape2D.CreatePersistentCompound">
            <summary>
            Creates a compound shape that composed by a group of other 2D shapes (including other compounds).
            </summary>
            <returns>A <see cref="T:Quantum.Shape2D"/> with the setup and type of an <see cref="T:Quantum.Shape2D.CompoundShape2D"/>.</returns>
        </member>
        <member name="M:Quantum.Shape2D.GetLocalSupport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2,System.Boolean)">
            <summary>
            Computes a point on the shape which has the highest dot product in a given direction (<paramref name="localDir"/>),
            both in the local space of the shape.
            </summary>
            <param name="f">Current frame.</param>
            <param name="localDir">The direction, in local space, in which to compute the support point.</param>
            <param name="skipNormalize">If the provided direction is already normalized.</param>
            <returns>A point, in the local space of the shape, which has the highest dot product in the given direction.</returns>
        </member>
        <member name="M:Quantum.Shape2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Shape2D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape2DConfig">
            <summary>
            The base settings for building a <see cref="T:Quantum.Shape2D"/>.
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Shape2DConfig.ShapeType">
            <summary>
            The <see cref="T:Quantum.Shape2DType">type</see> of the shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.PolygonCollider">
            <summary>
            The asset reference to a <see cref="T:Quantum.PolygonCollider"/>.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.CircleRadius">
            <summary>
            The radius of the circle.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.CapsuleSize">
            <summary>
            The capsule size is a vector two. The x-axis is the diameter of the capsule and the y-axis is the size of the capsule from the top end to the bottom end. 
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.EdgeExtent">
            <summary>
            The length of the edge from the center to the right or left end.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.BoxExtents">
            <summary>
            The vector that represents the extents of the box in each axis. 
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.PositionOffset">
            <summary>
            The position offset of the shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.RotationOffset">
            <summary>
            The rotation offset of the shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.UserTag">
            <summary>
            The user tag to identify the compound shape during the collision event.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.IsPersistent">
            <summary>
            This flag means the buffer of shapes is allocated in the memory. It will be free when the component is removed from the entity.
            <remarks>Only persistent compound shapes are supported on the editor.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapes">
            <summary>
            The configuration array of each shape in the compound that will be allocated. 
            </summary>
        </member>
        <member name="P:Quantum.Shape2DConfig.CapsuleRadius">
            <summary>
            The capsule radius is half the size of the capsule size on the X-Axis.
            </summary>
        </member>
        <member name="P:Quantum.Shape2DConfig.CapsuleExtent">
            <summary>
            The capsule extent is the distance from the center of the capsule to some of the spheres' centers.
            </summary>
        </member>
        <member name="M:Quantum.Shape2DConfig.CreateShape(Quantum.Core.FrameBase)">
            <summary>
            Creates a <see cref="T:Quantum.Shape2D"/> using the all the data set in the <see cref="T:Quantum.Shape2DConfig"/>.
            </summary>
            <param name="f">The current frame.</param>
        </member>
        <member name="T:Quantum.Shape2DConfig.CompoundShapeData2D">
            <summary>
            The settings of each shape in the compound of shapes list. 
            </summary>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.ShapeType">
            <inheritdoc cref="F:Quantum.Shape2DConfig.ShapeType"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.PolygonCollider">
            <inheritdoc cref="F:Quantum.Shape2DConfig.PolygonCollider"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.CircleRadius">
            <inheritdoc cref="F:Quantum.Shape2DConfig.CircleRadius"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.CapsuleSize">
            <inheritdoc cref="F:Quantum.Shape2DConfig.CapsuleSize"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.EdgeExtent">
            <inheritdoc cref="F:Quantum.Shape2DConfig.EdgeExtent"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.BoxExtents">
            <inheritdoc cref="F:Quantum.Shape2DConfig.BoxExtents"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.PositionOffset">
            <inheritdoc cref="F:Quantum.Shape2DConfig.PositionOffset"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.RotationOffset">
            <inheritdoc cref="F:Quantum.Shape2DConfig.RotationOffset"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.UserTag">
            <inheritdoc cref="F:Quantum.Shape2DConfig.UserTag"/>
        </member>
        <member name="P:Quantum.Shape2DConfig.CompoundShapeData2D.CapsuleRadius">
            <inheritdoc cref="P:Quantum.Shape2DConfig.CapsuleRadius"/>
        </member>
        <member name="P:Quantum.Shape2DConfig.CompoundShapeData2D.CapsuleExtent">
            <inheritdoc cref="P:Quantum.Shape2DConfig.CapsuleExtent"/>
        </member>
        <member name="F:Quantum.Shape2DConfig.CompoundShapeData2D.IsSetFromSourceCollider">
            <summary>
            This means an external collider component from this engine sets this component.
            </summary>
        </member>
        <member name="M:Quantum.Shape2DConfig.CompoundShapeData2D.#ctor(Quantum.Shape2DConfig)">
            <summary>
            Constructor that initializes the instance with the values from a <see cref="T:Quantum.Shape2DConfig"/>.
            </summary>
            <param name="fromConfig">Shape config used as source</param>
        </member>
        <member name="M:Quantum.Shape2DConfig.CompoundShapeData2D.CopyToConfig(Quantum.Shape2DConfig)">
            <summary>
            Copies the current instance's values to a <see cref="T:Quantum.Shape2DConfig"/> instance.
            </summary>
            <param name="toConfig">Shape config to receive the values</param>
        </member>
        <member name="M:Quantum.Shape2DConfig.CompoundShapeData2D.CreateShape(Quantum.Core.FrameBase)">
            <summary>
            Creates a <see cref="T:Quantum.Shape2D"/> using the all the data set in the <see cref="T:Quantum.Shape2DConfig.CompoundShapeData2D"/>.
            This shape is inserted on the shape buffer of the compound. 
            </summary>
            <param name="f">The frame reference.</param>
        </member>
        <member name="M:Quantum.Shape2DConfig.Copy(Quantum.Shape2DConfig,Quantum.Shape2DConfig)">
            <summary>
            Copies all the shape config values to anothere shape config.
            </summary>
            <param name="from">The shape config that will be copied.</param>
            <param name="to">The shape config that will receive the other values.</param>
            <returns>Returns true if the first argument is different from null.</returns>
        </member>
        <member name="T:Quantum.Shape2DType">
            <summary>
            Defines the geometry used by the <see cref="T:Quantum.Shape2D"/>. 
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="F:Quantum.Shape2DType.None">
            <summary>
            Represents a shape of none of the supported types.
            This is the default shape type and will produce errors if used in a collider or query.
            </summary>
        </member>
        <member name="F:Quantum.Shape2DType.Circle">
            <summary>
            2D circle shape
            </summary>
        </member>
        <member name="F:Quantum.Shape2DType.Polygon">
            <summary>
            2D convex polygon shape
            </summary>
        </member>
        <member name="F:Quantum.Shape2DType.Box">
            <summary>
            2D box shape
            </summary>
        </member>
        <member name="F:Quantum.Shape2DType.Edge">
            <summary>
            2D edge shape
            </summary>
        </member>
        <member name="F:Quantum.Shape2DType.Compound">
            <summary>
            2D shape compound of multiple other shapes
            </summary>
        </member>
        <member name="F:Quantum.Shape2DType.Capsule">
            <summary>
            2D capsule shape
            </summary>
        </member>
        <member name="T:Quantum.TriggerInfo2D">
            <summary>
            Info about a collision between a trigger and a non-trigger 2D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>No detailed collision data (ContactPoint, ContactNormal and Penetration) is computed for trigger collisions. Use shape queries with the appropriate query options selected as an option.</remarks>
            <remarks>See <see cref="T:Quantum.TriggerInfo3D"/> for 3D trigger collisions and <see cref="T:Quantum.CollisionInfo2D"/> for 2D non-trigger collisions.</remarks>
            \ingroup Physics2dApi
        </member>
        <member name="P:Quantum.TriggerInfo2D.IgnoreTrigger">
            <summary>
            If the collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo2D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is touching a static trigger collider.
            If so, <see cref="P:Quantum.TriggerInfo2D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.TriggerInfo2D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.TriggerInfo2D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics2D.PhysicsEngine2D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo2D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo2D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.TriggerInfo2D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo2D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape2D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo2D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.TriggerInfo2D.Entity"/> is colliding with a static (check <see cref="P:Quantum.TriggerInfo2D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.PhysicsEngine3D">
            <summary>
            3D Physics API
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.PhysicsEngine3D.Api">
            <summary>
            3D Physics API
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi">
            <summary>
            Struct to provide thread-safe access to the physics functions.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.GetCallbacks(Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetCallbacks(Quantum.EntityRef)"/>
        </member>
        <member name="P:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.Map">
            <inheritdoc cref="P:Quantum.Physics3D.PhysicsEngine3D.Api.Map"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.AllocatePersistentHitCollection3D(System.Int32)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.FreePersistentHitCollection3D(Quantum.Physics3D.HitCollection3D*)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.FreePersistentHitCollection3D(Quantum.Physics3D.HitCollection3D*)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.IsValidQueryRef(Quantum.PhysicsQueryRef@)">
            <summary>
            Checks if a given broad-phase physics query reference is valid for result retrieval.
            Broad-phase queries must be injected before the Physics system Update, their Ref stored and the results
            retrieved after the Physics Update, on the same frame.
            </summary>
            <param name="queryRef">The query ref to be checked.</param>
            <returns><see langword="true"/> if the query ref is valid and query results can be retrieved from it this frame. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.GetQueryHits(System.Int32)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.GetQueryHits(Quantum.PhysicsQueryRef@)">
            <summary>
            Gets the results of a broad-phase query added to the 3D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <returns>A <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.TryGetQueryHits(System.Int32,Quantum.Physics3D.HitCollection3D@)">
            <summary>
            Obsolete. Use 'TryGetQueryHits(in PhysicsQueryRef, out HitCollection3D)' overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.TryGetQueryHits(Quantum.PhysicsQueryRef@,Quantum.Physics3D.HitCollection3D@)">
            <summary>
            Tries to get the results of a broad-phase query added to the 3D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <param name="queryHits">The <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits. Default if the index is not valid.</param>
            <returns><see langword="true"/> if the index is valid, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.GetAllQueriesHits(Quantum.Physics3D.HitCollection3D*@,System.Int32@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetAllQueriesHits(Quantum.Physics3D.HitCollection3D*@,System.Int32@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Physics3D.HitCollection3D*,Quantum.Shape3D*,Quantum.Transform3D*,Quantum.Physics3D.Hit3D*)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Physics3D.HitCollection3D*,Quantum.Shape3D*,Quantum.Transform3D*,Quantum.Physics3D.Hit3D*)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D*,Quantum.Transform3D*,Quantum.Physics3D.Hit3D*)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D*,Quantum.Transform3D*,Quantum.Physics3D.Hit3D*)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.TriangleCCW*,System.Boolean,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.TriangleCCW*,System.Boolean,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.TriangleCCW*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.TriangleCCW*,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.TriangleCCW*,System.Boolean,Quantum.Physics3D.CollisionResultInfo3D@)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.TriangleCCW*,System.Boolean,Quantum.Physics3D.CollisionResultInfo3D@)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.Raycast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.Raycast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.Raycast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.Raycast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.Linecast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.Linecast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.Linecast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.Linecast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.RaycastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.RaycastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.RaycastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.RaycastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.LinecastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.LinecastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.LinecastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.LinecastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="P:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.SceneMesh">
            <inheritdoc cref="P:Quantum.Physics3D.PhysicsEngine3D.Api.SceneMesh"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.ShapeCast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.ShapeCastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.OverlapShape(Quantum.Physics3D.HitCollection3D*,Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Physics3D.HitCollection3D*,Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.OverlapShape(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.OverlapShape(Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ThreadSafeApi.OverlapShape(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)">
            <summary>
            Sets which 3D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider3D component attached to be able to collide with other physics entries.</remarks>
            <remarks>For receiving the callbacks, set the <see cref="T:Quantum.CallbackFlags"/> and implement the corresponding signal on a system.</remarks>
            </summary>
            <param name="entity">An entity with a PhysicsCollider3D component attached.</param>
            <param name="flags">The <see cref="T:Quantum.CallbackFlags"/> of the desired collision callbacks.</param>
            <code>frame.Physics3D.SetCallbacks(entity, CallbackFlags.OnDynamicCollision | CallbackFlags.OnStaticTriggerEnter);</code>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetCallbacks(Quantum.EntityRef)">
            <summary>
            Get the flags that represent which 3D physics collision callbacks will be called for the <paramref name="entity"/>.
            <remarks>The entity must have a PhysicsCollider3D component attached to be able to collide with other physics entries.</remarks>
            <remarks>To modify the callbacks, use <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            </summary>
            <param name="entity">The entity from which to get the callback flags.</param>
            <returns>The callback flags set to a given entity. Default if the entity did not have callback flags set.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ResetCallbacks(Quantum.EntityRef)">
            <summary>
            Resets the tracking history of collisions the <paramref name="entity"/> might have.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.#ctor(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Initializes an Api object to provide the physics functions.
            </summary>
            <param name="frame">The reference of a frame.</param>
            <param name="threadCount">The number of threads.</param>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Init">
            <summary>
            Initializes the game scene and creates all the physics static entries using the settings from the map. 
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Init(Quantum.AssetRef{Quantum.Map})">
            <summary>
            Initializes the game scene by cleaning all physics data and settings and create the new static physics entries for each static collider component in the <paramref name="mapRef"/>. 
            </summary>
            <param name="mapRef">The Map asset for loading static collider data and other physics settings.</param>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ResetScene">
            <summary>
            Resets the entries buffer and removes all the dynamic entries of the scene. Also, joints, queries and collision data are cleaned.
            The <see cref="T:Quantum.PhysicsCommon.MapPhysicsData"/> is changed to default and the <see cref="T:Quantum.PhysicsSceneSettings"/> is changed to initial state.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Update(Quantum.Core.ICollisionCallbacks3D,Photon.Deterministic.FP,Quantum.Task.TaskHandle)">
            <summary>
            Schedules all tasks that compose the 3D Physics Update loop.
            If the frame map changed, the static part of the physics engine is also reset.
            </summary>
            <param name="callbacks">A listener of physics collision callbacks.</param>
            <param name="dt">Delta-time of the physics update loop</param>
            <param name="taskHandle">Handle of the last task scheduled in the graph.</param>
            <returns>The task handle of the last task scheduled by the physics engine.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ResetMap">
            <summary>
            Resets 3D physics scene map asset guid.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.PhysicsEngine3D.Api.Map">
            <summary>
            Retrieves the map asset currently used on the physics scene.
            <remarks>
            The map currently used by the physics scene is only updated during verified simulations,
            so this map can be different from the frame Map during predictions, when the latter is changed. 
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)">
            <summary>
            Allocates a persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/> on the heap with an initial capacity.
            To free an allocated persistent collection of 3D hits, use <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.FreePersistentHitCollection3D(Quantum.Physics3D.HitCollection3D*)"/>.
            </summary>
            <param name="defaultCapacity">The initial <see cref="T:Quantum.Physics3D.Hit3D"/> buffer capacity allocated for the hit collection.</param>
            <returns>A pointer to the allocated hit collection.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.FreePersistentHitCollection3D(Quantum.Physics3D.HitCollection3D*)">
            <summary>
            Free a persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/> previously allocated on the heap.
            To allocate a persistent collection of 3D hits, use <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.
            </summary>
            <param name="collection">A pointer to the persistent hit collection to be freed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the hit collection was not allocated as persistent.</exception>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.IsValidQueryRef(Quantum.PhysicsQueryRef@)">
            <summary>
            Checks if a given broad-phase physics query reference is valid for result retrieval.
            Broad-phase queries must be injected before the Physics system Update, their Ref stored and the results
            retrieved after the Physics Update, on the same frame.
            </summary>
            <param name="queryRef">The query ref to be checked.</param>
            <returns><see langword="true"/> if the query ref is valid and query results can be retrieved from it this frame. <see langword="false"/> otherwise.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(Quantum.PhysicsQueryRef@)">
            <summary>
            Gets the results of a broad-phase query added to the 3D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <returns>A <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetQueryHits(System.Int32)">
            <summary>
            Obsolete. Use 'GetQueryHits(in PhysicsQueryRef)' overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.TryGetQueryHits(Quantum.PhysicsQueryRef@,Quantum.Physics3D.HitCollection3D@)">
            <summary>
            Tries to get the results of a broad-phase query added to the 3D physics scene.
            </summary>
            <param name="queryRef">Broad-phase Query reference. Returned when adding a broad-phase query to the physics engine.</param>
            <param name="queryHits">The <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits. Default if the index is not valid.</param>
            <returns><see langword="true"/> if the index is valid, <see langword="false"/> otherwise.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.TryGetQueryHits(System.Int32,Quantum.Physics3D.HitCollection3D@)">
            <summary>
            Obsolete. Use 'TryGetQueryHits(in PhysicsQueryRef, out HitCollection3D)' overload instead.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.GetAllQueriesHits(Quantum.Physics3D.HitCollection3D*@,System.Int32@)">
            <summary>
            Gets all the results for all the broad-phase queries added to the 3D physics scene this frame.
            </summary>
            <param name="queriesHits">A buffer of <see cref="T:Quantum.Physics3D.HitCollection3D"/> with <paramref name="queriesCount"/> elements, one for each broad-phase query added.</param>
            <param name="queriesCount">The number of elements in the <paramref name="queriesHits"/> buffer, also matching the number on broad-phase queries added.</param>
            <returns><see langword="true"/> if at least one broad-phase query has been added from a system that runs before the physics engine.</returns>
            <example>
            Example of how to iterate over added broad-phase queries results.
            <code>
            if (f.Physics3D.GetAllQueriesHits(out var queriesHits, out var queriesCount)) {
              for (var i = 0; i &lt; queriesCount; i++) {
                var queryHits = queriesHits + i;
                Log.Info($"Preemptive query {i} has {queryHits->Count} hits.");
              }
            }
            </code>
            </example>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Physics3D.HitCollection3D*,Quantum.Shape3D*,Quantum.Transform3D*,Quantum.Physics3D.Hit3D*)">
            <summary>
            Checks if the shape of the hit overlaps another shape and add the results in a <see cref="T:Quantum.Physics3D.HitCollection3D"/>.
            </summary>
            <param name="hits">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="transform">A 3D transform component pointer, with Position and Rotation info of the shape overlap.</param>
            <param name="hit">A 3D hit as reference to an entity that has shape and transform to be overlapped.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D*,Quantum.Transform3D*,Quantum.Physics3D.Hit3D*)">
            <summary>
            Checks if the shape of the hit overlaps another shape.
            </summary>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="transform">A 3D transform component pointer, with Position and Rotation info of the shape overlap.</param>
            <param name="hit">A 3D hit as reference to an entity that has shape and transform to be overlapped</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a sphere shape overlaps with another sphere shape.
            </summary>
            <param name="sphereShapeA">The 3D sphere shape to be overlapped.</param>
            <param name="positionA">The position in which the sphere shape is overlapped.</param>
            <param name="sphereShapeB">The 3D  shape that will overlap.</param>
            <param name="positionB">The position at which the sphere shape will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a sphere shape overlaps with a box shape.
            </summary>
            <param name="sphereShape">The 3D sphere shape to be overlapped.</param>
            <param name="spherePosition">The position in which the sphere shape is overlapped.</param>
            <param name="boxShape">The 3D box shape that will overlap.</param>
            <param name="boxTransform">A 3D transform component pointer, with Position and Rotation info of the box shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a box shape overlaps with a sphere shape.
            </summary>
            <param name="boxShape">The 3D box shape to be overlapped.</param>
            <param name="boxTransform">A 3D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="sphereShape">The 3D sphere shape that will overlap.</param>
            <param name="spherePosition">The position at which the sphere shape will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a sphere shape overlaps with a capsule shape.
            </summary>
            <param name="sphereShape">The 3D sphere shape to be overlapped.</param>
            <param name="spherePosition">The position in which the sphere shape is overlapped.</param>
            <param name="capsuleShape">The 3D capsule shape that will overlap.</param>
            <param name="capsuleTransform">A 3D transform component pointer, with Position and Rotation info of the capsule shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a capsule shape overlaps with a sphere shape.
            </summary>
            <param name="capsuleShape">The 3D capsule shape to be overlapped.</param>
            <param name="capsuleTransform">A 3D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="sphereShape">The 3D sphere shape that will overlap.</param>
            <param name="spherePosition">The position at which the sphere shape will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.SphereShape,Photon.Deterministic.FPVector3,Quantum.TriangleCCW*,System.Boolean,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a sphere shape overlaps with a triangle.
            </summary>
            <param name="sphereShape">The 3D sphere shape to be overlapped.</param>
            <param name="spherePosition">The position in which the sphere shape is overlapped.</param>
            <param name="tri">The triangle that will overlap.</param>
            <param name="smoothSphereMeshCollision">If true, the normal of the collision will aways be the triangle face up normal.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a box shape overlaps with another box shape.
            </summary>
            <param name="boxShapeA">The 3D box shape to be overlapped.</param>
            <param name="transformA">A 3D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="boxShapeB">The 3D box shape that will overlap.</param>
            <param name="transformB">A 3D transform component pointer, with Position and Rotation info of the box shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a box shape overlaps with a capsule shape.
            </summary>
            <param name="boxShape">The 3D box shape to be overlapped.</param>
            <param name="boxTransform">A 3D transform component pointer, with Position and Rotation info of the overlapped box shape.</param>
            <param name="capsuleShape">The 3D capsule shape that will overlap.</param>
            <param name="capsuleTransform">A 3D transform component pointer, with Position and Rotation info of the capsule shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a capsule shape overlaps with a box shape.
            </summary>
            <param name="capsuleShape">The 3D capsule shape to be overlapped.</param>
            <param name="capsuleTransform">A 3D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="boxShape">The 3D box shape that will overlap.</param>
            <param name="boxTransform">A 3D transform component pointer, with Position and Rotation info of the box shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.BoxShape,Quantum.Transform3D*,Quantum.TriangleCCW*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a box shape overlaps with a triangle.
            </summary>
            <param name="boxShape">The 3D box shape to be overlapped.</param>
            <param name="boxTransform">The position in which the box shape is overlapped.</param>
            <param name="tri">The triangle that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a capsule shape overlaps with another capsule shape.
            </summary>
            <param name="capsuleShapeA">The 3D capsule shape to be overlapped.</param>
            <param name="capsuleTransformA">A 3D transform component pointer, with Position and Rotation info of the overlapped capsule shape.</param>
            <param name="capsuleShapeB">The 3D capsule shape that will overlap.</param>
            <param name="capsuleTransformB">A 3D transform component pointer, with Position and Rotation info of the capsule shape that will overlap.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.CheckOverlap(Quantum.Shape3D.CapsuleShape,Quantum.Transform3D*,Quantum.TriangleCCW*,System.Boolean,Quantum.Physics3D.CollisionResultInfo3D@)">
            <summary>
            Checks if a capsule shape overlaps with a triangle.
            </summary>
            <param name="capsuleShape">The 3D capsule shape to be overlapped.</param>
            <param name="capsuleTransform">The position in which the capsule shape is overlapped.</param>
            <param name="tri">The triangle that will overlap.</param>
            <param name="smoothSphereMeshCollision">If true, the normal of the collision will aways be the triangle face up normal.</param>
            <param name="result">A <see cref="T:Quantum.Physics3D.CollisionResultInfo3D"/> struct that contains the penetration, normal and computed contact points.</param>
            <returns>Return if the shapes are in overlap.</returns>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddRaycastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Boolean,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase ray cast query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the ray <paramref name="origin"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddLinecastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Boolean,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase line cast query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="firstHitOnly">If the query results should return only the closest hit to the line <paramref name="start"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Raycast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast and returns the closest hit to the ray origin, if any.
            </summary>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A nullable <see cref="T:Quantum.Physics3D.Hit3D"/> with the closest hit to the ray origin, if any.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Raycast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast and adds the closest hit to the ray origin, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Linecast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast and returns the closest hit to the line start, if any.
            </summary>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A nullable <see cref="T:Quantum.Physics3D.Hit3D"/> with the closest hit to the line start, if any.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.Linecast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast and adds the closest hit to the line start, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.RaycastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast, returning all hits.
            </summary>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.RaycastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a ray cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="origin">The ray origin point, in a 3D world space.</param>
            <param name="direction">The direction of the ray, not normalized internally.</param>
            <param name="distance">The ray distance from the origin point on the specified direction.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.LinecastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast, returning all hits.
            </summary>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.LinecastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a line cast, returning all hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The line start point, in a 3D world space.</param>
            <param name="end">The line end point, in a 3D world space.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.Physics3D.PhysicsEngine3D.Api.SceneMesh">
            /// <summary>
            Returns the <see cref="T:Quantum.TriangleMesh"/> data for static meshes.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Boolean,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape cast query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="start">The cast start point, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="firstHitOnly">If the query results should return only the hit with the smallest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/> or all hits (default).</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,Photon.Deterministic.FPVector3,System.Boolean,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddShapeCastQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Boolean,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast and returns the hit with the smallest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>, if any.
            </summary>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A nullable <see cref="T:Quantum.Physics3D.Hit3D"/> with the smallest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>, if any.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCast(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast and adds the hit with the shortest <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>, if any, to a persistent collection of hits.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast, returning all hits.
            </summary>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <inheritdoc cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)"/>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.ShapeCastAll(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D*,Photon.Deterministic.FPVector3,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape cast, adding all hits to a persistent collection.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="start">The cast start, in a 3D world space.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be casted.</param>
            <param name="translation">The cast direction and distance, from the cast start point.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against. By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query. By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddOverlapShapeQuery(Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="transform">A 3D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.AddOverlapShapeQuery(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Adds a broad-phase shape overlap query to the 3D physics scene.
            In order to be resolved, must be added from a system that runs prior to the Physics System.
            </summary>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>The index of the injected query, to be used when retrieving the results with GetQueryHits.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Physics3D.HitCollection3D*,Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="transform">A 3D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Physics3D.HitCollection3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="collection">A previously allocated persistent <see cref="T:Quantum.Physics3D.HitCollection3D"/>, to which the query hits will be added.
            For allocating a persistent HitCollection, see <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.AllocatePersistentHitCollection3D(System.Int32)"/>.</param>
            <param name="position">The position in which the shape is overlapped.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the hit collection is not persistent.</exception>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Quantum.Transform3D,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="transform">A 3D transform component, with Position and Rotation info of the shape overlap.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.OverlapShape(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,Quantum.Shape3D,System.Int32,Quantum.QueryOptions)">
            <summary>
            Queries the 3D physics scene with a shape overlap.
            </summary>
            <param name="position">The 3D position in which the shape is overlapped.</param>
            <param name="rotation">The quaternion rotation of the shape.</param>
            <param name="shape">The 3D shape to be overlapped.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against.
            By default, all layers are considered. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="options">The <see cref="T:Quantum.QueryOptions"/> used by the query.
            By default, all types of colliders are checked against and detailed info (hit point, penetration and normal) is not computed.</param>
            <returns>A temporary <see cref="T:Quantum.Physics3D.HitCollection3D"/> with the query hits, automatically freed when the current frame simulation ends.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetStaticColliderEnabled(System.Int32,System.Boolean)">
            <summary>
            Set a toggleable 3D static collider enabled state to <paramref name="enabled"/>.
            Disabled static colliders are not considered for collisions or on query resolutions.
            <remarks>The static collider state is only changed on Verified frames.</remarks>
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders3D">StaticColliders3D</see> array.</param>
            <param name="enabled">If the static should be enabled (true) or disabled (false).</param>
            <exception cref="T:System.InvalidOperationException">If the static collider is baked as Immutable.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="M:Quantum.Physics3D.PhysicsEngine3D.Api.IsStaticColliderEnabled(System.Int32)">
            <summary>
            Returns the current state of a 3D static collider.
            </summary>
            <param name="staticColliderIndex">The index of the collider in the Map <see cref="F:Quantum.Map.StaticColliders3D">StaticColliders3D</see> array.</param>
            <returns><see langword="false"/> if the static is not Immutable and is currently disabled, <see langword="true"/> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If the provided <paramref name="staticColliderIndex"/> is not in the range of static colliders loaded in the current Physics static scene.</exception>
        </member>
        <member name="P:Quantum.Physics3D.PhysicsEngine3D.SceneMesh">
            <summary>
            3D Physics' space-partitioning structure for static meshes and their triangles. 
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.JointType3D">
            <summary>
            Defines the type of a 3D <see cref="T:Quantum.Physics3D.Joint3D"/>.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.None">
            <summary>
            Defines a Joint of no specific type, which are not solved by the Physics Engine.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.DistanceJoint">
            <summary>
            Defines the type of a <see cref="T:Quantum.Physics3D.DistanceJoint3D"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.SpringJoint">
            <summary>
            Defines the type of a <see cref="T:Quantum.Physics3D.SpringJoint3D"/>.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.JointType3D.HingeJoint">
            <summary>
            Defines the type of a <see cref="T:Quantum.Physics3D.HingeJoint3D"/>.
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.Joint3D">
            <summary>
            Defines a connection between a 3D Physics Body and an anchor, according to velocity and/or position constraints.
            The connected anchor can be a world-space position or another entity with at least a transform component. 
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.UserTag">
            <summary>
            A numerical tag that can be used to identify a joint or a group of joints.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.Anchor">
            <summary>
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.ConnectedAnchor">
            <summary>
            If the joint has a <see cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.ConnectedEntity">
            <summary>
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.SpringJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics3D.Joint3D.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.DistanceJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics3D.Joint3D.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Joint3D.HingeJoint">
            <summary>
            Type-specific settings of a joint of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.
            <remarks>
            Different types of joints have their fields overlapping in memory.
            Thus, settings of a type different than this joint's <see cref="P:Quantum.Physics3D.Joint3D.Type"/> might have fields with unexpected values.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Joint3D.Type">
            <summary>
            The type of this joint, indicating which type-specific settings should be accessed.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Joint3D.Enabled">
            <summary>
            If the constraints of this joint should be considered and resolved by the 3D Physics Engine. 
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.Joint3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics3D.Joint3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics3D.Joint3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics3D.Joint3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics3D.DistanceJoint3D">
            <summary>
            A <see cref="T:Quantum.Physics3D.Joint3D"/> that connects a Physics Body to an anchor and attempts to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.DistanceJoint3D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.DistanceJoint3D.Anchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.Anchor"/>
            @copydoc Joint3D.Anchor
        </member>
        <member name="F:Quantum.Physics3D.DistanceJoint3D.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/>
            @copydoc Joint3D.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics3D.DistanceJoint3D.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>
            @copydoc Joint3D.ConnectedEntity
        </member>
        <member name="P:Quantum.Physics3D.DistanceJoint3D.MinDistance">
            <summary>
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics3D.DistanceJoint3D.MaxDistance"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.DistanceJoint3D.MaxDistance">
            <summary>
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics3D.DistanceJoint3D.MinDistance"/>.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.DistanceJoint3D.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics3D.DistanceJoint3D"/> struct.
            Use <see cref="M:Quantum.Physics3D.DistanceJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/> instead to create a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.DistanceJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics3D.DistanceJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.
            </summary>
            <param name="minDistance">
            The minimum distance between the anchor points that the joint will attempt to maintain.
            If set to zero or default, allows any distance below <see cref="P:Quantum.Physics3D.DistanceJoint3D.MaxDistance"/>.
            </param>
            <param name="maxDistance">
            The maximum distance between the anchor points that the joint will attempt to maintain.
            If set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>, allows any distance in the usable range above <see cref="P:Quantum.Physics3D.DistanceJoint3D.MinDistance"/>.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.DistanceJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.DistanceJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.DistanceJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics3D.DistanceJoint3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics3D.DistanceJoint3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics3D.DistanceJoint3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics3D.DistanceJoint3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics3D.HingeJoint3D">
            <summary>
            A <see cref="T:Quantum.Physics3D.Joint3D"/> that attaches a Physics Body to an anchor around which it can rotate.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            The rotation can happen freely or, optionally, with limiting angles and/or a motor torque.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.Anchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.Anchor"/>
            @copydoc Joint3D.Anchor
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/>
            @copydoc Joint3D.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>
            @copydoc Joint3D.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.LowerLimitRad">
            <summary>
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.UpperLimitRad">
            <summary>
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> to enable or disable the angle-limiting constraints.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed">
            <summary>
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.HingeJoint3D.MaxMotorTorque">
            <summary>
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed"/>.
            Set to <see cref="P:Photon.Deterministic.FP.UseableMax"/> in order to allow "unlimited" torque while respecting the FP usable range.
            Set <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> to enable or disable the hinge motor.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits">
            <summary>
            If the <see cref="F:Quantum.Physics3D.HingeJoint3D.LowerLimitRad"/> and <see cref="F:Quantum.Physics3D.HingeJoint3D.UpperLimitRad"/> limiting constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HingeJoint3D.UseMotor">
            <summary>
            If the <see cref="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed"/> and <see cref="F:Quantum.Physics3D.HingeJoint3D.MaxMotorTorque"/> constraints should be considered and resolved by the Physics Engine.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HingeJoint3D.Axis">
            <summary>
            Axis around which the joint rotates, defined in the local space of the entity.
            To modify the axis, use <see cref="M:Quantum.Physics3D.HingeJoint3D.SetAxis(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HingeJoint3D.RelativeRotationReference">
            <summary>
            Reference rotation relative to the connected entity's space.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.HingeJoint3D.#ctor(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics3D.HingeJoint3D"/> struct.
            Use <see cref="M:Quantum.Physics3D.HingeJoint3D.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/> instead to create a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.HingeJoint3D.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics3D.HingeJoint3D.CreateJoint(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.
            </summary>
            <param name="f"></param>
            <param name="jointEntity"></param>
            <param name="axis">
            Axis around which the joint rotates, defined in the local space of the entity.
            The vector is normalized before set. If zeroed, <see cref="P:Photon.Deterministic.FPVector3.Right"/> is used instead.
            </param>
            <param name="lowerLimitRad">
            The lower angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an upper limiting angle is set, the lower angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMin"/>.
            If both limiting angles are <see langword="null"/>, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="upperLimitRad">
            The upper angle of the allowed arc of rotation around the connected anchor, in radians.
            If none is provided, i.e. default(NullableFP), and an lower limiting angle is set, the upper angle will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both limiting angles are <see langword="null"/>, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseAngleLimits"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="motorSpeed">
            The speed at which the hinge motor will attempt to rotate, in radians per second.
            If none is provided, i.e. default(NullableFP), and a maximum motor toque is set, the target motor speed will be set to 0.
            If both motor speed and maximum torque are <see langword="null"/>, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="maxMotorTorque">
            The maximum torque produced by the hinge motor in order to achieve the target <see cref="F:Quantum.Physics3D.HingeJoint3D.MotorSpeed"/>.
            If none is provided, i.e. default(NullableFP), and a target motor speed is set, the maximum torque will be set to <see cref="P:Photon.Deterministic.FP.UseableMax"/>.
            If both motor speed and maximum torque are <see langword="null"/>, <see cref="P:Quantum.Physics3D.HingeJoint3D.UseMotor"/> is <see langword="false"/> and related constraints will not be applied.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.HingeJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.HingeJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.HingeJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics3D.HingeJoint3D.SetAxis(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,System.Boolean)">
            <summary>
            Sets the <see cref="P:Quantum.Physics3D.HingeJoint3D.Axis"/> around which the joint rotates, defined in the local space of the entity.
            </summary>
            <param name="f"></param>
            <param name="jointEntity">Entity that contains this joint.</param>
            <param name="axis">
            The axis around which the joint rotates, defined in the local space of the entity.
            Normalized before being set. If zeroed, <see cref="P:Photon.Deterministic.FPVector3.Right"/> is used instead.
            </param>
            <param name="resetRelRotRef">
            If the joint's <see cref="P:Quantum.Physics3D.HingeJoint3D.RelativeRotationReference"/> should be reset.
            This field is usually only reset when the joint and connected entities are first connected.
            </param>
        </member>
        <member name="M:Quantum.Physics3D.HingeJoint3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics3D.HingeJoint3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics3D.HingeJoint3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics3D.HingeJoint3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics3D.SpringJoint3D">
            <summary>
            A <see cref="T:Quantum.Physics3D.Joint3D"/> that attaches a Physics Body to an anchor as if connected by a spring, trying to keep them a certain distance apart.
            The connected anchor can be a world-space position or another entity with at least a transform component.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Anchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.Anchor"/>
            @copydoc Joint3D.Anchor
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.ConnectedAnchor">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedAnchor"/>
            @copydoc Joint3D.ConnectedAnchor
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.ConnectedEntity">
            <inheritdoc cref="F:Quantum.Physics3D.Joint3D.ConnectedEntity"/>
            @copydoc Joint3D.ConnectedEntity
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Spring">
            <summary>
            The stiffness of the spring, in Newtons per meter (N/m).
            To get or set the frequency (Hz) at which the spring will attempt to oscillate, given the physics body(ies) involved, use <see cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics3D.SpringJoint3D.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Damper">
            <summary>
            The damper capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            To get or set the damping RATIO, given the physics body(ies) involved, use <see cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/> and <see cref="M:Quantum.Physics3D.SpringJoint3D.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*)"/>, respectively.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.SpringJoint3D.Distance">
            <summary>
            The distance between the anchor points that the joint will attempt to maintain.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.#ctor(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Constructs a <see cref="T:Quantum.Physics3D.SpringJoint3D"/> struct.
            Use CreateJoint overloads instead to create a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.SpringJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)"/>
            <returns></returns>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.EntityRef,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            </summary>
            <param name="spring">
            The stiffness of the spring, in Newtons per meter (N/m).
            </param>
            <param name="damper">
            The damping capacity at which the spring oscillation is suppressed, in Newtons per square meter (N/m2).
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.CreateJoint(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.EntityRef,Quantum.PhysicsBody3D*,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3)">
            <summary>
            Creates a <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.
            </summary>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <param name="distance">
            The distance between the anchor points that the joint will attempt to maintain.
            </param>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the joint entity.
            The body mass affects the spring rate necessary to achieve the target oscillation frequency.
            </param>
            <param name="connectedEntity">
            A target entity that this joint might be connected to. If set to <see cref="P:Quantum.EntityRef.None"/>, the <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedAnchor"/> represents the target anchor position in world space.
            The connected entity must have at least a <see cref="T:Quantum.Transform3D"/> component. If it also has a non-kinematic <see cref="T:Quantum.PhysicsBody3D"/>, joint forces are also computed and applied to it. 
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the <paramref name="connectedEntity"/>, if it exists and has one.
            Can be <see langword="null"/>, in which case the spring/damper rates will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="anchor">
            The anchor offset, in the local space of the joint entity transform.
            This is the point considered for the joint constraints and where the joint forces are applied.
            </param>
            <param name="connectedAnchor">
            If the joint has a <see cref="F:Quantum.Physics3D.SpringJoint3D.ConnectedEntity"/>, this represents the anchor offset relative to it, in local space.
            Else, this is the position in world space considered as target anchor.
            </param>
            <returns>A <see cref="T:Quantum.Physics3D.Joint3D"/> of type <see cref="F:Quantum.Physics3D.JointType3D.SpringJoint"/>.</returns>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="frequency"/> and <paramref name="dampingRatio"/> based on the joint <see cref="F:Quantum.Physics3D.SpringJoint3D.Spring"/> and <see cref="F:Quantum.Physics3D.SpringJoint3D.Damper"/> capacities, given the physics body(ies) involved. 
            </summary>
            <param name="jointBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the joint entity.
            The body mass affects the resultant oscillation frequency, given the joint spring stiffness.
            </param>
            <param name="connectedBody">
            The <see cref="T:Quantum.PhysicsBody3D"/> component of the entity connected to the joint, if it exists and has one.
            Can be <see langword="null"/>, in which case the frequency and damping ratio will be computed as if the joint is connected to a fixed point or kinematic body. 
            </param>
            <param name="frequency">
            The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate, given the mass of the body(ies) involved.
            Typical values are below half the frequency of the simulation.
            </param>
            <param name="dampingRatio">
            A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.
            </param>
            <exception cref="T:System.NullReferenceException">If the <paramref name="jointBody"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.SetStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*)">
            <summary>
            Computes and sets the <see cref="F:Quantum.Physics3D.SpringJoint3D.Spring"/> and <see cref="F:Quantum.Physics3D.SpringJoint3D.Damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.ComputeStiffness(Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)">
            <summary>
            Computes the <paramref name="spring"/> and <paramref name="damper"/> capacities based on the target <paramref name="frequency"/> and <paramref name="dampingRatio"/>, given the physics body(ies) involved.
            </summary>
            <inheritdoc cref="M:Quantum.Physics3D.SpringJoint3D.GetStiffness(Quantum.PhysicsBody3D*,Quantum.PhysicsBody3D*,Photon.Deterministic.FP@,Photon.Deterministic.FP@)"/>
            @copydetails GetStiffness
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics3D.SpringJoint3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics3D.SpringJoint3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics3D.SpringJoint3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Scene3D.Task_CreateEntriesMapping(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)">
            <summary>
            Creates a mapping from EntityRef to Entry (usable for Joints, for instance).
            Must run after <see cref="M:Quantum.Physics3D.Scene3D.Task_CreateEntries(Quantum.FrameThreadSafe,System.Int32,System.Int32,System.Void*)"/> and in a single thread.
            </summary>
        </member>
        <member name="T:Quantum.Physics3D.Hit3D">
            <summary>
            Information returned from a valid hit of a physics query.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.ShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> field of the shape hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.OverlapPenetration">
            <summary>
            The penetration of a shape overlap query on the collider that was hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options
            and only applies to Shape Overlap queries.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized">
            <summary>
            A normalized value (0 to 1) of the feature being casted when the hit occurs, relative to its full cast distance.
            <remarks>
            This field only applies to Ray, Line or Shape casts.
            It overlaps in memory and is mutually exclusive with <see cref="F:Quantum.Physics3D.Hit3D.OverlapPenetration"/>.
            </remarks>
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.Point">
            <summary>
            The point in world space where the collider is hit by the query.
            </summary>
        </member>
        <member name="F:Quantum.Physics3D.Hit3D.Normal">
            <summary>
            The surface normal of the hit.
            <remarks>
            This field is not computed unless <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> is used in the query options.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.IsDynamic">
            <summary>
            If the collider hit by the query is not static, i.e. it belongs to an <see cref="P:Quantum.Physics3D.Hit3D.Entity"/>.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.IsStatic">
            <summary>
            If the collider hit was static.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.StaticColliderIndex">
            <summary>
            0-based index of the static collider on the <see cref="F:Quantum.Map.StaticColliders3D"/> array of the map referenced by <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef"/>.
            If the hit <see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>, this value is -1.
            Tip: use <see cref="M:Quantum.Physics3D.Hit3D.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider3D@)"/>, <see cref="M:Quantum.Physics3D.Hit3D.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)"/>, <see cref="M:Quantum.Physics3D.Hit3D.GetStaticCollider(Quantum.Core.FrameBase)"/> or <see cref="M:Quantum.Physics3D.Hit3D.GetStaticData(Quantum.Core.FrameBase)"/>
            in order to safely and conveniently access info about a static collider hit.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef">
            <summary>
            The reference to the map used by the physics engine when a static collider is hit.
            Otherwise, this value is default (hit <see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>).
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.IsTrigger">
            <summary>
            If the collider hit by the query is Trigger.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.TriangleIndex">
            <summary>
            The index of the triangle touched by a query.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.Hit3D.Entity">
            <summary>
            The reference of the entity hit by the query, <see cref="P:Quantum.EntityRef.None"/> if hitting a static collider (<see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/> <see langword="false"/>).
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetShape(Quantum.Core.FrameBase)">
            <summary>
            Gets the shape of the collider hit by the query.
            </summary>
            <param name="f">The Frame.</param>
            <returns>The shape of the collider.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.TryGetShape(Quantum.Core.FrameBase,Quantum.Shape3D*@)">
            <summary>
            Tries to get the shape of the collider hit by the query.
            </summary>
            <param name="f">The frame.</param>
            <param name="shape">The shape of the collider, if found.</param>
            <returns>True if the shape was retrieved successfully, false otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.SetHitEntity(Quantum.EntityRef)">
            <summary>
            Sets the entity that was hit. Automatically resets <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderIndex"/> to -1.
            </summary>
            <param name="entity">The entity reference.</param>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.SetHitStaticCollider(System.Int32,Quantum.AssetRef{Quantum.Map})">
            <summary>
            Sets the index of the static collider hit on the <see cref="F:Quantum.Map.StaticColliders3D"/> array of the referenced map.
            </summary>
            <param name="staticColliderIndex">A valid index of the static collider on the array of the map.</param>
            <param name="mapRef">A reference to the map where the static collider hit is located.</param>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.TryGetStaticCollider(Quantum.Core.FrameBase,Quantum.MapStaticCollider3D@)">
            <summary>
            Tries to access the static collider that was hit.
            </summary>
            <param name="f">Current frame.</param>
            <param name="collider">A copy of the static collider data found. Default if the metadata is not valid (returns <see langword="false"/>).</param>
            <returns><see langword="false"/> if the collider hit is not static or the collide index or referenced map are not valid. <see langword="true"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.TryGetStaticCollider(Quantum.FrameThreadSafe,Quantum.MapStaticCollider3D@)">
            <summary>
            Tries to retrieve the static collider associated with the hit in the given frame.
            </summary>
            <param name="f">The frame from which to retrieve the static collider.</param>
            <param name="collider">The static collider associated with the hit, if found. Otherwise, it will be set to default.</param>
            <returns>True if the static collider is found and retrieved successfully; otherwise, false.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.TryGetStaticData(Quantum.Core.FrameBase,Quantum.StaticColliderData@)">
            <summary>
            Tries to access the data of the static collider that was hit (<see cref="F:Quantum.MapStaticCollider3D.StaticData"/>).
            </summary>
            <param name="f">Current frame.</param>
            <param name="data">A copy of the static collider data found. Default if the metadata is not valid (returns <see langword="false"/>).</param>
            <returns><see langword="false"/> if the collider hit is not static or the collide index or referenced map are not valid. <see langword="true"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.TryGetStaticData(Quantum.FrameThreadSafe,Quantum.StaticColliderData@)">
            <summary>
            Tries to retrieve the static collider data associated with the hit.
            </summary>
            <param name="f">The FrameThreadSafe object.</param>
            <param name="data">When this method returns, contains the static collider data associated with the hit, if the hit is a static hit; otherwise, the value is default.</param>
            <returns>true if the hit is a static hit and the static collider data is retrieved successfully; otherwise, false.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetStaticCollider(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the static collider hit. Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetStaticCollider(Quantum.FrameThreadSafe)">
            <summary>
            Gets the static collider hit by the query.
            </summary>
            <param name="f">The FrameThreadSafe.</param>
            <returns>The static collider.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetStaticData(Quantum.Core.FrameBase)">
            <summary>
            Gets a reference to the data of the static collider hit (<see cref="F:Quantum.MapStaticCollider3D.StaticData"/>). Does not perform additional safety checks.
            </summary>
            <param name="f">Current frame.</param>
            <exception cref="T:System.NullReferenceException">If the <see cref="P:Quantum.Physics3D.Hit3D.StaticColliderMapRef"/> does not reference a valid asset.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the hit is not static (<see cref="P:Quantum.Physics3D.Hit3D.IsDynamic"/>) or the collider index is not valid for the array of static colliders on the referenced map.</exception>
            <returns>A reference to the static collider hit.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetStaticData(Quantum.FrameThreadSafe)">
            <summary>
            Gets the static collider data of the collision hit in the specified frame.
            </summary>
            <param name="f">The frame containing the collision data.</param>
            <returns>The static collider data of the collision.</returns>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Physics3D.Hit3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Physics3D.Hit3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Physics3D.Hit3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Physics3D.HitCollection3D">
            <summary>
            Collection of hit information returned from a physics query.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.Physics3D.HitCollection3D.Count">
            <summary>
            Gets the number of hits in the hit collection.
            </summary>
            <value>The number of hits in the hit collection.</value>
        </member>
        <member name="P:Quantum.Physics3D.HitCollection3D.Item(System.Int32)">
            <summary>
            Represents a hit result from a physics query at a specific index.
            </summary>
        </member>
        <member name="P:Quantum.Physics3D.HitCollection3D.HitsBuffer">
            <summary>
            The buffer containing all hits in the collection.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.ToArray">
            <summary>
            Converts the collection of hits into a managed array.
            </summary>
            <returns>A managed array of hits.</returns>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.Sort(Photon.Deterministic.FPVector3)">
            <summary>
            Sort all hits in the collection, in ascending order, based on the distance from the <see cref="F:Quantum.Physics3D.Hit3D.Point"/> to the target <paramref name="point"/>.
            <remarks>
            Queries must have the <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> option set in order to compute hit Points and Cast Distance.
            Include this flag if intending to sort the query results.
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.SortCastDistance">
            <summary>
            Sort all hits in the collection, in ascending order, based on the <see cref="F:Quantum.Physics3D.Hit3D.CastDistanceNormalized"/>.
            <remarks>
            Queries must have the <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> option set in order to compute hit Points and Cast Distance.
            Include this flag if intending to sort the query results.
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.Free(Photon.Deterministic.Native.Allocator)">
            <summary>
            Frees a persistent hit collection held by an allocator.
            </summary>
            <param name="allocator">The allocator used for the hit collection.</param>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.Reset">
            <summary>
            Resets the hit collection by setting its count to 0.
            </summary>
        </member>
        <member name="M:Quantum.Physics3D.HitCollection3D.Add(Quantum.Physics3D.Hit3D,Quantum.Core.FrameContext)">
            <summary>
            Adds a Hit3D object to the HitCollection3D.
            </summary>
            <param name="hit">The Hit3D object to add.</param>
            <param name="context">The FrameContext object.</param>
        </member>
        <member name="M:Quantum.Physics3D.FPVector3RawInt.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.Physics3D.FPQuaternionRawInt.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.IKCCCallbacks3D">
            <summary>
            The interface receives the interaction callbacks from the character controller system. 
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.IKCCCallbacks3D.OnCharacterCollision3D(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics3D.Hit3D)">
            <summary>
            Allows to receive a <paramref name="hit"/> as result of the collision with other colliders.
            </summary>
            <param name="f">The current frame.</param>
            <param name="character">The entity of the character.</param>
            <param name="hit">The <see cref="T:Quantum.Physics3D.Hit3D"/> with the collision info.</param>
            <returns>True if the collision should be considered. False otherwise.</returns>
        </member>
        <member name="M:Quantum.IKCCCallbacks3D.OnCharacterTrigger3D(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics3D.Hit3D)">
            <summary>
            Allows to receive a <paramref name="hit"/> as result of the collision with other trigger colliders.
            </summary>
            <returns></returns>
            <inheritdoc cref="M:Quantum.IKCCCallbacks3D.OnCharacterCollision3D(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Physics3D.Hit3D)"/>
        </member>
        <member name="T:Quantum.CharacterController3DMovement">
            <summary>
            Result of a 3D KCC raw movement query.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Type">
            <summary>
            Recommended type of movement based on found collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.NearestNormal">
            <summary>
            Surface normal of the nearest collision.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.AvgNormal">
            <summary>
            Average normal of all collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.GroundNormal">
            <summary>
            Surface normal of the closest collision that qualifies as ground, if any.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Tangent">
            <summary>
            Surface tangent (recommended movement direction) in case there's a desired direction passed.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.SlopeTangent">
            <summary>
            Surface tangent (recommended movement direction) in case of a slope (based on gravity).
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Correction">
            <summary>
            Full correction vector to move out of collisions.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Penetration">
            <summary>
            Magnitude of the penetration over the nearest normal.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Grounded">
            <summary>
            <see langword="true"/> if at least one collision (not necessarily closest) qualifies as ground.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3DMovement.Contacts">
            <summary>
            Total number of collisions found in this execution of the movement query.
            </summary>
        </member>
        <member name="T:Quantum.CharacterController3D">
            <summary>
            A component for kinematic character controller prototyping that uses a sphere as a shape.
            You can quickly add this to an entity and set a <see cref="T:Quantum.CharacterController3DConfig"/>, then call the <see cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/> method in a system update.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.CharacterController3D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3D.BroadPhaseQuery">
            <summary>
            Broad-Phase Query index of the last query added by calling <see cref="M:Quantum.CharacterController3D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})"/>.
            To use Broad-Phase queries, call <see cref="M:Quantum.CharacterController3D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})"/> before the Physics system Update runs.
            When Move() is called and a broad-phase query has been added, the method will not perform a new query,
            but retrieve and use the results of the broad-phase query previously injected.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3D.MaxSpeed">
            <summary>
            The character's maximum horizontal speed will be clamped by this value.
            </summary>
        </member>
        <member name="F:Quantum.CharacterController3D.Velocity">
            <summary>
            The current velocity of the character controller.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3D.Config">
            <summary>
            Returns the <see cref="T:Quantum.CharacterController3DConfig">Character Controller </see> config asset.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3D.Grounded">
            <summary>
            Returns true if the character controller is touching the floor.
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3D.Jumped">
            <summary>
            If the character jumped this frame. See <see cref="M:Quantum.CharacterController3D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})"/>.
            <remarks>This state is consumed in the default steering method <see cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CharacterController3D.BroadPhaseQueryIndex">
            <summary>
            Obsolete. Use <see cref="F:Quantum.CharacterController3D.BroadPhaseQuery"/> instead.
            </summary>
        </member>
        <member name="M:Quantum.CharacterController3D.Init(Quantum.Core.FrameBase,Quantum.CharacterController3DConfig)">
            <summary>
            Initializes the 3D character controller component.
            <remarks>
            Use <see cref="M:Quantum.CharacterController3D.SetConfig(Quantum.Core.FrameBase,Quantum.CharacterController3DConfig)">SetConfig</see> instead
            in order to set or change the KCC config without resetting other fields.
            This method is not thread-safe: use the thread-safe overload if calling from a multi-threaded context.
            </remarks>
            </summary>
            <param name="frame">The current Frame.</param>
            <param name="config">
            The KCC <see cref="T:Quantum.CharacterController3DConfig"/> asset.
            If none is provided, the default config asset is used.
            </param>
        </member>
        <member name="M:Quantum.CharacterController3D.Init(Quantum.FrameThreadSafe,Quantum.CharacterController3DConfig)">
            <inheritdoc cref="M:Quantum.CharacterController3D.Init(Quantum.Core.FrameBase,Quantum.CharacterController3DConfig)"/>
        </member>
        <member name="M:Quantum.CharacterController3D.SetConfig(Quantum.Core.FrameBase,Quantum.CharacterController3DConfig)">
            <summary>
            Sets or changes this KCC's config.
            <remarks>
            This method does not reset other values like <see cref="P:Quantum.CharacterController3D.Grounded"/> and <see cref="F:Quantum.CharacterController3D.Velocity"/>:
            use <see cref="M:Quantum.CharacterController3D.Init(Quantum.Core.FrameBase,Quantum.CharacterController3DConfig)">Init</see> for that.
            This method is not thread-safe: use the thread-safe overload if calling from a threaded context.
            </remarks>
            </summary>
            <param name="frame">The current Frame.</param>
            <param name="config">
            The KCC <see cref="T:Quantum.CharacterController3DConfig"/> asset.
            If none is provided, the default config asset is used.
            </param>
        </member>
        <member name="M:Quantum.CharacterController3D.SetConfig(Quantum.FrameThreadSafe,Quantum.CharacterController3DConfig)">
            <inheritdoc cref="M:Quantum.CharacterController3D.SetConfig(Quantum.Core.FrameBase,Quantum.CharacterController3DConfig)"/>
        </member>
        <member name="M:Quantum.CharacterController3D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Applies a vertical impulse to the KCC velocity.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>No steering is performed at this stage. To actually move the character, use <see cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.</remarks>
            <param name="frame">The frame object.</param>
            <param name="ignoreGrounded">If the <see cref="P:Quantum.CharacterController3D.Grounded"/> state of the KCC should be ignored.</param>
            <param name="impulse">The amount of impulse applied to the KCC. If none is provided, the <see cref="F:Quantum.CharacterController3DConfig.BaseJumpImpulse"/> of the KCC config is used.</param>
        </member>
        <member name="M:Quantum.CharacterController3D.Jump(Quantum.FrameThreadSafe,System.Boolean,System.Nullable{Photon.Deterministic.FP})">
            <inheritdoc cref="M:Quantum.CharacterController3D.Jump(Quantum.Core.FrameBase,System.Boolean,System.Nullable{Photon.Deterministic.FP})"/>
        </member>
        <member name="M:Quantum.CharacterController3D.AddBroadPhaseQuery(Quantum.Core.FrameBase,Quantum.EntityRef,System.Nullable{System.Int32})">
            <summary>
            Adds a Broad-phase query to the 3D Physics scene, according to the KCC config settings, and store the query ref in <see cref="F:Quantum.CharacterController3D.BroadPhaseQuery"/>.
            This ref will be used on the next time Move or ComputeRawMovement is called to retrieve the resolved query results and perform the KCC logic.
            </summary>
            <remarks>
            The added BP-Query must be retrieve on the same frame. To cancel the addition of a BP-Query and perform a regular one when moving the KCC, set <see cref="F:Quantum.CharacterController3D.BroadPhaseQuery"/> to default. 
            </remarks>
            <param name="frame">The current frame object.</param>
            <param name="entity">The entity that represents the character. It must have a <see cref="T:Quantum.Transform3D"/> component, which will be used to compute the query position.</param>
            <param name="layerMask">A mask that specifies which layers should be considered by the query. If <see langword="null"/> (default), the layer mask defined in the KCC config will be used.</param>
            <returns>The index of the added query.</returns>
        </member>
        <member name="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})">
            <summary>
            Queries the 3D physics scene with <see cref="M:Quantum.CharacterController3D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform3D*,Quantum.CharacterController3D*,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean})"/>, computes a default steering in the desired <paramref name="direction"/> and moves the <paramref name="entity"/>.
            <remarks>This method is not thread-safe. Use the thread-safe overload if calling from a threaded context.</remarks>
            </summary>
            <remarks>The entity must have a Transform3D component.</remarks>
            <param name="frame">The frame in which the entity is being moved.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks. If calling from a system that implements the interface, you can use the "this" keyword.</param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If <see langword="null"/> is passed, the layer mask defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If <see langword="false"/>, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController3DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <param name="deltaTime">The delta timed used to integrate the kcc velocity. If no value is provided, the <paramref name="frame"/> delta time is used.</param>
        </member>
        <member name="M:Quantum.CharacterController3D.Move(Quantum.FrameThreadSafe,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})">
            <inheritdoc cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>
        </member>
        <member name="M:Quantum.CharacterController3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.CharacterController3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="p">The pointer to the <see cref="T:Quantum.CharacterController3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.CharacterController3D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform3D*,Quantum.CharacterController3D*,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <summary>
            Queries the 3D physics scene in the <paramref name="transform"/> position, using the <paramref name="kcc"/> config, and computes movement data.
            The movement data can be used to apply a custom steering to the character based on its surrounding environment.
            For using the default steering, use <see cref="M:Quantum.CharacterController3D.Move(Quantum.Core.FrameBase,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{Photon.Deterministic.FP})"/>.
            </summary>
            <param name="frame">The frame in which the physics scene is being queried.</param>
            <param name="entity">The entity that represents the character. Any collider attached by this entity is ignored in the raw movement computation.</param>
            <param name="transform">A pointer to a Transform3D component that has the position where the scene will be queried at, usually being the <paramref name="entity"/> transform.</param>
            <param name="kcc">A pointer to a CharacterController3D component that has the config used by the query, usually being the <paramref name="entity"/> kcc component.</param>
            <param name="direction">The intended movement direction.</param>
            <param name="callback">An object that can receive the KCC callbacks.
            <remarks>If calling from a system that implements the interface, you can use the "this" keyword.</remarks>
            </param>
            <param name="layerMask">A mask that specifies which layers will be checked against in the raw movement computation.
            If null is passed, the layer maks defined in the KCC config will be used. To create a layer mask, see <see cref="M:Quantum.LayerInfo.GetLayerMask(System.String)"/> and overloads on the <see cref="P:Quantum.Core.FrameBase.Layers">frame.Layers</see> property.</param>
            <param name="useManifoldNormal">
            If the hit manifold normal should be used when computing the raw movement.
            If <see langword="false"/>, the normal is computed from the query position and the contact point.
            If no value is provided, the <see cref="F:Quantum.CharacterController3DConfig.UseManifoldNormal"/> of the KCC config is used.
            </param>
            <returns>A <see cref="T:Quantum.CharacterController3DMovement"/> struct with raw movement data that can be used to compute a custom steering.</returns>
        </member>
        <member name="M:Quantum.CharacterController3D.ComputeRawMovement(Quantum.FrameThreadSafe,Quantum.EntityRef,Quantum.Transform3D*,Quantum.CharacterController3D*,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <inheritdoc cref="M:Quantum.CharacterController3D.ComputeRawMovement(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.Transform3D*,Quantum.CharacterController3D*,Photon.Deterministic.FPVector3,Quantum.IKCCCallbacks3D,System.Nullable{System.Int32},System.Nullable{System.Boolean})"/>
        </member>
        <member name="T:Quantum.RotationFreezeFlags">
            <summary>
            The flags to set up the rotation axis that will be not changed by the physics body movement.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.RotationFreezeFlags.None">
            <summary>
            Default. No axis is frozen.
            </summary>
        </member>
        <member name="F:Quantum.RotationFreezeFlags.FreezeX">
            <summary>
            Freezes the rotation on the X axis.
            </summary>
        </member>
        <member name="F:Quantum.RotationFreezeFlags.FreezeY">
            <summary>
            Freezes the rotation on the Y axis.
            </summary>
        </member>
        <member name="F:Quantum.RotationFreezeFlags.FreezeZ">
            <summary>
            Freezes the rotation on the Z axis.
            </summary>
        </member>
        <member name="F:Quantum.RotationFreezeFlags.FreezeAll">
            <summary>
            Freezes the rotation on all axes.
            </summary>
        </member>
        <member name="T:Quantum.PhysicsBody3D">
            <summary>
            Adds physics motion to an entity with a <see cref="T:Quantum.PhysicsCollider3D"/> driven by the built-in physics systems. 
            You can customize how the movement of the physics body will works by changing the <see cref="P:Quantum.PhysicsBody3D.Mass"/>, <see cref="P:Quantum.PhysicsBody3D.GravityScale"/> or <see cref="P:Quantum.PhysicsBody3D.Drag"/>.
            A <see cref="P:Quantum.PhysicsBody3D.IsKinematic">Kinematic</see> body will not have linear and angular velocities integrated, but those values are still perceived and taken into
            account when resolving the collision with other dynamic bodies.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.PhysicsBody3D.ConfigFlags">
            <summary>
            The flags to set up how the physics body will behave in the physics systems.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.Default">
            <summary>IsAllowedToSleep | IsAwakenedByForces | ResetInertiaOnAdded | ResetCenterOfMassOnAdded</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.IsKinematic">
            <summary>Prevents linear and angular velocities from being integrated.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.IsAllowedToSleep">
            <summary>Allows the physics body to sleep after some time at rest.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.IsAwakenedByForces">
            <summary>Allows sleeping physic bodies to be awakened by dynamic interactions.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.IsAwakenedByKinematics">
            <summary>Allows sleeping physic bodies to be awakened by kinematic interaction.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.ResetInertiaOnAdded">
            <summary>Allows the physics body to compute the inertia automatically when it is added to an entity.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.ResetCenterOfMassOnAdded">
            <summary>Resets the <see cref="P:Quantum.PhysicsBody3D.CenterOfMass"/> to the shape <see cref="F:Quantum.Shape3D.Centroid"/> when the physics body is added to an entity.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.ConfigFlags.UseContinuousCollisionDetection">
            <summary>Prevents the physics body from passing through other objects when at high velocity.</summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.RotationFreeze">
            <summary>
            The <see cref="T:Quantum.RotationFreezeFlags"/> that blocks the rotation in the specified axes.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.Velocity">
            <summary>
            The rate of change of physics body position in units per second. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsBody3D.AngularVelocity">
            <summary>
            The rate of change of physics rotation in radians per second for each axis.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody3D.Force">
            <summary>
            The accumulated forces by the <see cref="M:Quantum.PhysicsBody3D.AddForce(Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPVector3})"/> method that will be integrated into delta velocity on the next Physics Update.
            This value is reset after the integration.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody3D.Torque">
            <summary>
            The accumulated torques by the <see cref="M:Quantum.PhysicsBody3D.AddTorque(Photon.Deterministic.FPVector3)"/> method that will be integrated into delta angular velocity on the next Physics Update.
            This value is reset after the integration.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsBody3D.Enabled">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.Enabled"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.AllowSleeping">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.AllowSleeping"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.IsAwakenedByKinematics">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.IsAwakenedByKinematics"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.IsSleeping">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.IsSleeping"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.UseContinuousCollisionDetection">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.UseContinuousCollisionDetection"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.Drag">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.Drag"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.AngularDrag">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.AngularDrag"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.Mass">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.Mass"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.MassInverse">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.MassInverse"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.GravityScale">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.GravityScale"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.InertiaScale">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.InertiaScale"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.CenterOfMass">
            <inheritdoc cref="F:Quantum.PhysicsBody2D.CenterOfMass"/>
        </member>
        <member name="P:Quantum.PhysicsBody3D.IsKinematic">
            <inheritdoc cref="P:Quantum.PhysicsBody2D.IsKinematic"/>
        </member>
        <member name="M:Quantum.PhysicsBody3D.GetInertiaTensor">
            <summary>
            Returns the inertia tensor based on the stored inverse inertia tensor values.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody3D.GetInertiaTensorInverse">
            <summary>
            Returns the inverse form of the inertia tensor, as it is stored internally.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.PhysicsBody3D.SetInertiaTensor(Photon.Deterministic.FPVector3,Photon.Deterministic.NullableFP)">
            <summary>
            Sets the inertia tensor value. The greater the value of inertia on a given axis, the more torque will be required to achieve the same delta angular velocity on that axis.
            This value is automatically recomputed when the value of mass is set.
            </summary>
            <param name="inertiaTensor">The inertia tensor value. This value is scaled by the <see cref="P:Quantum.PhysicsBody3D.InertiaScale"/>
            or by <paramref name="resetInertiaScale"/> if provided and its inverse value is stored on the component.
            </param>
            <param name="resetInertiaScale">
            If specified, resets the body <see cref="P:Quantum.PhysicsBody3D.InertiaScale"/> and immediately applies the new scale to the
            provided <paramref name="inertiaTensor"/>.
            </param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.CreateDynamic(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,System.Boolean,System.Boolean,Quantum.RotationFreezeFlags,System.Nullable{Photon.Deterministic.FPVector3},Photon.Deterministic.NullableFP)">
            <summary>
            Creates a dynamic <see cref="T:Quantum.PhysicsBody3D"/>.
            </summary>
            <param name="mass">The mass of the physics body.</param>
            <param name="drag">The drag of the physics body.</param>
            <param name="angularDrag">The angular drag of the physics body.</param>
            <param name="allowSleeping">Allows the physics body to sleep.</param>
            <param name="awakenByKinematics">Allows the physics body to be awaken by an interaction with kinematic bodies.</param>
            <param name="flags">The rotation freeze flags.</param>
            <param name="centerOfMass">The center of mass position relative to the transform's origin.</param>
            <param name="gravityScale">The multiplier for the gravity force applied for this physics body.</param>
            <returns>A <see cref="T:Quantum.PhysicsBody3D"/> component.</returns>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.PhysicsBody3D.CreateDynamic(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D.ConfigFlags,Quantum.RotationFreezeFlags,System.Nullable{Photon.Deterministic.FPVector3},Photon.Deterministic.NullableFP)">
            <inheritdoc cref="M:Quantum.PhysicsBody3D.CreateDynamic(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,System.Boolean,System.Boolean,Quantum.RotationFreezeFlags,System.Nullable{Photon.Deterministic.FPVector3},Photon.Deterministic.NullableFP)"/>
        </member>
        <member name="M:Quantum.PhysicsBody3D.CreateKinematic">
            <summary>
            Creates a kinematic <see cref="T:Quantum.PhysicsBody3D"/>. The mass, drag and angular drag are not considered in kinematic interactions and have 0 as value.
            </summary>
            <returns>A <see cref="T:Quantum.PhysicsBody3D"/> component.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody3D.InitBody(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsBody3D.ConfigFlags,Quantum.RotationFreezeFlags,System.Nullable{Photon.Deterministic.FPVector3},Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFP,Photon.Deterministic.NullableFPVector3)">
            <summary>
            Initializes a <see cref="T:Quantum.PhysicsBody3D"/> component with custom settings.
            </summary>
            <param name="bodyMass">The mass of the physics body.</param>
            <param name="drag">The drag of the physics body.</param>
            <param name="angularDrag">The angular drag of the physics body.</param>
            <param name="bodyConfig">The <see cref="T:Quantum.PhysicsBody3D.ConfigFlags"/> used in the physics body.</param>
            <param name="rotationFlags">The <see cref="T:Quantum.RotationFreezeFlags"/> used in the physics body.</param>
            <param name="centerOfMass">The center of mass position relative to the transform's origin.</param>
            <param name="gravityScale">The multiplier for the gravity force applied for this physics body.</param>
            <param name="inertiaScale">A multiplier for the inertia tensor value.</param>
            <param name="inertiaTensor">
            An optional value for the body's inertia tensor.
            If not specified AND the <see cref="F:Quantum.PhysicsBody3D.ConfigFlags.ResetInertiaOnAdded"/> is set in the <paramref name="bodyConfig"/>,
            then the inertia tensor will be computed when the body component is added to an entity, based on the shape of the
            collider, assuming uniform mass distribution.
            </param>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.PhysicsBody3D.ResetInertia(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the inertia on this physics body component based on its mass and the shape of a
            <see cref="T:Quantum.PhysicsCollider3D"/> component on the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody3D"/> component is added to an entity, unless the body <see cref="F:Quantum.PhysicsBody3D.ConfigFlags.ResetInertiaOnAdded"/> flag is not set.
            The body's center of mass affects the computation of the inertia, so consider calling
            <see cref="M:Quantum.PhysicsBody3D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)"/> before resetting the inertia, specially if the collider shape has changed.
            More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="frame">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider shape will be retrieved, necessary for computing the inertia.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.ResetCenterOfMass(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <summary>
            Resets the <see cref="P:Quantum.PhysicsBody3D.CenterOfMass"/> of physics body component to the the shape <see cref="F:Quantum.Shape3D.Centroid">centroid</see>
            of a <see cref="T:Quantum.PhysicsCollider3D"/> component attached to the <paramref name="entity"/>.
            <remarks>
            This is called automatically when a <see cref="T:Quantum.PhysicsBody3D"/> component is added to an entity,
            unless the body <see cref="F:Quantum.PhysicsBody3D.ConfigFlags.ResetCenterOfMassOnAdded"/> flag is not set.
            When changing the collider shape in runtime, consider resetting the center of mass and inertia of the attached physics body,
            in this order. More info on the online docs <a href="https://doc.photonengine.com/en-us/quantum/v2/manual/physics/collider-body#changing_the_shape_at_runtime">here</a>.
            </remarks>
            </summary>
            <param name="f">Current frame instance in use.</param>
            <param name="entity">The entity from which the collider component and shape will be retrieved.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddLinearImpulse(Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPVector3})">
            <summary>
            Applies the given <paramref name="amount"/> of linear impulse to the body.
            The amount of delta-velocity generated by the impulse is inversely proportional to the mass of the body.
            If the impulse is applied in a <paramref name="relativePoint"/> that is different than zero, it will also generate a delta angular velocity.
            </summary>
            <param name="amount">The impulse vector to be applied.</param>
            <param name="relativePoint">A vector in world space that represents the distance from the center of mass to the point where the impulse is being applied.</param>
            <seealso cref="M:Quantum.PhysicsBody3D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.Transform3D)"/>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.Transform3D)">
            <inheritdoc cref="M:Quantum.PhysicsBody3D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.Transform3D*)"/>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddLinearImpulseAtPosition(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.Transform3D*)">
            <summary>
            Applies the given linear <paramref name="impulse"/> to the body at a given <paramref name="position"/> in world space.
            </summary>
            <param name="impulse">The impulse vector to be applied.</param>
            <param name="position">
            The point in world space where the impulse is being applied.
            This position should be withing the collider shape in order to prevent unrealistic behavior.
            </param>
            <param name="transform">The current transform of the entity that owns this physics body.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddAngularImpulse(Photon.Deterministic.FPVector3)">
            <summary>
            Accumulates a given <paramref name="amount"/> of angular impulse, to be integrated into angular velocity on the next Physics Update.
            The amount of delta angular velocity produced by the angular impulse is inversely proportional to the body inertia on each axis.
            </summary>
            <param name="amount">The angular impulse to be accumulated.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.ClearForce">
            <summary>
            Clears all the accumulated forces in this body.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddForce(Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPVector3})">
            <summary>
            Increases the <see cref="P:Quantum.PhysicsBody3D.Force"/> value with the <paramref name="amount"/> vector.
            The force is integrated into delta velocity on the next Physics Update. The amount of delta-velocity produced
            by the accumulated force is directly proportional do the delta-time and inversely proportional do the Mass of the body.
            If the impulse is applied at a <paramref name="relativePoint"/> that is different than zero, it will also generate <see cref="P:Quantum.PhysicsBody3D.Torque"/>.
            </summary>
            <param name="amount">The force vector in world coordinates.</param>
            <param name="relativePoint">A vector in world space that represents the distance from the center of mass to the point where the impulse is being applied.</param>
            <seealso cref="M:Quantum.PhysicsBody3D.AddTorque(Photon.Deterministic.FPVector3)"/>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddForceAtPosition(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.Transform3D)">
            <inheritdoc cref="M:Quantum.PhysicsBody3D.AddForceAtPosition(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.Transform3D*)"/>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddForceAtPosition(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Quantum.Transform3D*)">
            <summary>
            Applies the given <paramref name="force"/> to the body at a given <paramref name="position"/> in world space.
            </summary>
            <param name="force">The force vector to be applied.</param>
            <param name="position">
            The point in world space where the impulse is being applied.
            This position should be withing the collider shape in order to prevent unrealistic behavior.
            </param>
            <param name="transform">The current transform of the entity that owns this physics body.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.ClearTorque">
            <summary>
            Clears all the accumulated torques in this body.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody3D.AddTorque(Photon.Deterministic.FPVector3)">
            <summary>
            Accumulates a given <paramref name="amount"/> of torque, to be integrated into angular velocity on the next Physics Update.
            The amount of delta angular velocity produced by the angular impulse is directly proportional to the Update delta-time and
            inversely proportional to the body inertia on each axis.
            </summary>
            <param name="amount">The torque to be accumulated.</param>
        </member>
        <member name="M:Quantum.PhysicsBody3D.GetPointVelocity(Photon.Deterministic.FPVector3,Quantum.Transform3D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined in world space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in world space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 3D vector representing the computed velocity, also in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody3D.GetRelativePointVelocity(Photon.Deterministic.FPVector3,Quantum.Transform3D*)">
            <summary>
            Computes the velocity of the physics body at a given <paramref name="point"/> defined on its local space.
            </summary>
            <param name="point">The point where the velocity will be computed at, in local space.</param>
            <param name="bodyTransform">The transform component of the entity to which this physics body belongs.</param>
            <returns>A 3D vector representing the computed velocity, in world space.</returns>
        </member>
        <member name="M:Quantum.PhysicsBody3D.WakeUp">
            <summary>
            Wakes up a sleeping physics body and resets the accumulated time within sleeping thresholds.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody3D.Sleep">
            <summary>
            Puts an enabled physics body into a sleeping state.
            <remarks>
            If set during a physics collision callback, the body might be awakened by the solver if the collision is not ignored.  
            </remarks>
            </summary>
        </member>
        <member name="M:Quantum.PhysicsBody3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsBody3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsBody3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsCallbacks3D">
            <inheritdoc cref="T:Quantum.PhysicsCallbacks2D"/>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.PhysicsCallbacks3D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCallbacks3D.Flags">
            <summary>
            Represents which collision callbacks will be called for the entity. See <see cref="T:Quantum.CallbackFlags"/> for more information.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsCallbacks3D.IsCollidingWith(Quantum.Core.FrameBase,Quantum.EntityRef,System.Int32@)">
            <inheritdoc cref="M:Quantum.PhysicsCallbacks2D.IsCollidingWith(Quantum.Core.FrameBase,Quantum.EntityRef,System.Int32@)"/>
        </member>
        <member name="M:Quantum.PhysicsCallbacks3D.IsCollidingWith(Quantum.Core.FrameBase,Quantum.AssetGuid,System.Int32,System.Int32@)">
            <inheritdoc cref="M:Quantum.PhysicsCallbacks2D.IsCollidingWith(Quantum.Core.FrameBase,Quantum.AssetGuid,System.Int32,System.Int32@)"/>
        </member>
        <member name="M:Quantum.PhysicsCallbacks3D.AddCollision(Quantum.Core.FrameBase,Quantum.EntityRef)">
            <inheritdoc cref="M:Quantum.PhysicsCallbacks2D.AddCollision(Quantum.Core.FrameBase,Quantum.EntityRef)"/>
        </member>
        <member name="M:Quantum.PhysicsCallbacks3D.AddCollision(Quantum.Core.FrameBase,Quantum.AssetGuid,System.Int32,System.Boolean)">
            <inheritdoc cref="M:Quantum.PhysicsCallbacks2D.AddCollision(Quantum.Core.FrameBase,Quantum.AssetGuid,System.Int32,System.Boolean)"/>
        </member>
        <member name="P:Quantum.PhysicsCallbacks3D.ListCount">
            <inheritdoc cref="P:Quantum.PhysicsCallbacks2D.ListCount"/>
        </member>
        <member name="P:Quantum.PhysicsCallbacks3D.ListBufferPtr">
            <inheritdoc cref="P:Quantum.PhysicsCallbacks2D.ListBufferPtr"/>
        </member>
        <member name="M:Quantum.PhysicsCallbacks3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsCallbacks3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsCallbacks3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsCollider3D">
            <summary>
            A component with a shape used to represent 3D physics objects in the physics simulation. 
            You can use <see cref="T:Quantum.PhysicsCollider3D.Flags">flags</see> and <see cref="P:Quantum.PhysicsCollider3D.Layer">layers</see> to setup how the object interacts with other colliders.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.PhysicsCollider3D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCollider3D._material">
            <inheritdoc cref="P:Quantum.PhysicsCollider3D.Material"/>
        </member>
        <member name="F:Quantum.PhysicsCollider3D.Shape">
            <summary>
            The <see cref="T:Quantum.Shape3D"/> used by the collider.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCollider3D.Layer">
            <inheritdoc cref="P:Quantum.PhysicsCollider2D.Layer"/>
        </member>
        <member name="P:Quantum.PhysicsCollider3D.IsTrigger">
            <inheritdoc cref="P:Quantum.PhysicsCollider2D.IsTrigger"/>
        </member>
        <member name="P:Quantum.PhysicsCollider3D.Material">
            <inheritdoc cref="P:Quantum.PhysicsCollider2D.Material"/>
        </member>
        <member name="P:Quantum.PhysicsCollider3D.Enabled">
            <inheritdoc cref="P:Quantum.PhysicsCollider2D.Enabled"/>
        </member>
        <member name="M:Quantum.PhysicsCollider3D.Create(Quantum.Core.FrameBase,Quantum.Shape3D,Quantum.PhysicsMaterial,System.Boolean,System.Int32)">
            <summary>
            Creates a physics collider component with a <see cref="T:Quantum.Shape3D"/>.
            </summary>
            <param name="f">The frame.</param>
            <param name="shape">
            The shape to be used by this collider. If the provided shape is a <see cref="T:Quantum.Shape3D.CompoundShape3D"/>, this
            collider will create a deep, persistent copy of the provided compound, which will be disposed automatically when
            this component is removed from an entity.
            </param>
            <param name="material">The physics material asset object. If null, it will use the default physics material.</param>
            <param name="isTrigger">If the collider is trigger. False by default.</param>
            <param name="layer">The index of the layer the collider belongs to.</param>
            <returns>An instance of physics collider component.</returns>
        </member>
        <member name="M:Quantum.PhysicsCollider3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsCollider3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsCollider3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsJoints3D">
            <summary>
            A component holding one or more <see cref="T:Quantum.Physics3D.Joint3D"/>,
            defining connections between a 3D Physics Body and anchors according to velocity and/or position constraints.
            </summary>
            \ingroup PhysicsJoints3D
        </member>
        <member name="P:Quantum.PhysicsJoints3D.Count">
            <summary>
            The current amount of joints tracked by the component.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.Capacity">
            <summary>
            The number of joints the currently allocated buffer can hold before having to be resized.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@)">
            <summary>
            Adds a <see cref="T:Quantum.Physics3D.Joint3D"/> to the component.
            If the buffer is at full <see cref="P:Quantum.PhysicsJoints3D.Capacity"/>, a new buffer will be allocated with double the capacity and existing entries are copied over.
            In that case, the previous buffer is not disposed immediately and cached pointers are still valid, although outdated.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joint">The joint that will be added to the component.</param>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.RemoveJoints(Quantum.Core.FrameBase,System.Nullable{System.Int32})">
            <summary>
            Removes all joints in the component that have a <see cref="F:Quantum.Physics3D.Joint3D.UserTag"/> field matching the specified <paramref name="userTag"/>.
            If none is specified, all joints are removed.
            </summary>
            <remarks>
            This method does not keep the order of remaining elements in the buffer.
            To achieve that instead, use <see cref="M:Quantum.PhysicsJoints3D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints3D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> while iterating the buffer in reverse order.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="userTag">
            A numerical tag that can be used to identify a joint or a group of joints.
            Any joint in the component that matches the tag will be removed.
            If none is specified, all joints are removed.
            </param>
            <returns><see langword="true"/> if at least one joint has been removed.</returns>
            <code>
            const int removeJointsUserTag = 42;
            
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            if (removeAll) {
              jointsComponent->RemoveJoints(f);
            } else {
              jointsComponent->RemoveJoints(f, removeJointsUserTag);
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.RemoveAt(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer, while keeping the order of the remaining objects.
            If the remaining elements do not need to be kept in order, <see cref="M:Quantum.PhysicsJoints3D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)"/> is a cheaper option.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics3D.JointType3D.DistanceJoint) {
                  // removes the element at the current index, keeping the order of the remaining ones
                  jointsComponent->RemoveAt(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.RemoveAtUnordered(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Removes the joint at the specified <paramref name="index"/> of the component's joints buffer.
            The order of the elements with indices greater than <paramref name="index"/> is not kept.
            If the order must be kept, use <see cref="M:Quantum.PhysicsJoints3D.RemoveAt(Quantum.Core.FrameBase,System.Int32)"/> instead.
            </summary>
            <param name="f">The current frame.</param>
            <param name="index">The index of the element to be removed.</param>
            <exception cref="T:System.NullReferenceException">If the joints buffer is not allocated.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="index"/> is outside the valid range.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              // by iterating the buffer in reverse order we avoid skipping elements if also removing
              for (var i = count - 1; i >= 0; i--) {
                var current = joints + i;
            
                if (current->Type == Physics3D.JointType3D.DistanceJoint) {
                  // removes the element at the current index
                  // the order of the elements with index greater than i is not ensured
                  jointsComponent->RemoveAtUnordered(f, i);
                }
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D*@,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints, if it has one.
            See also <see cref="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="joints">The allocated buffer for the component joints. <see langword="null"/> if the buffer is not allocated.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called. 0 if the buffer is not allocated.</param>
            <returns><see langword="true"/> if the buffer is allocated.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            
            if (jointsComponent->TryGetJoints(f, out var joints, out var count)) {
              for (var i = 0; i &lt; count; i++) {
                var current = joints + i;
                Log.Info($"Joint Type {i}: {current->Type}");
              }
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.GetJoints(Quantum.Core.FrameBase,System.Int32@)">
            <summary>
            Gets the currently allocated buffer for the component joints.
            See also <see cref="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to iterate over the buffer with an auxiliary structure.
            </summary>
            <param name="f">The current frame.</param>
            <param name="count">The number of elements used in the buffer at the moment this method is called.</param>
            <returns>The allocated buffer for the component joints.</returns>
            <exception cref="T:System.NullReferenceException">If the buffer is not allocated.</exception>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            var joints = jointsComponent->GetJoints(f, out var count);
            
            for (var i = 0; i &lt; count; i++) {
              var current = joints + i;
              Log.Info($"Joint Type {i}: {current->Type}");
            }
            </code>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsJoints3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsJoints3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsJoints3D.JointsIterator3D">
            <summary>
            An auxiliary struct to iterate over the joints on a <see cref="T:Quantum.PhysicsJoints3D"/> component.
            Use <see cref="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)"/> to acquire an iterator for the component's joint buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints3D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = <see langword="true"/>;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics3D.JointType3D.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
            \ingroup PhysicsJoints3D
        </member>
        <member name="M:Quantum.PhysicsJoints3D.JointsIterator3D.GetEnumerator">
            <summary>
            The iterator is also an enumerator.
            This method is useful for accessing the elements in a foreach loop, for instance.
            </summary>
            <returns>A copy of this iterator on its current state.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.JointsIterator3D.MoveNext">
            <summary>
            Moves to the next joint.
            </summary>
            <returns><see langword="true"/> if there is a next element.</returns>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.JointsIterator3D.Reset">
            <summary>
            Resets the iterator to its original state.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.JointsIterator3D.CurrentUnsafe">
            <summary>
            A pointer to the current joint being iterated.
            This allows modifications to the element in the actual buffer of joints.
            </summary>
            <exception cref="T:System.NullReferenceException">If the iterator buffer is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the iterator current index is outside the valid range of the buffer: [0, count).</exception>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.JointsIterator3D.Current">
            <summary>
            A copy of the current joint being iterated.
            To modify the actual element in the buffer, use <see cref="P:Quantum.PhysicsJoints3D.JointsIterator3D.CurrentUnsafe"/> instead.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsJoints3D.JointsIterator3D.CurrentIndex">
            <summary>
            The index on the buffer of the element currently being iterated.
            The index is out of the valid range if the iterator has just been created on <see cref="M:Quantum.PhysicsJoints3D.JointsIterator3D.Reset"/>.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsJoints3D.GetIterator(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Gets an auxiliary struct to iterate over the joints in this component.
            See also <see cref="M:Quantum.PhysicsJoints3D.TryGetJoints(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D*@,System.Int32@)"/> and <see cref="M:Quantum.PhysicsJoints3D.GetJoints(Quantum.Core.FrameBase,System.Int32@)"/> to have direct access to the buffer.
            </summary>
            <remarks>
            If new elements are added while iterating and this causes the buffer to be expanded,
            the iterator will keep iterating over the previous buffer, which is not immediately disposed (see <see cref="M:Quantum.PhysicsJoints3D.AddJoint(Quantum.Core.FrameBase,Quantum.Physics3D.Joint3D@)"/>).
            In this case, further changes to elements in the buffer being iterated will not modify the elements on the new buffer.
            Hence, the addition of elements while iterating is not recommended, unless the access to the elements are read-only.
            </remarks>
            <param name="f">The current frame.</param>
            <param name="reverseOrder">
            If the buffer elements should be iterated in reverse order.
            If <see langword="true"/>, allows the removal of elements while iterating without it causing some elements to be skipped.
            </param>
            <returns>A <see cref="T:Quantum.PhysicsJoints3D.JointsIterator3D"/> for the buffer of joints in this component.</returns>
            <code>
            var jointsComponent = f.Unsafe.GetPointer&lt;PhysicsJoints3D&gt;(entity);
            var jointsIterator  = jointsComponent->GetIterator(f);
            
            while (jointsIterator.MoveNext()) {
              // CurrentUnsafe is a pointer to the element in the buffer
              jointsIterator.CurrentUnsafe->Enabled = <see langword="true"/>;
            
              // Current is a copy of the joint being currently iterated
              var jointCopy = jointsIterator.Current;
              Assert.Check(jointCopy.Enabled);
            
              // by default, the iterator will go through the elements in reverse order.
              // this allows the removal of elements while iterating without this causing elements to be skipped as a byproduct.
              if (jointCopy.Type == Physics3D.JointType3D.None) {
                jointsComponent->RemoveAtUnordered(f, jointsIterator.CurrentIndex);
              }
            }
            </code>
        </member>
        <member name="T:Quantum.TriangleReference">
            <summary>
            Represents a reference to a triangle in the triangle mesh.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.TriangleReference.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.TriangleReference.ALIGNMENT">
            <summary>
            The struct alignment in bytes.
            </summary>
        </member>
        <member name="P:Quantum.TriangleReference.Index">
            <summary>
            The index of the triangle.
            </summary>
        </member>
        <member name="P:Quantum.TriangleReference.IsValid">
            <summary>
            If this triangle reference is valid.
            </summary>
        </member>
        <member name="P:Quantum.TriangleReference.IsMany">
            <summary>
            If this reference point to multiple triangles.
            </summary>
        </member>
        <member name="M:Quantum.TriangleReference.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.TriangleReference"/> struct.
            </summary>
            <param name="index">The index of the referenced triangle.</param>
            <param name="isMany">If the reference point to multiple triangles. <seealso cref="P:Quantum.TriangleReference.IsMany"/></param>
        </member>
        <member name="M:Quantum.TriangleReference.Equals(Quantum.TriangleReference)">
            <summary>
            Checks if this instance is equal to another <see cref="T:Quantum.TriangleReference"/>.
            </summary>
            <param name="other">The other triangle reference to be checked against.</param>
            <returns><see langword="true"/> if the triangle references are equal. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.TriangleReference.Equals(System.Object)">
            <summary>
            Checks if this instance is equal to another object.
            </summary>
            <param name="obj">The object to be checked against.</param>
            <returns><see langword="true"/> if the object is a <see cref="T:Quantum.TriangleReference"/> and they are equal to each other.
            <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Quantum.TriangleReference.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.TriangleReference.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.TriangleReference"/> into an instance of <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/>.
            </summary>
            <param name="p">The pointer to the <see cref="T:Quantum.TriangleReference"/>.</param>
            <param name="serializer">The <see cref="T:Photon.Deterministic.IDeterministicFrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.TriangleReference.op_Equality(Quantum.TriangleReference,Quantum.TriangleReference)">
            <summary>
            Checks if two <see cref="T:Quantum.TriangleReference"/> instances are equal.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><see langword="true"/> if equal. <see langword="false"/> if not.</returns>
        </member>
        <member name="M:Quantum.TriangleReference.op_Inequality(Quantum.TriangleReference,Quantum.TriangleReference)">
            <summary>
            Checks if two <see cref="T:Quantum.TriangleReference"/> instances are not equal.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><see langword="true"/> if not equal. <see langword="false"/> if equal.</returns>
        </member>
        <member name="T:Quantum.TriangleMesh">
            <summary>
            The data representation of all static triangles in the scene.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.TriangleMesh.CellVisitor">
            <summary>
            The delegate used to visit cells in the triangle mesh.
            </summary>
        </member>
        <member name="T:Quantum.TriangleMesh.CellBounds">
            <summary>
            The bounds of a cell.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.ALIGNMENT">
            <summary>
            The struct alignment in bytes.
            </summary>
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.MinX">
            <summary>
            The minimum bounds of the cell in the X component.
            </summary>
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.MinY">
            <summary>
            The minimum bounds of the cell in the Y component.
            </summary>
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.MinZ">
            <summary>
            The minimum bounds of the cell in the Z component.
            </summary>
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.MaxX">
            <summary>
            The maximum bounds of the cell in the X component.
            </summary>
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.MaxY">
            <summary>
            The maximum bounds of the cell in the Y component.
            </summary>
        </member>
        <member name="F:Quantum.TriangleMesh.CellBounds.MaxZ">
            <summary>
            The maximum bounds of the cell in the Z component.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.CellCount">
            <summary>
            Get the number of cells in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.CellCapacity">
            <summary>
            The capacity of the cells in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.FreeCellCount">
            <summary>
            The number of free cells in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.FreeCellHead">
            <summary>
            The first free cell in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.CellSize">
            <summary>
            The size of the cells in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.CellExtent">
            <summary>
            The extent of the cells in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.CellBroadRadius">
            <summary>
            The broad radius of the cells in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.Bounds">
            <summary>
            The bounds of the cells.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.TriangleCount">
            <summary>
            The number of triangles in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.TriangleCapacity">
            <summary>
            The capacity of the triangles in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.FreeTriangleCount">
            <summary>
            The number of free triangles in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.FreeTriangleHead">
            <summary>
            The first free triangle in the triangle mesh.
            </summary>
        </member>
        <member name="P:Quantum.TriangleMesh.ImmutableTriangleCount">
            <summary>
            How many triangles are immutable (ie: not toggleable) in the triangle mesh.
            </summary>
        </member>
        <member name="M:Quantum.TriangleMesh.VisitCells(Quantum.TriangleMesh.CellVisitor)">
            <summary>
            Visits all cells in the triangle mesh using the supplied cell visitor.
            </summary>
            <param name="visitor">The visitor delegate to use.</param>
        </member>
        <member name="M:Quantum.TriangleMesh.GetNodeCenter(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieve the center of a node at a given cell position.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>The center of the node.</returns>
        </member>
        <member name="M:Quantum.TriangleMesh.GetTriangle(System.Int32)">
            <summary>
            Get the triangle at the specified index.
            </summary>
            <param name="triIndex"></param>
            <returns>A pointer to the triangle at the specified index.</returns>
        </member>
        <member name="M:Quantum.TriangleMesh.ToCell(Photon.Deterministic.FPVector3,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Convert a position to a cell.
            </summary>
            <param name="pos"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Quantum.TriangleMesh.TryGetTriangles(System.Int32,System.Int32,System.Int32,System.Int32*@,System.Int32@)">
            <summary>
            Get all triangles at a given cell position.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="triangles"></param>
            <param name="count"></param>
            <returns><see langword="false"/> if no triangles exist, <see langword="true"/> if triangles are found</returns>
        </member>
        <member name="M:Quantum.TriangleMesh.RemoveMany(Quantum.TriangleReference)">
            <summary>
            This method is Obsolete. Use the overload that receives a FrameBase instance instead.
            <seealso cref="M:Quantum.TriangleMesh.RemoveMany(Quantum.Core.FrameBase,Quantum.TriangleReference)"/>
            </summary>
            <param name="triangle">The triangle reference to remove.</param>
        </member>
        <member name="M:Quantum.TriangleMesh.RemoveMany(Quantum.Core.FrameBase,Quantum.TriangleReference)">
            <summary>
            Obsolete method. Renamed to RemoveMeshCollider, use it instead.
            <seealso cref="M:Quantum.TriangleMesh.RemoveMeshCollider(Quantum.Core.FrameBase,Quantum.TriangleReference)"/>
            </summary>
            <param name="frame">The frame.</param>
            <param name="meshTriReference">The triangle reference to remove.</param>
        </member>
        <member name="M:Quantum.TriangleMesh.RemoveMeshCollider(Quantum.Core.FrameBase,Quantum.TriangleReference)">
            <summary>
            Remove many triangles from the triangle mesh.
            </summary>
            <param name="frame">The frame.</param>
            <param name="meshTriReference">The triangle reference to remove.</param>
        </member>
        <member name="M:Quantum.TriangleMesh.Remove(Quantum.TriangleReference)">
            <summary>
            <see cref="M:Quantum.TriangleMesh.Remove(Quantum.Core.FrameBase,Quantum.TriangleReference)"/>
            This method is Obsolete. Use the overload that receives a FrameBase instance instead.
            </summary>
            <param name="triangle">The triangle reference to remove.</param>
        </member>
        <member name="M:Quantum.TriangleMesh.Remove(Quantum.Core.FrameBase,Quantum.TriangleReference)">
            <summary>
            Obsolete method. Renamed to RemoveTriangle, use it instead.
            </summary>
            <param name="frame">The frame.</param>
            <param name="triangle">The triangle reference to remove.</param>
        </member>
        <member name="M:Quantum.TriangleMesh.RemoveTriangle(Quantum.Core.FrameBase,Quantum.TriangleReference)">
            <summary>
            Remove a singular triangle from the triangle mesh.
            </summary>
            <param name="frame">The frame.</param>
            <param name="triangle">The triangle reference to remove.</param>
        </member>
        <member name="M:Quantum.MeshTriangleVerticesCcw.Create(System.Collections.Generic.IList{Photon.Deterministic.FPVector3},System.Collections.Generic.IList{System.Int32},System.Nullable{Photon.Deterministic.FPMatrix4x4})">
            <summary>
            Creates a new instance of <see cref="T:Quantum.MeshTriangleVerticesCcw"/> from a list of vertices and indices.
            </summary>
            <param name="vertices">The vertices of the mesh collider.</param>
            <param name="indices">The triangle indices of the mesh collider.</param>
            <param name="matrix4X4">The optional matrix to apply to the collider.</param>
            <returns>An instance of <see cref="T:Quantum.MeshTriangleVerticesCcw"/>.</returns>
        </member>
        <member name="T:Quantum.TriangleCCW.VertexHashMapper">
            <summary>
            Uses a <see cref="T:Quantum.ByteSerializerHashMapper`1"/> to more efficiently serialize
            triangles with shared vertices to a <see cref="T:Quantum.ByteStream"/>.
            <example>
            How to serialize:
            <code>
            var sourceTris = new TriangleCCW[42];
            var vertexHashMapper = new VertexHashMapper();
            stream.WriteInt(sourceTris.Length);
            for (int i = 0; i &lt; sourceTris.Length; i++) {
              sourceTris[i].Serialize(stream, write: true, vertexHashMapper);
            }
            </code>
            </example>
            <example>
            How to de-serialize:
            <code>
            var trisCount = stream.ReadInt();
            var destTris = new TriangleCCW[trisCount];
            var vertexHashMapper = new VertexHashMapper();
            for (int i = 0; i &lt; trisCount; i++) {
              destTris[i].Serialize(stream, write: false, vertexHashMapper);
            }
            </code>
            </example>
            </summary>
        </member>
        <member name="F:Quantum.TriangleCCW.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.TriangleCCW.ALIGNMENT">
            <summary>
            Struct alignment in bytes.
            </summary>
        </member>
        <member name="F:Quantum.TriangleCCW.SERIALIZED_SIZE">
            <summary>
            The size of the serialized version of this struct, in bytes.
            </summary>
        </member>
        <member name="T:Quantum.ExitInfo3D">
            <summary>
            Info about two entities that were colliding in the 3D Physics.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo3D"/> for 3D collisions and <see cref="T:Quantum.TriggerInfo3D"/> for 3D trigger collisions.</remarks>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.ExitInfo3D.Entity">
            <summary>
            The main entity that was involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo3D.Other">
            <summary>
            The other entity that was involved in the collision if the <see cref="P:Quantum.ExitInfo3D.Entity"/> was NOT colliding with a static (check <see cref="P:Quantum.ExitInfo3D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.ExitInfo3D.Entity"/> was colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.ExitInfo3D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.ExitInfo3D.Entity"/> was touching a static collider.
            If so, <see cref="P:Quantum.ExitInfo3D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.ExitInfo3D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.ExitInfo3D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.ExitInfo3D.Entity"/> was colliding with a static (check <see cref="P:Quantum.ExitInfo3D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.CollisionInfo3D">
            <summary>
            Info about a collision between two 3D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>See <see cref="T:Quantum.CollisionInfo2D"/> for 2D collisions and <see cref="T:Quantum.TriggerInfo3D"/> for 3D trigger collisions.</remarks>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.CollisionInfo3D.ContactPointIterator3D">
            <summary>
            An iterator over multiple triangles collisions with a given mesh.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactPointIterator3D.Count">
            <summary>
            The number of contact points on this collision.
            <remarks>
            If the entity is colliding with a mesh, this is the sum of all contact points with the triangles of the mesh.
            To access each specific triangle collision, check <see cref="F:Quantum.CollisionInfo3D.MeshTriangleCollisions"/>.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactPointIterator3D.Average">
            <summary>
            The average contact point on this collision.
            <remarks>
            If the entity is colliding with a mesh, this is the average of all contact points with the triangles of the mesh.
            To access each specific triangle collision, check <see cref="F:Quantum.CollisionInfo3D.MeshTriangleCollisions"/>.
            </remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactPointIterator3D.First">
            <summary>
            The first contact point computed on this collision.
            <remarks>Contact points are computed in NO particular order.</remarks>
            <remarks>If the entity is colliding with a mesh, this is the first contact point with the first triangle.</remarks>
            </summary>
        </member>
        <member name="M:Quantum.CollisionInfo3D.ContactPointIterator3D.Next(Photon.Deterministic.FPVector3@)">
            <summary>
            Iterates through the contact points of a collision.
            <remarks>If the entity is colliding with a mesh, this will iterate through all contact points in all colliding triangles.</remarks>
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <returns><see langword="true"/> if there is still a <paramref name="contactPoint"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var cp) {
              Draw.Sphere(cp, FP._0_10);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo3D.ContactPointIterator3D.Next(Photon.Deterministic.FPVector3@,Photon.Deterministic.FPVector3@)">
            <summary>
            Iterates through the contact points of a collision, also accessing the contact normal.
            <remarks>If the entity is colliding with a mesh, this will iterate through all contact points and normals in all colliding triangles.</remarks>
            </summary>
            <param name="contactPoint">The current contact point. Default if the iteration is over.</param>
            <param name="contactNormal">The contact normal. Default if the iteration is over.</param>
            <returns><see langword="true"/> if there is still a <paramref name="contactPoint"/> and <paramref name="contactNormal"/>.</returns>
            <code>
            while(info.ContactPoints.Next(out var contactPoint, out var contactNormal) {
               Draw.Sphere(contactPoint, FP._0_10);
               Draw.Ray(contactPoint, contactNormal);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo3D.ContactPointIterator3D.ResetIterator">
            <summary>
            Resets the iterator.
            </summary>
        </member>
        <member name="T:Quantum.CollisionInfo3D.TriangleCollisionIterator">
            <summary>
            Data regarding a mesh collision, including all the individual triangles.
            </summary>
        </member>
        <member name="M:Quantum.CollisionInfo3D.TriangleCollisionIterator.Next(Quantum.CollisionInfo3D.TriangleCollisionInfo@)">
            <summary>
            Iterates through the triangle collisions with a mesh.
            </summary>
            <param name="current">Information about the current triangle collision on the iteration. Default if the iteration is over.</param>
            <returns><see langword="true"/> if there is still a <paramref name="current"/> triangle collision info.</returns>
            <code>
            while(info.MeshTriangleCollisions.Next(out var triCollision) {
              Draw.Ray(triCollision.Triangle->Center, triCollision.ContactNormal * triCollision.Penetration);
            }
            </code>
        </member>
        <member name="M:Quantum.CollisionInfo3D.TriangleCollisionIterator.ResetIterator">
            <summary>
            Resets the iterator.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionIterator.AverageNormal">
            <summary>
            The average contact normal of all the collisions with the triangles of the mesh.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionIterator.AveragePenetration">
            <summary>
            The average penetration of all the collisions with the triangles of the mesh.
            </summary>
        </member>
        <member name="T:Quantum.CollisionInfo3D.TriangleCollisionInfo">
            <summary>
            Info about the collision with a specific triangle of a mesh.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.IgnoreCollision">
            <summary>
            If this triangle collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="F:Quantum.CollisionInfo3D.TriangleCollisionInfo.ContactPoints">
            <summary>
            Data about the contact points of the triangle collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.Triangle">
            <summary>
            The triangle of the mesh that the entity is colliding with.
            <remarks>This is not a copy but a pointer to the actual triangle data in the scene mesh, do NOT change it.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.ContactNormal">
            <summary>
            The contact normal, from the <see cref="P:Quantum.CollisionInfo3D.Entity"/> perspective.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.Penetration">
            <summary>
            The collision penetration in the <see cref="P:Quantum.CollisionInfo3D.TriangleCollisionInfo.ContactNormal"/> direction.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.IgnoreCollision">
            <summary>
            If the collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="F:Quantum.CollisionInfo3D.ContactPoints">
            <summary>
            Data about the contact points of the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.ContactNormal">
            <summary>
            The contact normal, from the <see cref="P:Quantum.CollisionInfo3D.Entity"/> perspective.
            <remarks>In a mesh collision (<see cref="P:Quantum.CollisionInfo3D.IsMeshCollision"/> <see langword="true"/>), this is the average normal of all triangle collisions in this mesh.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.Penetration">
            <summary>
            The collision penetration in the <see cref="P:Quantum.CollisionInfo3D.ContactNormal"/> direction.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is touching a static collider.
            If so, <see cref="P:Quantum.CollisionInfo3D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.CollisionInfo3D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.CollisionInfo3D.IsMeshCollision">
            <summary>
            If the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is colliding with a static mesh.
            More data about the mesh collision, including individual triangle collisions, can be accessed in <see cref="F:Quantum.CollisionInfo3D.MeshTriangleCollisions"/>.
            </summary>
            <code>
            if (info.IsMeshCollision) {
              while(info.MeshTriangleCollisions.Next(out var triCollision)) {
                Draw.Ray(triCollision.Triangle->Center, triCollision.ContactNormal);
              }
            }
            </code>
        </member>
        <member name="F:Quantum.CollisionInfo3D.MeshTriangleCollisions">
            <summary>
            Additional data regarding a mesh collision, including all the individual triangles.
            To know if this is a mesh collision, check <see cref="P:Quantum.CollisionInfo3D.IsMeshCollision"/>.
            </summary>
            <code>
            if (info.IsMeshCollision) {
              Log.Info($"Average normal: {info.MeshTriangleCollisions.AverageNormal}");
              while(info.MeshTriangleCollisions.Next(out var triCollision)) {
                Draw.Ray(triCollision.Triangle->Center, triCollision.ContactNormal);
              }
            }
            </code>
        </member>
        <member name="P:Quantum.CollisionInfo3D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.CollisionInfo3D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.CollisionInfo3D.IsStatic"/>).
            <remarks>If the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.CollisionInfo3D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> if the <see cref="P:Quantum.CollisionInfo3D.Entity"/> is colliding with a static (check <see cref="P:Quantum.CollisionInfo3D.IsStatic"/>).
            </summary>
        </member>
        <member name="T:Quantum.Shape3D">
            <summary>
            Defines a 3D shape with <see cref="P:Quantum.Shape3D.Type"/> and data disposed in a union-like structure.
            All shapes have a <see cref="F:Quantum.Shape3D.UserTag"/>, <see cref="F:Quantum.Shape3D.BroadRadius"/> and <see cref="F:Quantum.Shape3D.Centroid"/>.
            All non-compound shapes have a <see cref="F:Quantum.Shape3D.LocalTransform"/> and their <see cref="F:Quantum.Shape3D.Centroid"/> always match their local transform position.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.Shape3D.CompoundShape3D">
            <summary>
            A 3D shape type that can reference a group of other 3D shapes (including other compounds, but not Mesh and Terrain shapes).
            Compound shape overlaps and physics colliders with compound shapes are supported.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.CompoundShape3D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.CompoundShape3D.IsPersistent">
            <summary>
            If the buffer of shapes is persistently allocated.
            </summary>
            <remarks>Persistently allocated memory is not disposed automatically. Call <see cref="M:Quantum.Shape3D.CompoundShape3D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)"/> when done using a persistent compound.</remarks>
        </member>
        <member name="P:Quantum.Shape3D.CompoundShape3D.Count">
            <summary>
            The number of shapes in the compound buffer.
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.CompoundShape3D.Capacity">
            <summary>
            The current number of shapes that can be held by the compound buffer.
            </summary>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.CopyFrom(Quantum.Core.FrameBase,Quantum.Shape3D@)">
            <summary>
            Creates a copy of another compound <paramref name="shape"/>'s and any nested compound's buffers.
            The resultant shapes will not share data.
            </summary>
            <remarks>Any existing persistent compounds in this shape's hierarchy are disposed before copying.</remarks>
            <param name="f">The current frame being simulated.</param>
            <param name="shape">The compound shape that will be copied from.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.AddShape(Quantum.Core.FrameBase,Quantum.Shape3D@,System.Boolean)">
            <summary>
            Adds the <paramref name="shape"/> to the compound buffer.
            </summary>
            <remarks>Trying to add a compound shape that holds a buffer already reference in this shape's hierarchy will throw an error in debug mode.</remarks>
            <remarks>Mesh and Terrain shapes cannot be added to a compound shape.</remarks>
            <param name="f">The frame currently being simulated.</param>
            <param name="shape">The shape being added to the compound.</param>
            <param name="updateCompoundMeta">If the compound meta data (e.g. broad radius and centroid) should be automatically updated.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.RemoveShapes(Quantum.Core.FrameBase,System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Removes all shapes in a compound that have a <see cref="F:Quantum.Shape3D.UserTag"/> field matching the specified <paramref name="userTag"/>.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="userTag">
            A tag that specifies a shape or group of shapes.
            Any shape in a compound that has a matching <see cref="F:Quantum.Shape3D.UserTag"/> field will be removed.
            If none is specified, all shapes are removed.
            </param>
            <param name="resetCompoundMeta">If the compound meta data (e.g. broad radius, centroid) should be automatically reset if any shapes are removed.</param>
            <param name="removeFromNested">If shapes should also be removed from any compound shape nested inside this.</param>
            <returns><see langword="true"/> if at least one shape has been removed by this method.</returns>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.GetShapes(Quantum.Core.FrameBase,Quantum.Shape3D*@,System.Int32@)">
            <summary>
            Gets a pointer to the buffer of shapes added to this compound.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="shapesBuffer">A pointer to the buffer of shapes added to this compound. <see langword="null"/> if the compound doesn't have shapes.</param>
            <param name="count">The number of shapes in the <paramref name="shapesBuffer"/>.</param>
            <returns><see langword="true"/> if the buffer has at least one shape</returns>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.ResetCompoundMeta(Quantum.Core.FrameBase)">
            <summary>
            Recomputes the compound shape broad radius, centroid and volume sum (the later is used internally).
            </summary>
            <param name="f">The frame currently being simulated.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.FreePersistent(Quantum.Core.FrameBase,System.Boolean)">
            <summary>
            Dispose any persistently allocated memory for this compound shape.
            </summary>
            <param name="f">The frame currently being simulated.</param>
            <param name="freeNestedPersistent">If nested compound shapes should also have persistent buffers disposed.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.ReserveCapacity(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Ensures that this compound shape capacity can hold at least <paramref name="capacity"/> shapes.
            </summary>
            <param name="f">The current Frame instance</param>
            <param name="capacity">The desired capacity. The resultant capacity can be greater than or equal this value.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.AssertExistingReference(Quantum.Core.FrameBase,Quantum.Ptr)">
            <summary>
            Returns <see langword="true"/> if this compound shape doesn't already reference the <paramref name="ptr"/> in it's hierarchy. 
            </summary>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape3D.CompoundShape3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape3D.CompoundShape3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Shape3D.CompoundShape3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape3D.SphereShape">
            <summary>
            Defines a sphere shape in its local space.
            In order to create a <see cref="T:Quantum.Shape3D"/> of type <see cref="F:Quantum.Shape3DType.Sphere"/>, use <see cref="M:Quantum.Shape3D.CreateSphere(Photon.Deterministic.FP,System.Nullable{Photon.Deterministic.FPVector3})"/>. 
            <seealso cref="T:Quantum.Shape3D"/>
            <seealso cref="T:Quantum.Shape3DType"/>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Shape3D.SphereShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.SphereShape.Radius">
            <summary>
            Value of the radius that defines the sphere.
            </summary>
        </member>
        <member name="T:Quantum.Shape3D.BoxShape">
            <summary>
            Defines a 3D box shape in its local space.
            In order to create a <see cref="T:Quantum.Shape3D"/> of type <see cref="F:Quantum.Shape3DType.Box"/>, use <see cref="M:Quantum.Shape3D.CreateBox(Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPVector3},System.Nullable{Photon.Deterministic.FPQuaternion})"/>. 
            <seealso cref="T:Quantum.Shape3D"/>
            <seealso cref="T:Quantum.Shape3DType"/>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Shape3D.BoxShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.BoxShape.Extents">
            <summary>
            Vector that defines the distance from the box centroid to the furthest point in the
            positive direction of each axis.
            </summary>
        </member>
        <member name="T:Quantum.Shape3D.MeshShape">
            <summary>
            References a static Mesh collider by its index.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Shape3D.MeshShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.MeshShape.MeshIndex">
            <summary>
            Index of the mesh collider in an array or buffer
            </summary>
        </member>
        <member name="T:Quantum.Shape3D.TerrainShape">
            <summary>
            References a static Terrain shape by its <see cref="T:Quantum.TerrainCollider"/> asset.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Shape3D.TerrainShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.TerrainShape.TerrainCollider">
            <summary>
            The <see cref="T:Quantum.AssetRef`1"/> of the <see cref="T:Quantum.TerrainCollider"/> that defines this shape.
            </summary>
        </member>
        <member name="T:Quantum.Shape3D.CapsuleShape">
            <summary>
            Defines a 3D capsule shape in its local space.
            In order to create a <see cref="T:Quantum.Shape3D"/> of type <see cref="F:Quantum.Shape3DType.Capsule"/>, use <see cref="M:Quantum.Shape3D.CreateCapsule(Photon.Deterministic.FP,Photon.Deterministic.FP,System.Nullable{Photon.Deterministic.FPVector3},System.Nullable{Photon.Deterministic.FPQuaternion})"/>. 
            <seealso cref="T:Quantum.Shape3D"/>
            <seealso cref="T:Quantum.Shape3DType"/>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Shape3D.CapsuleShape.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.CapsuleShape.Radius">
            <summary>
            The radius of the capsule's top and bottom semi-spheres.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.CapsuleShape.Extent">
            <summary>
            The distance from the capsule's centroid to the center of the top or bottom semi-sphere.
            <seealso cref="P:Quantum.Shape3D.CapsuleShape.Height"/> 
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.CapsuleShape.Diameter">
            <summary>
            Twice the value of the capsule <see cref="F:Quantum.Shape3D.CapsuleShape.Radius"/>.
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.CapsuleShape.Height">
            <summary>
            The distance from the bottommost to the topmost points in the capsule along its elongated axis.
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.CapsuleShape._broadRadius">
            <summary>
            Obsolete. Use <see cref="F:Quantum.Shape3D.BroadRadius"/> intead.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.UserTag">
            <summary>
            Set a number tag to identify a shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.LocalTransform">
            <summary>
            The offset position and rotation of the shape related to the entity's transform.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.Centroid">
            <summary>
            The offset position of the shape center related to the entity's position.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.Compound">
            <summary>
            The <see cref="T:Quantum.Shape3D.CompoundShape3D"/> in the shape if it's <see cref="T:Quantum.Shape3DType">type</see> of compound.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.BroadRadius">
            <summary>
            The radius of an abstract circle that rounds the shape. Used to check the possibility of collision.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.Mesh">
            <summary>
            The <see cref="T:Quantum.Shape3D.MeshShape"/> in the shape if it's <see cref="T:Quantum.Shape3DType">type</see> of mesh.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.Sphere">
            <summary>
            The <see cref="T:Quantum.Shape3D.SphereShape"/> in the shape if it's <see cref="T:Quantum.Shape3DType">type</see> of sphere.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.Box">
            <summary>
            The <see cref="T:Quantum.Shape3D.BoxShape"/> in the shape if it's <see cref="T:Quantum.Shape3DType">type</see> of box.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.Capsule">
            <summary>
            The <see cref="T:Quantum.Shape3D.CapsuleShape"/> in the shape if it's <see cref="T:Quantum.Shape3DType">type</see> of capsule.
            </summary>
        </member>
        <member name="F:Quantum.Shape3D.Terrain">
            <summary>
            The <see cref="T:Quantum.Shape3D.TerrainShape"/> in the shape if it's <see cref="T:Quantum.Shape3DType">type</see> of terrain.
            </summary>
        </member>
        <member name="P:Quantum.Shape3D.Type">
            <summary>
            Returns the <see cref="T:Quantum.Shape3DType">type</see> of the shape. 
            </summary>
        </member>
        <member name="M:Quantum.Shape3D.CreateSphere(Photon.Deterministic.FP,System.Nullable{Photon.Deterministic.FPVector3})">
            <summary>
            Creates a 3D sphere shape defined by a <paramref name="radius"/>.
            </summary>
            <param name="radius">The radius of the sphere</param>
            <param name="posOffset">The offset of the shape in the <see cref="F:Quantum.Shape3D.LocalTransform"/>.</param>
            <returns>A <see cref="T:Quantum.Shape3D"/> with the setup and type of a <see cref="T:Quantum.Shape3D.SphereShape"/>.</returns>
        </member>
        <member name="M:Quantum.Shape3D.CreateBox(Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPVector3},System.Nullable{Photon.Deterministic.FPQuaternion})">
            <summary>
            Creates a 3D box shape defined by <paramref name="extents"/>.
            </summary>
            <param name="extents">
            The extents of the box, a vector that defines the distance from the box centroid to the furthest point in the
            positive direction of each axis.
            </param>
            <param name="posOffset">The position offset of the shape in the <see cref="F:Quantum.Shape3D.LocalTransform"/>.</param>
            <param name="rotOffset">The rotation offset of the shape in the <see cref="F:Quantum.Shape3D.LocalTransform"/>.</param>
            <returns>A <see cref="T:Quantum.Shape3D"/> with the setup and type of a <see cref="T:Quantum.Shape3D.BoxShape"/>.</returns>
        </member>
        <member name="M:Quantum.Shape3D.CreateCapsule(Photon.Deterministic.FP,Photon.Deterministic.FP,System.Nullable{Photon.Deterministic.FPVector3},System.Nullable{Photon.Deterministic.FPQuaternion})">
            <summary>
            Creates a 3D capsule shape.
            </summary>
            <param name="radius">Radius of the cylinder and semi-spheres that compose the capsule.</param>
            <param name="extent">
            Distance from the center of the capsule to the top of the internal cylinder. This is NOT the capsule Height.
            <para>Height = 2 * (Radius + Extent)</para>
            Extent = (Height / 2) - Radius
            </param>
            <param name="posOffset">Offset of the center of the capsule relative to its collider or query position.</param>
            <param name="rotOffset">Rotation offset of the capsule relative to its collider or query rotation.</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Shape3D.CreatePersistentCompound">
            <summary>
            Creates a compound shape that composed by a group of other 3D shapes (including other compounds).
            </summary>
            <returns>A <see cref="T:Quantum.Shape3D"/> with the setup and type of an <see cref="T:Quantum.Shape3D.CompoundShape3D"/>.</returns>
        </member>
        <member name="M:Quantum.Shape3D.GetLocalSupport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,System.Boolean)">
            <summary>
            Computes a point on the shape which has the highest dot product in a given direction (<paramref name="localDir"/>),
            both in the local space of the shape.
            </summary>
            <param name="f">Current frame.</param>
            <param name="localDir">The direction, in local space, in which to compute the support point.</param>
            <param name="skipNormalize">If the provided direction is already normalized.</param>
            <returns>A point, in the local space of the shape, which has the highest dot product in the given direction.</returns>
        </member>
        <member name="M:Quantum.Shape3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Shape3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Shape3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Shape3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Shape3DConfig">
            <summary>
            The base settings for building a <see cref="T:Quantum.Shape3D"/>.
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Shape3DConfig.ShapeType">
            <summary>
            The <see cref="T:Quantum.Shape3DType">type</see> of the shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.SphereRadius">
            <summary>
            The radius of the sphere.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.CapsuleRadius">
            <summary>
            The radius of the capsule.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.CapsuleHeight">
            <summary>
            The size of the capsule from the top end to the bottom end. 
            </summary>
        </member>
        <member name="P:Quantum.Shape3DConfig.CapsuleExtent">
            <summary>
            The capsule extent is the distance from the center of the capsule to some of the spheres' centers.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.PositionOffset">
            <summary>
            The position offset of the shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.BoxExtents">
            <summary>
            The vector that represents the extents of the box in each axis. 
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.RotationOffset">
            <summary>
            The rotation offset of the shape.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.UserTag">
            <summary>
            The user tag to identify the compound shape during the collision event.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.IsPersistent">
            <summary>
            Means the buffer of shapes is allocated in the memory. It will be free when the component is removed from the entity.
            <remarks>Only persistent compound shapes are supported on the editor.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapes">
            <summary>
            The configuration array of each shape in the compound that will be allocated. 
            </summary>
        </member>
        <member name="M:Quantum.Shape3DConfig.CreateShape(Quantum.Core.FrameBase)">
            <summary>
            Creates a <see cref="T:Quantum.Shape3D"/> using the all the data set in the <see cref="T:Quantum.Shape3DConfig"/>.
            </summary>
            <param name="f">The current frame.</param>
        </member>
        <member name="T:Quantum.Shape3DConfig.CompoundShapeData3D">
            <summary>
            The settings of each shape in the compound of shapes list. 
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.ShapeType">
            <inheritdoc cref="F:Quantum.Shape3DConfig.ShapeType"/>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.SphereRadius">
            <inheritdoc cref="F:Quantum.Shape3DConfig.SphereRadius"/>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.CapsuleRadius">
            <inheritdoc cref="F:Quantum.Shape3DConfig.CapsuleRadius"/>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.CapsuleHeight">
            <inheritdoc cref="F:Quantum.Shape3DConfig.CapsuleHeight"/>
        </member>
        <member name="P:Quantum.Shape3DConfig.CompoundShapeData3D.CapsuleExtent">
            <summary>
            The capsule extent is the distance from the center of the capsule to some of the spheres' centers.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.PositionOffset">
            <inheritdoc cref="F:Quantum.Shape3DConfig.PositionOffset"/>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.BoxExtents">
            <inheritdoc cref="F:Quantum.Shape3DConfig.BoxExtents"/>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.RotationOffset">
            <inheritdoc cref="F:Quantum.Shape3DConfig.RotationOffset"/>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.UserTag">
            <inheritdoc cref="F:Quantum.Shape3DConfig.UserTag"/>
        </member>
        <member name="F:Quantum.Shape3DConfig.CompoundShapeData3D.IsSetFromSourceCollider">
            <summary>
            This means an external collider component from this engine sets this component.
            </summary>
        </member>
        <member name="M:Quantum.Shape3DConfig.CompoundShapeData3D.#ctor(Quantum.Shape3DConfig)">
            <summary>
            Constructor that initializes the instance with the values from a <see cref="T:Quantum.Shape3DConfig"/>.
            </summary>
            <param name="fromConfig">Shape config used as source</param>
        </member>
        <member name="M:Quantum.Shape3DConfig.CompoundShapeData3D.CopyToConfig(Quantum.Shape3DConfig)">
            <summary>
            Copies the current instance's values to a <see cref="T:Quantum.Shape3DConfig"/> instance.
            </summary>
            <param name="dest">Shape config to receive the values</param>
        </member>
        <member name="M:Quantum.Shape3DConfig.CompoundShapeData3D.CreateShape(Quantum.Core.FrameBase)">
            <summary>
            Creates a <see cref="T:Quantum.Shape3D"/> using the all the data set in the <see cref="T:Quantum.Shape3DConfig.CompoundShapeData3D"/>.
            This shape is inserted on the shape buffer of the compound. 
            </summary>
            <param name="f">The frame reference.</param>
        </member>
        <member name="M:Quantum.Shape3DConfig.Copy(Quantum.Shape3DConfig,Quantum.Shape3DConfig)">
            <summary>
            Copies all the shape config values to anothere shape config.
            </summary>
            <param name="from">The shape config that will be copied.</param>
            <param name="to">The shape config that will receive the other values.</param>
            <returns>Returns true if the first argument is different from null.</returns>
        </member>
        <member name="T:Quantum.Shape3DType">
            <summary>
            Defines the geometry used by the <see cref="T:Quantum.Shape3D"/>. 
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="F:Quantum.Shape3DType.None">
            <summary>
            Represents a shape of none of the supported types.
            This is the default shape type and will produce errors if used in a collider or query.
            </summary>
        </member>
        <member name="F:Quantum.Shape3DType.Sphere">
            <summary>
            3D sphere shape
            </summary>
        </member>
        <member name="F:Quantum.Shape3DType.Box">
            <summary>
            3D box shape
            </summary>
        </member>
        <member name="F:Quantum.Shape3DType.Mesh">
            <summary>
            3D mesh shape, convex or concave
            </summary>
        </member>
        <member name="F:Quantum.Shape3DType.Terrain">
            <summary>
            3D terrain shape
            </summary>
        </member>
        <member name="F:Quantum.Shape3DType.Compound">
            <summary>
            3D shape compound of multiple other shapes
            </summary>
        </member>
        <member name="F:Quantum.Shape3DType.Capsule">
            <summary>
            3D capsule shape
            </summary>
        </member>
        <member name="T:Quantum.TriggerInfo3D">
            <summary>
            Info about a collision between a trigger and a non-trigger 3D physics colliders.
            </summary>
            <remarks>The info is taken from the perspective of the entity that has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>No detailed collision data (ContactPoint, ContactNormal and Penetration) is computed for trigger collisions. Use shape queries with the appropriate query options selected as an option.</remarks>
            <remarks>See <see cref="T:Quantum.TriggerInfo2D"/> for 2D trigger collisions and <see cref="T:Quantum.CollisionInfo3D"/> for 3D non-trigger collisions.</remarks>
            \ingroup Physics3dApi
        </member>
        <member name="P:Quantum.TriggerInfo3D.IgnoreTrigger">
            <summary>
            If the collision should be ignored by the physics engine.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo3D.IsStatic">
            <summary>
            If the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is touching a static trigger collider.
            If so, <see cref="P:Quantum.TriggerInfo3D.Other"/> has an <see cref="P:Quantum.EntityRef.None"/> value and the static collider data can be accessed through <see cref="P:Quantum.TriggerInfo3D.StaticData"/>.
            </summary>
            <code>
            if (info.IsStatic) {
              var otherStaticData = info.StaticData;
            } else {
              var otherEntity = info.Other;
            }
            </code>
        </member>
        <member name="P:Quantum.TriggerInfo3D.Entity">
            <summary>
            The main entity involved in the collision.
            </summary>
            <remarks>The info is taken from the perspective of this entity, which has subscribed to the callback with <see cref="M:Quantum.Physics3D.PhysicsEngine3D.SetCallbacks(Quantum.Core.FrameBase,Quantum.EntityRef,Quantum.CallbackFlags)"/>.</remarks>
            <remarks>If both entities involved in a collision have subscribed to this collision type callback, it will be called twice, each time carrying information from the perspective of one of the entities.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo3D.EntityShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the entity's shape involved in the collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo3D.Other">
            <summary>
            The other entity involved in the collision if the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is NOT colliding with a static (check <see cref="P:Quantum.TriggerInfo3D.IsStatic"/>).
            </summary>
            <remarks>If the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is colliding with a static, Other has <see cref="P:Quantum.EntityRef.None"/> value.</remarks>
        </member>
        <member name="P:Quantum.TriggerInfo3D.OtherShapeUserTag">
            <summary>
            The <see cref="F:Quantum.Shape3D.UserTag"/> of the other entity's shape involved in the collision.
            Returns default value if the this is a static collision.
            </summary>
        </member>
        <member name="P:Quantum.TriggerInfo3D.StaticData">
            <summary>
            The <see cref="T:Quantum.StaticColliderData"/> of the static collider if the <see cref="P:Quantum.TriggerInfo3D.Entity"/> is colliding with a static (check <see cref="P:Quantum.TriggerInfo3D.IsStatic"/>).
            </summary>
        </member>
        <member name="F:Quantum.CCDSettings.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="M:Quantum.CCDSettings.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.CCDSettings.Serialize(Quantum.CCDSettings*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.CCDSettings"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.CCDSettings"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="F:Quantum.GJKSettings.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="M:Quantum.GJKSettings.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.GJKSettings.Serialize(Quantum.GJKSettings*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.GJKSettings"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.GJKSettings"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.PhysicsCommon">
            \defgroup PhysicsCommonApi Physics Common API
            \brief Groups the Physics types that are relevant for both 2D and 3D physics engines.
        </member>
        <member name="T:Quantum.PhysicsCommon.ConstraintsSolverType">
            <summary>
            Defines which solver algorithm should be used by the physics engine when
            solving velocity and position constraints.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.ConstraintsSolverType.HybridJacobiGaussSeidel">
            <summary>
            Default solver, introduced on v2.1, and has an improved parallelization relative to
            the legacy Gauss-Seidel solver used on v2.0. It is expected to have a better performance if
            the simulation is running in multiple threads. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.ConstraintsSolverType.LegacyGaussSeidel">
            <summary>
            Legacy solver from v2.0.
            This Gauss-Seidel solver is expected to have a better performance than the HJGS if
            the simulation is running in a single thread.
            </summary>
        </member>
        <member name="T:Quantum.PhysicsCommon.PhysicsNativeLib">
            <summary>
            Defines if the physics simulation should to use native compiled libraries for supported platforms. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.PhysicsNativeLib.Disabled">
            <summary>
            Disable the use of native physics libraries by the physics systems.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.PhysicsNativeLib.Auto">
            <summary>
            Enable the use of native physics libraries by the physics systems on the supported platforms.
            </summary>
        </member>
        <member name="T:Quantum.PhysicsCommon.Config">
            <summary>
            Global physics settings which are part of the <see cref="!:SimulationConfig"/>.
            </summary>
            \ingroup PhysicsCommonApi
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.Gravity">
            <summary>
            Define the gravity of the physics simulation. For a 2D world set the y-component to zero. Default is (0, -10, 0).
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SolverType">
            <summary>
            Defines which solver algorithm will be used by the Physics Engines.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.UsePhysicsNativeLib">
            <summary>
            Obsolete option that enable the use of native physics libraries. The property has no function for SDK 3.0.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SolverIterations">
            <summary>
            The physics collision solver runs in sub-steps to improve quality. Default is 4.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.PositionSolverIterations">
            <summary>
            The physics position constraint solver (used on Joint, for instance) runs in sub-steps to improve quality. Default is 2.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.UseJoints">
            <summary>
            Enable the use of joints in the physics engines. If joints are not used, this can be disabled to reduce overhead. Default is <see langword="true"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.UseAngularVelocity">
            <summary>
            Lock the angular velocity for dynamic bodies. Disabling this option leads not only to faster but also to more stable physics simulation for games that can use it. Default is <see langword="true"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.UseVerticalTransform">
            <summary>
            Toggle the use of a vertical transform component for 2.5D worlds that have a simplified concept of height. Default is <see langword="true"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.PenetrationAllowance">
            <summary>
            Allow a certain degree of penetration to improve the stability of the physics simulation. Default is 0.01.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.PenetrationCorrection">
            <summary>
            How much of the exceeding penetration (above allowance) should be corrected in a single frame. 0 = no correction, 1 = full correction. Default is 0.5.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MinLinearIntegration">
            <summary>
            A physics body's linear velocity component (x, y or z, the latter only in the 3D Physics) is rounded to 0 if its absolute value is smaller than this minimum linear integration.
            A small amount can increase the physics simulation stability and improve sleep detection. Default is 0.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MinAngularIntegration">
            <summary>
            A physics body's angular velocity component (x, y or z in the 3D Physics and the amount relative to the vertical axis in the 2D Physics) is rounded to 0 if its absolute value is smaller than this minimum angular integration.
            A small amount can increase the physics simulation stability and improve sleep detection. Default is 0.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MinContactInverseMass">
            <summary>
            When Physics Bodies have a very large Mass or Inertia, the inverse value of the perceived mass in contact points as computed by the Physics Solver might get very small and close to zero.
            Under such conditions, rounding errors become very significant and this can often be translated into impulse spikes.
            This setting functions as a minimum threshold to this inverse mass value, below which the value is clamped. Set to 0 to never clamp.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SimplexMinBitShift">
            <summary>
            Scales the GJK Voronoy Simplex space by shifting points' raw values. Consider increasing if working with small-scaled shapes. Default is 0.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SimplexMaxBitShift">
            <summary>
            The GJK Voronoy Simplex space is scaled by progressively by shifting points' raw values up to this max value when the current instance becomes affine dependent, avoiding degenerate cases due to limited precision. Default is 2.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.ShapeCastMaxIterations">
            <summary>
            The max number of iterations performed by the GJK algorithm while searching for a solution below <see cref="F:Quantum.PhysicsCommon.Config.ShapeCastHardTolerance"/>. Default is 16.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.ShapeCastMinIterations">
            <summary>
            The minimum number of iterations performed by the GJK algorithm if the <see cref="F:Quantum.QueryOptions.ComputeDetailedInfo"/> query option is enabled. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.ShapeCastHardTolerance">
            <summary>
            A GJK iteration result below this threshold is acceptable as a finishing condition.
            In general, increasing the hard tolerance decreases the accuracy of the result, but reduces computational cost by requiring less iterations. Default is 0.01.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.ShapeCastSoftTolerance">
            <summary>
            A GJK resolution that fails to find an acceptable result below <see cref="F:Quantum.PhysicsCommon.Config.ShapeCastHardTolerance"/> after <see cref="F:Quantum.PhysicsCommon.Config.ShapeCastMaxIterations"/>
            will still return positive if the best solution found is below this soft threshold. Default is 0.05.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.AllowSleeping">
            <summary>
            Toggles the detection of physics bodies in a sleeping state.
            If allowed, the simulation will skip forces and velocity integrations and collisions detection on physics bodies while they are asleep. Default is <see langword="false"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.SleepTimeSec">
            <summary>
            For how many seconds a physics body should stay under the linear and angular velocity sleeping thresholds before being put in a sleeping state. Default is 0.5.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.LinearSleepTolerance">
            <summary>
            Amount of linear velocity below which a physics body might be considered as standing still for sleeping detection. Default is 0.02.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.AngularSleepToleranceInRad">
            <summary>
            Amount of angular velocity below which a physics body might be considered as standing still for sleeping detection.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.AllowCCD">
            <summary>
            Allows CCD to be performed if the Physics Body has CCD enabled on its Config flags. Default is <see langword="false"/>.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.CCDLinearVelocityThreshold">
            <summary>
            If CCD is allowed, it will be performed on all Physics Bodies that have it enabled and have a linear velocity magnitude above this threshold. Default is 3.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.CCDAngularVelocityThreshold">
            <summary>
            If CCD is allowed, it will be performed on all Physics Bodies that have it enabled and have a angular velocity magnitude above this threshold. Default is 3.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.CCDDistanceTolerance">
            <summary>
            The absolute distance value below which the Physics Bodies under CCD check can be considered as touching. Default is 0.001.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MaxTimeOfImpactIterations">
            <summary>
            The maximum number of iterations performed by the CCD algorithm when computing the time of impact between two Physics Bodies. Default is 16.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.MaxRootFindingIterations">
            <summary>
            The maximum number of iterations performed when computing the point in time when the distance between two Physics Bodies in a given separation axis is below the tolerance. Default is 32.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultEntriesCapacity">
            <summary>
            The initial number of supported entities when a scene is initialized. Memory for more entities will be allocated if necessary. The smallest value is 32. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultStaticsCapacity">
            <summary>
            The initial number of supported static entities when a scene is initialized. Memory for more entities will be allocated if necessary. The smallest value is 64. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultQueriesCapacity">
            <summary>
            The initial number of supported broad-phase queries per frame when a scene is initialized. Memory for more queries will be allocated if necessary. The smallest value is 64. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultQueryItemsCapacity">
            <summary>
            The initial number of query manifolds for collision interactions per bucket when a scene is initialized. Memory for more manifolds will be allocated if necessary. The default value is 1024.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultHitCollectionItemsCapacity">
            <summary>
            The initial number of memory allocated for items in the <see cref="T:Quantum.Physics3D.HitCollection3D"/>. The default value is 32. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultBucketsCapacity">
            <summary>
            The initial amount of buckets used in the physics broad phase to solve collisions in parallel. Use a reasonable amount according to how many colliders you have. The default value is 16. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultIslandsCapacity">
            <summary>
            The default number of islands of entities that are in contact in the physics update. Memory for more islands will be allocated if necessary. The smallest  value is 16. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultManifoldsCapacity">
            <summary>
            The initial number of manifolds for collision interactions per bucket when a scene is initialized. Memory for more manifolds will be allocated if necessary. The default value is 1024.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultJointsCapacity">
            <summary>
            The initial number of supported joints when a scene is initialized. Memory for more joints will be allocated if necessary. The default value is 128. 
            This value can be set to 0 if not using Joints. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultPhysicsMaterial">
            <summary>
            The default <see cref="T:Quantum.PhysicsMaterial"/> asset used when initializing a 2D or 3D physics collider component with no other material specified
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultCharacterController2D">
            <summary>
            The default <see cref="T:Quantum.CharacterController2DConfig"/> asset used when initializing a CharacterController2D component with no other config specified
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.DefaultCharacterController3D">
            <summary>
            The default <see cref="T:Quantum.CharacterController3DConfig"/> asset used when initializing a CharacterController3D component with no other config specified
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.Layers">
            <summary>
            The collision layer names recognized by the Quantum simulation. Can be imported from Unity layers on the editor.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.Config.LayerMatrix">
            <summary>
            The collision matrix of the layers recognized by the Quantum simulation. Can be imported from Unity's layer matrix on the editor.
            </summary>
        </member>
        <member name="T:Quantum.PhysicsCommon.StaticColliderMutableMode">
            <summary>
            Defines if the static collider can be toggled on and off at runtime.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.StaticColliderMutableMode.Immutable">
            <summary>The collider cannot be enabled or disabled at runtime.</summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.StaticColliderMutableMode.ToggleableStartOn">
            <summary>The collider can be toggled at runtime and starts enabled.</summary>
        </member>
        <member name="F:Quantum.PhysicsCommon.StaticColliderMutableMode.ToggleableStartOff">
            <summary>The collider can be toggled at runtime and starts disabled.</summary>
        </member>
        <member name="T:Quantum.PhysicsCommon.BucketAxis">
            <summary>
            The world axis setting for divide the physics entries in different buckets. 
            </summary>
        </member>
        <member name="T:Quantum.PhysicsCommon.SortAxis">
            <summary>
            The sorting axis for the queries in a bucket that are sorted according to their position.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsCommon.StaticCollidersState.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.PhysicsCommon.StaticCollidersState.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsCommon.StaticCollidersState"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsCommon.StaticCollidersState"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.PhysicsCommon.UnsafeBuffer.Iterator`1.MoveNext">
            <summary>
            Moves to the next entry.
            </summary>
            <returns><see langword="true"/> if there is a next element.</returns>
        </member>
        <member name="M:Quantum.PhysicsCommon.UnsafeBuffer.Iterator`1.Reset">
            <summary>
            Resets the iterator to its original state.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCommon.UnsafeBuffer.Iterator`1.CurrentUnsafe">
            <summary>
            A pointer to the current entry being iterated.
            This allows modifications to the element in the actual buffer.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCommon.UnsafeBuffer.Iterator`1.Current">
            <summary>
            A copy of the current entry being iterated.
            To modify the actual element in the buffer, use <see cref="P:Quantum.PhysicsCommon.UnsafeBuffer.Iterator`1.CurrentUnsafe"/>.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCommon.UnsafeBuffer.Iterator`1.CurrentIndex">
            <summary>
            The index on the buffer of the element currently being iterated.
            The index is out of the valid range if the iterator has just been created on <see cref="M:Quantum.PhysicsCommon.UnsafeBuffer.Iterator`1.Reset"/>.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsCommon.UnsafePointerBuffer`1.Iterator.MoveNext">
            <summary>
            Moves to the next entry.
            </summary>
            <returns><see langword="true"/> if there is a next element.</returns>
        </member>
        <member name="M:Quantum.PhysicsCommon.UnsafePointerBuffer`1.Iterator.Reset">
            <summary>
            Resets the iterator to its original state.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCommon.UnsafePointerBuffer`1.Iterator.CurrentUnsafe">
            <summary>
            A pointer to the current entry being iterated.
            This allows modifications to the element in the actual buffer.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCommon.UnsafePointerBuffer`1.Iterator.Current">
            <summary>
            A copy of the current entry being iterated.
            To modify the actual element in the buffer, use <see cref="P:Quantum.PhysicsCommon.UnsafePointerBuffer`1.Iterator.CurrentUnsafe"/>.
            </summary>
        </member>
        <member name="P:Quantum.PhysicsCommon.UnsafePointerBuffer`1.Iterator.CurrentIndex">
            <summary>
            The index on the buffer of the element currently being iterated.
            The index is out of the valid range if the iterator has just been created on <see cref="M:Quantum.PhysicsCommon.UnsafePointerBuffer`1.Iterator.Reset"/>.
            </summary>
        </member>
        <member name="T:Quantum.CallbackFlags">
            <summary>
            Represents which collision callbacks will be called for an entity.
            <remarks>By default, no callbacks are called unless at least one of the entities involved in a collision have the respective flag set.</remarks>
            <remarks>The callbacks are called for every entity involved in a collision that has the respective collision type flag set.</remarks>
            </summary>
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
        </member>
        <member name="F:Quantum.CallbackFlags.None">
            <summary>
            Set None to stop receiving callbacks for an entity.
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicCollision">
            <summary>
            Called once per frame while two non-trigger colliders are touching.
            <remarks>Related signals: <see cref="!:ISignalOnCollision2D"/> and <see cref="!:ISignalOnCollision3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicCollisionEnter">
            <summary>
            Called once two non-trigger colliders start touching.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionEnter2D"/> and <see cref="!:ISignalOnCollisionEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicCollisionExit">
            <summary>
            Called once two non-trigger colliders stop touching.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionExit2D"/> and <see cref="!:ISignalOnCollisionExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticCollision">
            <summary>
            Called once per frame while a non-trigger collider is touching a non-trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnCollision2D"/> and <see cref="!:ISignalOnCollision3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticCollisionEnter">
            <summary>
            Called once a non-trigger collider start touching a non-trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionEnter2D"/> and <see cref="!:ISignalOnCollisionEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticCollisionExit">
            <summary>
            Called once a non-trigger collider stop touching a non-trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnCollisionExit2D"/> and <see cref="!:ISignalOnCollisionExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicTrigger">
            <summary>
            Called once per frame while a trigger collider is touching a non-trigger collider.
            <remarks>Related signals: <see cref="!:ISignalOnTrigger2D"/> and <see cref="!:ISignalOnTrigger3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicTriggerEnter">
            <summary>
            Called once a trigger collider start touching a non-trigger collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerEnter2D"/> and <see cref="!:ISignalOnTriggerEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnDynamicTriggerExit">
            <summary>
            Called once a trigger collider stop touching a non-trigger collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerExit2D"/> and <see cref="!:ISignalOnTriggerExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticTrigger">
            <summary>
            Called once per frame while a non-trigger collider is touching a trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnTrigger2D"/> and <see cref="!:ISignalOnTrigger3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticTriggerEnter">
            <summary>
            Called once a non-trigger collider start touching a trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerEnter2D"/> and <see cref="!:ISignalOnTriggerEnter3D"/>.</remarks>
            </summary>
        </member>
        <member name="F:Quantum.CallbackFlags.OnStaticTriggerExit">
            <summary>
            Called once a non-trigger collider stop touching a trigger static collider.
            <remarks>Related signals: <see cref="!:ISignalOnTriggerExit2D"/> and <see cref="!:ISignalOnTriggerExit3D"/>.</remarks>
            </summary>
        </member>
        <member name="T:Quantum.QueryOptions">
            <summary>
            The flags to set up which type of colliders the query should hit and how detailed the collision should be.
            </summary>
        </member>
        <member name="F:Quantum.QueryOptions.HitStatics">
            <summary>
             The query checks static colliders.
             Include also <see cref="F:Quantum.QueryOptions.HitTriggers"/> in order to check static trigger colliders.
             </summary>
        </member>
        <member name="F:Quantum.QueryOptions.HitKinematics">
            <summary>
            The query checks colliders with no physics body or with Kinematic physics body.
            Include also <see cref="F:Quantum.QueryOptions.HitTriggers"/> in order to check trigger colliders.
            </summary>
        </member>
        <member name="F:Quantum.QueryOptions.HitDynamics">
            <summary>
            The query checks colliders with dynamic (not kinematic) physics body.
            </summary>
        </member>
        <member name="F:Quantum.QueryOptions.HitTriggers">
            <summary>
            The query also checks trigger colliders.
            Combine this with both or either <see cref="F:Quantum.QueryOptions.HitStatics"/> and/or <see cref="F:Quantum.QueryOptions.HitKinematics"/>.
            </summary>
        </member>
        <member name="F:Quantum.QueryOptions.HitAll">
            <summary>
            The query checks all colliders: statics, kinematics and dynamics, including trigger colliders.
            To filter some of these options out, combine specific flags instead.
            </summary>
        </member>
        <member name="F:Quantum.QueryOptions.HitSolids">
            <summary>
            The query checks all non-trigger colliders: statics, kinematics and dynamics.
            </summary>
        </member>
        <member name="F:Quantum.QueryOptions.ComputeDetailedInfo">
            <summary>
            Detailed info (e.g. contact point, normal, penetration) will be computed for the query hits.
            </summary>
        </member>
        <member name="F:Quantum.QueryOptions.DetectOverlapsAtCastOrigin">
            <summary>
            For Ray and Shape casts, the query will consider other colliders that may be overlapping with the cast
            feature at the cast origin. By default, such overlaps are not considered hits.
            </summary>
        </member>
        <member name="T:Quantum.CharacterMovementType">
            <summary>
            The state of the character movement. It is updated internally by the character controller system.
            </summary>
        </member>
        <member name="F:Quantum.CharacterMovementType.None">
            <summary>Grounded with no desired direction passed.</summary>
        </member>
        <member name="F:Quantum.CharacterMovementType.FreeFall">
            <summary>There is no contacts within the Radius.</summary>
        </member>
        <member name="F:Quantum.CharacterMovementType.SlopeFall">
            <summary>
            There is at least 1 ground contact within the radius, specifically a contact with a normal angle vs -gravity &lt; maxSlopeAngle). 
            It is possible to be "grounded" without this type of contact <see cref="F:Quantum.CharacterController3DMovement.Grounded"/>
            </summary>
        </member>
        <member name="F:Quantum.CharacterMovementType.Horizontal">
            <summary>there is no ground contact, but there is at least one lateral contact.</summary>
        </member>
        <member name="T:Quantum.PhysicsCombineFunction">
            <summary>
            Defines how the properties of the collider will be combined and affect the collision resolution.
            The Physics system will chose the function with the highest precedent from the two colliders. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsCombineFunction.Max">
            <summary>The max value between the two values.</summary>
        </member>
        <member name="F:Quantum.PhysicsCombineFunction.Min">
            <summary>The min value between the two values.</summary>
        </member>
        <member name="F:Quantum.PhysicsCombineFunction.Average">
            <summary>The average value between the two values.</summary>
        </member>
        <member name="F:Quantum.PhysicsCombineFunction.Multiply">
            <summary>The multiplication of the two values.</summary>
        </member>
        <member name="T:Quantum.PhysicsMaterialData">
            <summary>
            Defines the settings for a physics body to resolve its collision when it is touching another body.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterialData.SIZE">
            <summary>
            Represents the size of a variable in bytes.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterialData.RestitutionCombineFunction">
            <summary>
            Define how the physics system calculates restitution for two physics bodies, based on each collider's restitution.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterialData.FrictionCombineFunction">
            <summary>
            Define how the physics system calculates friction between two physics bodies, based on each colliders friction. 
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterialData.Restitution">
            <summary>
            Defines how much movement is restituted after a collision solver. It can be used to apply a bounciness behavior to the physics body.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterialData.FrictionStatic">
            <summary>
            How much friction the collider has against another collider when they are moving and touching each other.
            </summary>
        </member>
        <member name="F:Quantum.PhysicsMaterialData.FrictionDynamic">
            <summary>
            How much friction the collider has against another collider when they are not moving. 
            </summary>
        </member>
        <member name="M:Quantum.PhysicsMaterialData.GetDefaultPhysicsMaterialData">
            <summary>
            Returns a <see cref="T:Quantum.PhysicsMaterialData"/> with default values. The restituition is 0 and the friction is 0.6.
            The default combination mode is the <see cref="F:Quantum.PhysicsCombineFunction.Average"/> for all functions.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsMaterialData.#ctor(Photon.Deterministic.FP,Quantum.PhysicsCombineFunction,Photon.Deterministic.FP,Photon.Deterministic.FP,Quantum.PhysicsCombineFunction)">
            <summary>
            Creates a physics material data with custom values.
            </summary>
            <param name="restitution">How much movement should be restituted after the collision resolution.</param>
            <param name="restitutionCombine">The combination mode for the restituition between two colliders.</param>
            <param name="frictionStatic">How much friction applied against two colliders in movement.</param>
            <param name="frictionDynamic">How much friction applied against two stopped colliders.</param>
            <param name="frictionCombine">The combination mode for the friction between two bodies.</param>
        </member>
        <member name="F:Quantum.PhysicsSceneSettings.SIZE">
            <summary>
            The size of the struct in bytes.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsSceneSettings.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.PhysicsSceneSettings.Serialize(Quantum.PhysicsSceneSettings*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsSceneSettings"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsSceneSettings"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.PhysicsQueryRef.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.PhysicsQueryRef.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsQueryRef"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsQueryRef"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.PhysicsEngineState.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="M:Quantum.PhysicsEngineState.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.PhysicsEngineState"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.PhysicsEngineState"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.Profiling.HostProfiler">
            <summary>
            Provides profiling functionality for the host. It used to measure different parts of the engine compared to <see cref="T:Quantum.Profiling.Profiler"/>, which
            in turn is used to measure the performance at finer granularity.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.Init(Quantum.Profiling.IHostProfiler)">
            <summary>
            Initializes the host profiler with the specified host profiler.
            </summary>
            <param name="hostProfiler"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.Reset">
            <summary>
            Resets the host profiler by clearing all the profiling actions.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.Start(System.String)">
            <summary>
            Starts profiling for a specific sample.
            </summary>
            <param name="sample">The name of the sample.</param>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.End">
            <summary>
            Ends profiling for the current sample. Consider using <see cref="T:Quantum.Profiling.HostProfilerNamedMarkerScope"/> returned by <see cref="M:Quantum.Profiling.HostProfiler.Start(System.String)"/> instead of calling this method directly.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.CreateMarker(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.Init(System.Action{System.String},System.Action)">
            <summary>
            Initializes the host profiler with the specified start and end actions.
            </summary>
            <param name="start">The action to be executed when a profiler section starts.</param>
            <param name="end">The action to be executed when a profiler section ends.</param>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.InitThread(System.Action{System.String,System.String},System.Action)">
            <summary>
            Initializes the host profiler with the specified start and end actions for thread profiling.
            </summary>
            <param name="start">The action to be executed when a profiler section in a named thread starts.</param>
            <param name="end">The action to be executed when a profiler section in a named thread ends.</param>
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.StartDebug(System.String)">
            <inheritdoc cref="M:Quantum.Profiling.HostProfiler.Start(System.String)" />
        </member>
        <member name="M:Quantum.Profiling.HostProfiler.EndDebug">
            <inheritdoc cref="M:Quantum.Profiling.HostProfiler.End" />
        </member>
        <member name="T:Quantum.Profiling.HostProfilerMarker">
            <summary>
            Pre-defined marker for the host profiler. 
            </summary>
            <param name="rawValue"></param>
        </member>
        <member name="M:Quantum.Profiling.HostProfilerMarker.#ctor(System.IntPtr)">
            <summary>
            Pre-defined marker for the host profiler. 
            </summary>
            <param name="rawValue"></param>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarker.RawValue">
            <summary>
            Raw value of the marker. Implementation-defined.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.HostProfilerMarker.IsValid">
            <summary>
            Checks if the marker is valid.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.HostProfilerMarker.Start">
            <summary>
            Begins profiling for the marker. Call <see cref="M:Quantum.Profiling.HostProfilerMarkerScope.Dispose"/> to end profiling.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.Profiling.HostProfilerMarker.End">
            <summary>
            Ends profiling for the marker. Consider using <see cref="T:Quantum.Profiling.HostProfilerMarkerScope"/> returned by <see cref="M:Quantum.Profiling.HostProfilerMarker.Start"/> instead of calling this method directly.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.HostProfilerMarkers">
            <summary>
            Provides a collection of pre-defined markers for the host profiler.
            </summary>
            <param name="profiler"></param>
        </member>
        <member name="M:Quantum.Profiling.HostProfilerMarkers.#ctor(Quantum.Profiling.IHostProfiler)">
            <summary>
            Provides a collection of pre-defined markers for the host profiler.
            </summary>
            <param name="profiler"></param>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.CopyEntityInfo">
            <summary>
            Marker for Copy Entity Info.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.CopyComponentData">
            <summary>
            Marker for Copy Component Data.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.DynamicDBCopyFromIncrementAll">
            <summary>
            Marker for DynamicAssetDB.CopyFrom.IncrementAll.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.DynamicDBCopyFromDisposeAll">
            <summary>
            Marker for DynamicAssetDB.CopyFrom.DisposeAll.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.TaskContextEndFrame">
            <summary>
            Marker for Quantum.TaskContext.EndFrame.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.TaskContextPrepareTaskGraph">
            <summary>
            Marker for Prepare Task Graph.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.TaskContextScheduleTaskRunner">
            <summary>
            Marker for Schedule Task Runner.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.TaskContextTaskExecuteGraph">
            <summary>
            Marker for WorkerThread.TaskExecuteGraph.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.CalculateChecksumInternal">
            <summary>
            Marker for CalculateChecksumInternal.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.FrameCopy">
            <summary>
            Marker for Frame Copy.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.FrameCopyHeap">
            <summary>
            Marker for Copy Heap.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.FrameCopyGlobals">
            <summary>
            Marker for Copy Globals.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.FrameCopyUser">
            <summary>
            Marker for Copy User.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.InvokeEvents">
            <summary>
            Marker for QuantumGame.InvokeEvents.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.RaiseEvent">
            <summary>
            Marker for QuantumGame.RaiseEvent.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.RecordingSnapshots">
            <summary>
            Marker for QuantumGame.RecordingSnapshots.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.OnSimulate">
            <summary>
            Marker for QuantumGame.OnSimulate.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.OnSimulateInitProfiler">
            <summary>
            Marker for Init Profiler.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.OnSimulateApplyInputs">
            <summary>
            Marker for ApplyInputs.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.OnSimulateBegin">
            <summary>
            Marker for OnSimulateBegin.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.OnSimulateUpdatePlayerData">
            <summary>
            Marker for UpdatePlayerData.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.OnSimulateSchedulingTasks">
            <summary>
            Marker for Scheduling Tasks.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.InvokeOnChecksumErrorFrameDump">
            <summary>
            Marker for QuantumGame.InvokeOnChecksumErrorFrameDump.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.InvokeOnUpdateView">
            <summary>
            Marker for QuantumGame.InvokeOnUpdateView.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.InvokeOnSimulateFinished">
            <summary>
            Marker for QuantumGame.InvokeOnSimulateFinished.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.HostProfilerMarkers.InvokeOnEvent">
            <summary>
            Marker for QuantumGame.InvokeOnEvent.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.HostProfilerMarkerScope">
            <summary>
            Provides a scope for a host profiler marker. Do not use this struct directly, use <see cref="M:Quantum.Profiling.HostProfilerMarker.Start"/> instead.
            </summary>
            <param name="marker"></param>
        </member>
        <member name="M:Quantum.Profiling.HostProfilerMarkerScope.#ctor(Quantum.Profiling.HostProfilerMarker)">
            <summary>
            Provides a scope for a host profiler marker. Do not use this struct directly, use <see cref="M:Quantum.Profiling.HostProfilerMarker.Start"/> instead.
            </summary>
            <param name="marker"></param>
        </member>
        <member name="M:Quantum.Profiling.HostProfilerMarkerScope.Dispose">
            <summary>
            Stops profiling for the marker.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.IHostProfiler">
            <summary>
            Interface for the host profiler.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.IHostProfiler.CreateMarker(System.String)">
            <summary>
            Creates a new marker with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Profiling.IHostProfiler.StartMarker(Quantum.Profiling.HostProfilerMarker)">
            <summary>
            Starts profiling for the specified marker.
            </summary>
            <param name="marker"></param>
        </member>
        <member name="M:Quantum.Profiling.IHostProfiler.EndMarker(Quantum.Profiling.HostProfilerMarker)">
            <summary>
            Stops profiling for the specified marker.
            </summary>
            <param name="marker"></param>
        </member>
        <member name="M:Quantum.Profiling.IHostProfiler.StartNamedMarker(System.String)">
            <summary>
            Starts profiling for the specified named marker. Use <see cref="M:Quantum.Profiling.IHostProfiler.EndLastNamedMarker"/> to stop profiling.
            </summary>
            <param name="markerName"></param>
        </member>
        <member name="M:Quantum.Profiling.IHostProfiler.EndLastNamedMarker">
            <summary>
            Ends profiling for the last named marker.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.Profiler">
            <summary>
            Represents a profiler that can be used for performance profiling.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.Profiler.IsValid">
            <summary>
            Gets a value indicating whether the profiler is valid. If the returned value is <see langword="false"/>, all profiler calls will be no-ops.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.Profiler.Event(System.String)">
            <summary>
            Records an event with the specified name. Events are used to mark specific points in time and do not have a duration.
            </summary>
            <param name="name">The name of the event.</param>
        </member>
        <member name="M:Quantum.Profiling.Profiler.Start(System.String)">
            <summary>
            Starts a profiling section with the specified name.
            </summary>
            <param name="name">The name of the profiling section.</param>
        </member>
        <member name="M:Quantum.Profiling.Profiler.End">
            <summary>
            Ends the current profiling section.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.Profiler.Reset">
            <summary>
            Resets the profiler.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.Profiler.Scope(System.String)">
            <summary>
            Creates a new profiler scope with the specified name.
            </summary>
            <param name="name">The name of the profiler scope.</param>
            <returns>A new instance of the <see cref="T:Quantum.Profiling.Profiler.ProfilerScope"/> struct.</returns>
        </member>
        <member name="T:Quantum.Profiling.Profiler.ProfilerScope">
            <summary>
            Represents a disposable profiler scope that automatically starts and ends a profiling section.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.Profiler.ProfilerScope.Dispose">
            <summary>
            Ends the profiling section.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.ProfilerContext">
            <summary>
            Represents a profiler context that manages profiling data.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.Profiling.ProfilerContext"/> class.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.GetFrameTimeAverage">
            <summary>
            Gets the average frame time.
            </summary>
            <returns>The average frame time.</returns>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.SimulationBegin">
            <summary>
            Begins a simulation.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.Reset(System.Boolean)">
            <summary>
            Resets the profiler context.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.StoreFrameTime">
            <summary>
            Stores the frame time.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.TicksToMS(System.Int64)">
            <summary>
            Converts ticks to milliseconds.
            </summary>
            <param name="ticks">The number of ticks.</param>
            <returns>The equivalent time in milliseconds.</returns>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.CreateReport(System.Int32,System.Boolean)">
            <summary>
            Creates a profiler context report.
            </summary>
            <param name="frame">The frame number.</param>
            <param name="isVerified">Indicates whether the report is verified.</param>
            <returns>The profiler context report.</returns>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.GetProfilerForTaskThread(System.Int32)">
            <summary>
            Gets the profiler for the specified task thread index.
            </summary>
            <param name="taskThreadIndex">The task thread index.</param>
            <returns>The profiler for the task thread.</returns>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContext.GetProfilerForTaskThread(Quantum.FrameThreadSafe)">
            <summary>
            Gets the profiler for the specified frame.
            </summary>
            <param name="frame">The frame.</param>
            <returns>The profiler for the frame.</returns>
        </member>
        <member name="T:Quantum.Profiling.ProfilerContextData">
            <summary>
            Represents the data collected by the profiler for all the threads for a single frame.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.ProfilerContextData.Frame">
            <summary>
            Frame number.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.ProfilerContextData.Frequency">
            <summary>
            Stopwatch frequency. Can be used to normalize the tick values.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.ProfilerContextData.Profilers">
            <summary>
            Per-thread profiler data.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.ProfilerContextData.IsVerified">
            <summary>
            Was the frame verified?
            </summary>
        </member>
        <member name="F:Quantum.Profiling.ProfilerContextData.SimulationId">
            <summary>
            Absolute number of the simulation.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.ProfilerContextData.Clone">
            <summary>
            Clones the profiler context data.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Quantum.Profiling.ProfilerData">
            <summary>
            Data collected by the profiler.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.ProfilerData.Name">
            <summary>
            Name of the profiler. Profiler for the main thread will have the name "Main Thread", wheras working threads will have the name "Worker Thread #X".
            </summary>
        </member>
        <member name="F:Quantum.Profiling.ProfilerData.Samples">
            <summary>
            Samples collected by the profiler.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.ProfilerData.Clone">
            <summary>
            Creates a deep copy of the profiler data.
            </summary>
            <returns>A new instance of the ProfilerData struct that is a copy of this instance.</returns>
        </member>
        <member name="T:Quantum.Profiling.SampleType">
            <summary>
            Represents the type of sample.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.Sample">
            <summary>
            Represents a sample in the profiler.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.Sample.Type">
            <summary>
            Gets or sets the type of the sample.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.Sample.Time">
            <summary>
            Gets or sets the time of the sample.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.Sample.Name">
            <summary>
            Gets or sets the name of the sample.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.Sample.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.Profiling.Sample"/> struct with the specified name.
            </summary>
            <param name="name">The name of the sample.</param>
        </member>
        <member name="T:Quantum.EntityComponentConfigAttribute">
            <summary>
            Obsolete attribute, use [CodeGen] instead.
            </summary>
        </member>
        <member name="P:Quantum.EntityComponentConfigAttribute.GenerateLinkingScripts">
            <summary/>
        </member>
        <member name="P:Quantum.EntityComponentConfigAttribute.GenerateAsMainScript">
            <summary/>
        </member>
        <member name="P:Quantum.EntityComponentConfigAttribute.GenerateAsAbstractScript">
            <summary/>
        </member>
        <member name="T:Quantum.ArrayLengthAttribute">
            <summary>
            Editor attribute for selecting the minimum and maximum length constraints for an array field.
            </summary>
        </member>
        <member name="M:Quantum.ArrayLengthAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.ArrayLengthAttribute"/> class with the specified length.
            </summary>
            <param name="length">The length of the array.</param>
        </member>
        <member name="M:Quantum.ArrayLengthAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.ArrayLengthAttribute"/> class with the specified minimum and maximum lengths.
            </summary>
            <param name="minLength">The minimum length of the array.</param>
            <param name="maxLength">The maximum length of the array.</param>
        </member>
        <member name="P:Quantum.ArrayLengthAttribute.MinLength">
            <summary>
            Gets the minimum length of the array.
            </summary>
        </member>
        <member name="P:Quantum.ArrayLengthAttribute.MaxLength">
            <summary>
            Gets the maximum length of the array.
            </summary>
        </member>
        <member name="T:Quantum.AssemblyNameAttribute">
            <summary>
            Specifies that the attributed field represents the name of an assembly.
            </summary>
        </member>
        <member name="P:Quantum.AssemblyNameAttribute.RequiresUnsafeCode">
            <summary>
            Gets or sets a value indicating whether the assembly requires unsafe code.
            </summary>
        </member>
        <member name="T:Quantum.BinaryDataAttribute">
            <summary>
            Specifies that the field represents binary data.
            </summary>
        </member>
        <member name="T:Quantum.BitSetAttribute">
            <summary>
            Represents an attribute that specifies the number of bits in a bit set.
            </summary>
        </member>
        <member name="M:Quantum.BitSetAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.BitSetAttribute"/> class with the specified number of bits.
            </summary>
            <param name="bitCount">The number of bits in the bit set.</param>
        </member>
        <member name="P:Quantum.BitSetAttribute.BitCount">
            <summary>
            Gets the number of bits in the bit set.
            </summary>
        </member>
        <member name="T:Quantum.DecoratingPropertyAttribute">
            <summary>
            A base class for property attributes that decorate other property attributes.
            </summary>
        </member>
        <member name="F:Quantum.DecoratingPropertyAttribute.DefaultOrder">
            <summary>
            The default order of the attribute.
            </summary>
        </member>
        <member name="M:Quantum.DecoratingPropertyAttribute.#ctor">
            <summary>
            Initializes a new instance with the default order.
            </summary>
        </member>
        <member name="M:Quantum.DecoratingPropertyAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance with the specified order.
            </summary>
            <param name="order"></param>
        </member>
        <member name="T:Quantum.DisplayAsEnumAttribute">
            <summary>
            Casts an enum or int value in the inspector to specific enum type for rendering of its popup list. 
            Supplying a method name rather than a type allows a property with the type Type to be used to dynamically get the enum type.
            </summary>
        </member>
        <member name="M:Quantum.DisplayAsEnumAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.DisplayAsEnumAttribute"/> class with the specified enum type.
            </summary>
            <param name="enumType">The type of the enum.</param>
        </member>
        <member name="M:Quantum.DisplayAsEnumAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.DisplayAsEnumAttribute"/> class with the specified enum type member name.
            </summary>
            <param name="enumTypeMemberName">The name of the member that returns the enum type.</param>
        </member>
        <member name="P:Quantum.DisplayAsEnumAttribute.EnumType">
            <summary>
            Gets the type of the enum.
            </summary>
        </member>
        <member name="P:Quantum.DisplayAsEnumAttribute.EnumTypeMemberName">
            <summary>
            Gets the name of the member that returns the enum type.
            </summary>
        </member>
        <member name="T:Quantum.DisplayNameAttribute">
            <summary>
            Specifies the display name for a field.
            </summary>
        </member>
        <member name="F:Quantum.DisplayNameAttribute.Name">
            <summary>
            Field name to display.
            </summary>
        </member>
        <member name="M:Quantum.DisplayNameAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.DisplayNameAttribute"/> class with the specified name.
            </summary>
            <param name="name">The display name.</param>
        </member>
        <member name="T:Quantum.CompareOperator">
            <summary>
              Comparison method for evaluating condition member value against compareToValues.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.Equal">
            <summary>
              <see langword="true"/> if condition member value equals compareToValue.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.NotEqual">
            <summary>
              <see langword="true"/> if condition member value is not equal to compareToValue.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.Less">
            <summary>
              <see langword="true"/> if condition member value is less than compareToValue.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.LessOrEqual">
            <summary>
              <see langword="true"/> if condition member value is less than or equal to compareToValue.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.GreaterOrEqual">
            <summary>
              <see langword="true"/> if condition member value is greater than or equal to compareToValue.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.Greater">
            <summary>
              <see langword="true"/> if condition member value is greater than compareToValue.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.NotZero">
            <summary>
              Returns <see langword="true"/> if the condition member evaluates to anything other than zero.
              In the case of object references, this means <see langword="true"/> for any non-<see langword="null"/> value.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.IsZero">
            <summary>
              Returns <see langword="true"/> if the condition member evaluates to zero.
              In the case of object references, this means <see langword="true"/> for any <see langword="null"/> value.
            </summary>
        </member>
        <member name="F:Quantum.CompareOperator.BitwiseAndNotEqualZero">
            <summary>
            Returns <see langword="true"/> if the bitwise AND of the condition member and compareToValue is not zero.
            </summary>
        </member>
        <member name="T:Quantum.DoIfAttributeBase">
            <summary>
              Editor attribute for selective editor rendering. Condition member can be a property, field or method (with a
              return value).
              <para>Value of condition method is converted to a long or a double. <see langword="null"/> = 0, <see langword="false"/> = 0, <see langword="true"/> = 1, Unity Object = InstanceId</para>
            </summary>
        </member>
        <member name="F:Quantum.DoIfAttributeBase._doubleValue">
            <summary>
            The double value to compare against.
            </summary>
        </member>
        <member name="F:Quantum.DoIfAttributeBase._isDouble">
            <summary>
            Is the value to compare against a double?
            </summary>
        </member>
        <member name="F:Quantum.DoIfAttributeBase._longValue">
            <summary>
            The long value to compare against.
            </summary>
        </member>
        <member name="F:Quantum.DoIfAttributeBase.Compare">
            <summary>
            The comparison operator to use.
            </summary>
        </member>
        <member name="F:Quantum.DoIfAttributeBase.ConditionMember">
            <summary>
            Condition member to evaluate.
            </summary>
        </member>
        <member name="F:Quantum.DoIfAttributeBase.ErrorOnConditionMemberNotFound">
            <summary>
            If <see langword="true"/>, an error will be thrown if the condition member is not found.
            </summary>
        </member>
        <member name="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Double,Quantum.CompareOperator)">
            <summary>
            Initializes a new instance with a double value to compare against.
            </summary>
            <param name="conditionMember"></param>
            <param name="compareToValue"></param>
            <param name="compare"></param>
        </member>
        <member name="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Int64,Quantum.CompareOperator)">
            <summary>
            Initializes a new instance with a long value to compare against.
            </summary>
            <param name="conditionMember"></param>
            <param name="compareToValue"></param>
            <param name="compare"></param>
        </member>
        <member name="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Boolean,Quantum.CompareOperator)">
            <summary>
            Initializes a new instance with a boolean value to compare against.
            </summary>
            <param name="conditionMember"></param>
            <param name="compareToValue"></param>
            <param name="compare"></param>
        </member>
        <member name="T:Quantum.DrawerPropertyAttribute">
            <summary>
            A base class for property attributes that are used to draw properties in the inspector.
            </summary>
        </member>
        <member name="T:Quantum.DrawIfMode">
            <summary>
            Mode for the DrawIf attribute. If the condition is not met, should the field be hidden or just read-only?
            </summary>
        </member>
        <member name="F:Quantum.DrawIfMode.ReadOnly">
            <summary>
            Field is read-only if the condition is not met.
            </summary>
        </member>
        <member name="F:Quantum.DrawIfMode.Hide">
            <summary>
            Field is hidden if the condition is not met.
            </summary>
        </member>
        <member name="T:Quantum.DrawIfAttribute">
            <summary>
              Editor attribute for selectively drawing/hiding fields. Condition member can be a property, field or method
              (with a return value).
              <para>Value of condition method is converted to a long. <see langword="null"/> = 0, <see langword="false"/> = 0, <see langword="true"/> = 1, Unity Object = InstanceId</para>
            </summary>
        </member>
        <member name="F:Quantum.DrawIfAttribute.Mode">
            <summary>
              Instructs the attribute completely hide the field if not draw, rather than the default of just disabling it.
            </summary>
        </member>
        <member name="P:Quantum.DrawIfAttribute.Hide">
            <summary>
            Should the field be hidden if the condition is not met?
            </summary>
        </member>
        <member name="M:Quantum.DrawIfAttribute.#ctor(System.String,System.Double,Quantum.CompareOperator,Quantum.DrawIfMode)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Double,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.DrawIfAttribute.#ctor(System.String,System.Boolean,Quantum.CompareOperator,Quantum.DrawIfMode)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Boolean,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.DrawIfAttribute.#ctor(System.String,System.Int64,Quantum.CompareOperator,Quantum.DrawIfMode)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Int64,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.DrawIfAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance that will hide the field if the condition member is not equal to zero.
            </summary>
            <param name="conditionMember"></param>
        </member>
        <member name="T:Quantum.DrawInlineAttribute">
            <summary>
            Specifies that a field should be drawn inline in the inspector.
            </summary>
        </member>
        <member name="T:Quantum.EditorButtonAttribute">
            <summary>
            Specifies that a method should be displayed as a button in the Unity editor.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonAttribute.Label">
            <summary>
            The label text to display on the button.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonAttribute.Visibility">
            <summary>
            The visibility of the button in the Unity editor.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonAttribute.Priority">
            <summary>
            The priority of the button. Buttons with higher priority are displayed first.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonAttribute.AllowMultipleTargets">
            <summary>
            Determines whether multiple targets are supported.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonAttribute.DirtyObject">
            <summary>
            Determines whether the object should be marked as dirty after clicking the button.
            </summary>
        </member>
        <member name="M:Quantum.EditorButtonAttribute.#ctor(System.String,Quantum.EditorButtonVisibility,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.EditorButtonAttribute"/> class with the specified label, visibility, priority, and dirty object flag.
            </summary>
            <param name="label">The label text to display on the button.</param>
            <param name="visibility">The visibility of the button in the Unity editor.</param>
            <param name="priority">The priority of the button. Buttons with higher priority are displayed first.</param>
            <param name="dirtyObject">Determines whether the object should be marked as dirty after clicking the button.</param>
        </member>
        <member name="M:Quantum.EditorButtonAttribute.#ctor(Quantum.EditorButtonVisibility,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.EditorButtonAttribute"/> class with the specified visibility, priority, and dirty object flag.
            </summary>
            <param name="visibility">The visibility of the button in the Unity editor.</param>
            <param name="priority">The priority of the button. Buttons with higher priority are displayed first.</param>
            <param name="dirtyObject">Determines whether the object should be marked as dirty after clicking the button.</param>
        </member>
        <member name="T:Quantum.EditorButtonVisibility">
            <summary>
            Specifies the visibility options for an editor button.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonVisibility.PlayMode">
            <summary>
            The button is only visible in Play Mode.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonVisibility.EditMode">
            <summary>
            The button is only visible in Edit Mode.
            </summary>
        </member>
        <member name="F:Quantum.EditorButtonVisibility.Always">
            <summary>
            The button is always visible.
            </summary>
        </member>
        <member name="T:Quantum.ErrorIfAttribute">
            <summary>
              Editor attribute for adding notices to fields if the condition member evaluates as <see langword="true"/>.
              Condition member can be a property, field or method (with a return value).
            </summary>
        </member>
        <member name="F:Quantum.ErrorIfAttribute.Message">
            <summary>
            The default error text, when an error is shown.
            </summary>
        </member>
        <member name="F:Quantum.ErrorIfAttribute.AsBox">
            <summary>
            Should the error be shown as a box?
            </summary>
        </member>
        <member name="M:Quantum.ErrorIfAttribute.#ctor(System.String,System.Double,System.String,Quantum.CompareOperator)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Double,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.ErrorIfAttribute.#ctor(System.String,System.Boolean,System.String,Quantum.CompareOperator)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Boolean,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.ErrorIfAttribute.#ctor(System.String,System.Int64,System.String,Quantum.CompareOperator)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Int64,Quantum.CompareOperator)"/>
        </member>
        <member name="T:Quantum.ExpandableEnumAttribute">
            <summary>
            Editor attribute that shows an enum as an expandable list of options in the inspector.
            </summary>
        </member>
        <member name="P:Quantum.ExpandableEnumAttribute.AlwaysExpanded">
            <summary>
            Always expand the enum in the inspector (no foldout)
            </summary>
        </member>
        <member name="P:Quantum.ExpandableEnumAttribute.ShowFlagsButtons">
            <summary>
            Show the enum flags as buttons in the inspector.
            </summary>
        </member>
        <member name="P:Quantum.ExpandableEnumAttribute.ShowInlineHelp">
            <summary>
            Show inline help for enum values in the inspector.
            </summary>
        </member>
        <member name="T:Quantum.FieldEditorButtonAttribute">
            <summary>
            Editor attribute to add a button that invokes a custom method in the inspector.
            </summary>
        </member>
        <member name="F:Quantum.FieldEditorButtonAttribute.Label">
            <summary>
            Button label.
            </summary>
        </member>
        <member name="F:Quantum.FieldEditorButtonAttribute.AllowMultipleTargets">
            <summary>
            Is it allowed to select multiple targets for the button?
            </summary>
        </member>
        <member name="F:Quantum.FieldEditorButtonAttribute.TargetMethod">
            <summary>
            The method to invoke when the button is clicked.
            </summary>
        </member>
        <member name="M:Quantum.FieldEditorButtonAttribute.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance class with the specified label and target method.
            </summary>
            <param name="label">The label of the button</param>
            <param name="targetMethod">The method to invoke when the button is clicked</param>
        </member>
        <member name="T:Quantum.HideArrayElementLabelAttribute">
            <summary>
            Attribute used to hide the label of an array element in the inspector.
            </summary>
        </member>
        <member name="M:Quantum.HideArrayElementLabelAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.HideArrayElementLabelAttribute"/> class.
            </summary>
        </member>
        <member name="T:Quantum.InlineHelpAttribute">
            <summary>
            If applied to a field, checks if there is a help text for the field or the field's type and shows it in the inspector.
            </summary>
        </member>
        <member name="P:Quantum.InlineHelpAttribute.ShowTypeHelp">
            <summary>
            Gets or sets a value indicating whether to show help for the type.
            </summary>
        </member>
        <member name="M:Quantum.InlineHelpAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.InlineHelpAttribute"/> class.
            </summary>
        </member>
        <member name="T:Quantum.LayerAttribute">
            <summary>
            Specifies that an int field should be drawn as a layer field in the inspector.
            </summary>
        </member>
        <member name="T:Quantum.LayerMatrixAttribute">
            <summary>
            Specifies that the integer array field should be drawn as a layer matrix in the inspector.
            </summary>
        </member>
        <member name="T:Quantum.MaxStringByteCountAttribute">
            <summary>
            Specifies that the string field should be drawn as a text field with a maximum byte count for given encoding.
            </summary>
        </member>
        <member name="M:Quantum.MaxStringByteCountAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.MaxStringByteCountAttribute"/> class with the specified byte count and encoding.
            </summary>
            <param name="count"></param>
            <param name="encoding"></param>
        </member>
        <member name="P:Quantum.MaxStringByteCountAttribute.ByteCount">
            <summary>
            Maximum byte count for the string.
            </summary>
        </member>
        <member name="P:Quantum.MaxStringByteCountAttribute.Encoding">
            <summary>
            The encoding of the string.
            </summary>
        </member>
        <member name="T:Quantum.RangeExAttribute">
            <summary>
            Represents an attribute that specifies a range of values for a field or property.
            </summary>
        </member>
        <member name="P:Quantum.RangeExAttribute.Max">
            <summary>
            Gets the maximum value of the range.
            </summary>
        </member>
        <member name="P:Quantum.RangeExAttribute.Min">
            <summary>
            Gets the minimum value of the range.
            </summary>
        </member>
        <member name="F:Quantum.RangeExAttribute.ClampMin">
            <summary>
            Gets or sets a value indicating whether the minimum value should be clamped.
            </summary>
        </member>
        <member name="F:Quantum.RangeExAttribute.ClampMax">
            <summary>
            Gets or sets a value indicating whether the maximum value should be clamped.
            </summary>
        </member>
        <member name="F:Quantum.RangeExAttribute.UseSlider">
            <summary>
            Gets or sets a value indicating whether a slider should be used for the range.
            </summary>
        </member>
        <member name="M:Quantum.RangeExAttribute.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.RangeExAttribute"/> class with the specified minimum and maximum values.
            </summary>
            <param name="min">The minimum value of the range.</param>
            <param name="max">The maximum value of the range.</param>
        </member>
        <member name="T:Quantum.ReadOnlyAttribute">
            <summary>
            Attribute used to mark a field as read-only.
            </summary>
        </member>
        <member name="P:Quantum.ReadOnlyAttribute.InPlayMode">
            <summary>
            Should the field be read-only in play mode?
            </summary>
        </member>
        <member name="P:Quantum.ReadOnlyAttribute.InEditMode">
            <summary>
            Should the field be read-only in edit mode?
            </summary>
        </member>
        <member name="T:Quantum.ScenePathAttribute">
            <summary>
            Specifies that a string field represents a scene path.
            </summary>
        </member>
        <member name="T:Quantum.ScriptHelpAttribute">
            <summary>
            Defines the appearance of the script header in the Unity inspector.
            </summary>
        </member>
        <member name="P:Quantum.ScriptHelpAttribute.Hide">
            <summary>
            Hide the script header in the Unity inspector.
            </summary>
        </member>
        <member name="P:Quantum.ScriptHelpAttribute.Url">
            <summary>
            </summary>
        </member>
        <member name="P:Quantum.ScriptHelpAttribute.BackColor">
            <summary>
              Color of the inspector header for this component type. None indicates no header graphic should be used.
            </summary>
        </member>
        <member name="P:Quantum.ScriptHelpAttribute.Style">
            <summary>
            
            </summary>
        </member>
        <member name="T:Quantum.ScriptHeaderStyle">
            <summary>
            Style of the script header in the Unity inspector.
            </summary>
        </member>
        <member name="F:Quantum.ScriptHeaderStyle.Unity">
            <summary>
            Use the default Unity header style.
            </summary>
        </member>
        <member name="F:Quantum.ScriptHeaderStyle.Photon">
            <summary>
            Use the Photon header style.
            </summary>
        </member>
        <member name="T:Quantum.ScriptHeaderIcon">
            <summary>
              Icon to be rendered on the component graphic header in the Unity inspector.
            </summary>
        </member>
        <member name="T:Quantum.ScriptHeaderBackColor">
            <summary>
              Color of the component graphic header in the Unity inspector. None indicates no header graphic should be used.
            </summary>
        </member>
        <member name="T:Quantum.SerializableTypeAttribute">
            <summary>
            Specifies that either a string field represents a type name or sets additional options for <see cref="T:Quantum.SerializableType"/> field.
            </summary>
        </member>
        <member name="P:Quantum.SerializableTypeAttribute.BaseType">
            <summary>
            The base type of the picked type.
            </summary>
        </member>
        <member name="P:Quantum.SerializableTypeAttribute.UseFullAssemblyQualifiedName">
            <summary>
            Should the type be stored as a full assembly qualified name.
            </summary>
        </member>
        <member name="P:Quantum.SerializableTypeAttribute.WarnIfNoPreserveAttribute">
            <summary>
            Should a warning be shown if the field does not have a PreserveAttribute.
            </summary>
        </member>
        <member name="T:Quantum.SerializeReferenceTypePickerAttribute">
            <summary>
            Attribute used to show a type picker for a field with [SerializeReference].
            </summary>
        </member>
        <member name="F:Quantum.SerializeReferenceTypePickerAttribute.GroupTypesByNamespace">
            <summary>
            Should the types be grouped by namespace?
            </summary>
        </member>
        <member name="F:Quantum.SerializeReferenceTypePickerAttribute.ShowFullName">
            <summary>
            Should the full name be shown?
            </summary>
        </member>
        <member name="M:Quantum.SerializeReferenceTypePickerAttribute.#ctor(System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.SerializeReferenceTypePickerAttribute"/> class.
            </summary>
            <param name="types">The types to be picked.</param>
        </member>
        <member name="P:Quantum.SerializeReferenceTypePickerAttribute.Types">
            <summary>
            Gets the types to be picked.
            </summary>
        </member>
        <member name="T:Quantum.ToggleLeftAttribute">
            <summary>
            Specifies that the bool field should be drawn as the toggle on the left side of the label.
            </summary>
        </member>
        <member name="T:Quantum.Units">
            <summary>
            Unit Type for a certain field.
            This helps to identify the unit that a certain value represents, like Seconds or Percentage
            </summary>
        </member>
        <member name="F:Quantum.Units.None">
            <summary> </summary>
        </member>
        <member name="F:Quantum.Units.Ticks">
            <summary>ticks</summary>
        </member>
        <member name="F:Quantum.Units.Seconds">
            <summary>seconds - secs</summary>
        </member>
        <member name="F:Quantum.Units.MilliSecs">
            <summary>millisecs - ms</summary>
        </member>
        <member name="F:Quantum.Units.Kilobytes">
            <summary>kilobytes - kB</summary>
        </member>
        <member name="F:Quantum.Units.Megabytes">
            <summary>megabytes - MB</summary>
        </member>
        <member name="F:Quantum.Units.Normalized">
            <summary>normalized - norm</summary>
        </member>
        <member name="F:Quantum.Units.Multiplier">
            <summary>multiplier - mult</summary>
        </member>
        <member name="F:Quantum.Units.Percentage">
            <summary>%</summary>
        </member>
        <member name="F:Quantum.Units.NormalizedPercentage">
            <summary>normalized % - n%</summary>
        </member>
        <member name="F:Quantum.Units.Degrees">
            <summary>degrees - \u00B0</summary>
        </member>
        <member name="F:Quantum.Units.PerSecond">
            <summary>per sec - /sec</summary>
        </member>
        <member name="F:Quantum.Units.DegreesPerSecond">
            <summary>\u00B0 / sec - \u00B0/sec</summary>
        </member>
        <member name="F:Quantum.Units.Radians">
            <summary>radians - rad</summary>
        </member>
        <member name="F:Quantum.Units.RadiansPerSecond">
            <summary>radian / sec - rad/s</summary>
        </member>
        <member name="F:Quantum.Units.TicksPerSecond">
            <summary>ticks / sec - tck/s</summary>
        </member>
        <member name="F:Quantum.Units.Units">
            <summary>units - units</summary>
        </member>
        <member name="F:Quantum.Units.Bytes">
            <summary>bytes - bytes</summary>
        </member>
        <member name="F:Quantum.Units.Count">
            <summary>count - count</summary>
        </member>
        <member name="F:Quantum.Units.Packets">
            <summary>packets - packets</summary>
        </member>
        <member name="F:Quantum.Units.Frames">
            <summary>frames - frames</summary>
        </member>
        <member name="F:Quantum.Units.FramesPerSecond">
            <summary>fps - fps</summary>
        </member>
        <member name="F:Quantum.Units.SquareMagnitude">
            <summary>sqrMagnitude - sqrMag</summary>
        </member>
        <member name="T:Quantum.UnitAttribute">
            <summary>
            Unit Attribute class.
            Used to mark a field with the respective <see cref="T:Quantum.Units"/>
            </summary>
        </member>
        <member name="P:Quantum.UnitAttribute.Unit">
            <summary>
            Selected Unit for the field.
            </summary>
        </member>
        <member name="M:Quantum.UnitAttribute.#ctor(Quantum.Units)">
            <summary>
            Initializes a new instance of the <see cref="T:Quantum.UnitAttribute"/> class with the specified unit.
            </summary>
            <param name="units"></param>
        </member>
        <member name="T:Quantum.UnityAddressablesRuntimeKeyAttribute">
            <summary>
            Specifies that the string field represents a key for Unity Addressables.
            </summary>
        </member>
        <member name="T:Quantum.UnityAssetGuidAttribute">
            <summary>
            Specifies that the string field represents a GUID of an asset.
            </summary>
        </member>
        <member name="T:Quantum.UnityResourcePathAttribute">
            <summary>
            Specifies that the string field represents a path to a Unity resource.
            </summary>
        </member>
        <member name="M:Quantum.UnityResourcePathAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the class with the specified resource type.
            </summary>
            <param name="resourceType"></param>
        </member>
        <member name="P:Quantum.UnityResourcePathAttribute.ResourceType">
            <summary>
            The type of the resource.
            </summary>
        </member>
        <member name="T:Quantum.WarnIfAttribute">
            <summary>
              Editor attribute for adding notices to fields if the condition member evaluates as <see langword="true"/>.
              Condition member can be a property, field or method (with a return value).
            </summary>
        </member>
        <member name="F:Quantum.WarnIfAttribute.Message">
            <summary>
            The default warning text, when a warning is shown.
            </summary>
        </member>
        <member name="F:Quantum.WarnIfAttribute.AsBox">
            <summary>
            Should the warning be shown as a box?
            </summary>
        </member>
        <member name="M:Quantum.WarnIfAttribute.#ctor(System.String,System.Double,System.String,Quantum.CompareOperator)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Double,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.WarnIfAttribute.#ctor(System.String,System.Boolean,System.String,Quantum.CompareOperator)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Boolean,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.WarnIfAttribute.#ctor(System.String,System.Int64,System.String,Quantum.CompareOperator)">
            <inheritdoc cref="M:Quantum.DoIfAttributeBase.#ctor(System.String,System.Int64,Quantum.CompareOperator)"/>
        </member>
        <member name="M:Quantum.WarnIfAttribute.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance that will hide the field if the condition member is not equal to zero.
            </summary>
            <param name="conditionMember"></param>
            <param name="message"></param>
        </member>
        <member name="T:Quantum.FieldsMask">
            <summary>
            Base class for <see cref="T:Quantum.FieldsMask`1"/>.
            </summary>
        </member>
        <member name="F:Quantum.FieldsMask.Mask">
            <summary>
            The internal mask value.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask.#ctor(Quantum.Mask256)">
            <summary>
            Constructor for <see cref="T:Quantum.FieldsMask"/>.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Constructor for <see cref="T:Quantum.FieldsMask"/>.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask.#ctor">
            <summary>
            Constructor for <see cref="T:Quantum.FieldsMask"/>.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask.op_Implicit(Quantum.FieldsMask)~Quantum.Mask256">
            <summary>
            Implicitly convert <see cref="T:Quantum.FieldsMask"/> to its long mask value.
            </summary>
        </member>
        <member name="T:Quantum.FieldsMask`1">
            <summary>
            Associates and displays a 64 bit mask which represents the field members of a struct. Makes it possible to treat a Struct like an Flags Enum.
            NOTE: A <see cref="T:Quantum.FieldsMask`1"/> attribute is required for proper rendering in the Inspector.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask`1.#ctor(Quantum.Mask256)">
            <summary>
            Constructor for <see cref="T:Quantum.FieldsMask`1"/>.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask`1.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Constructor for <see cref="T:Quantum.FieldsMask"/>.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask`1.#ctor">
            <summary>
            Constructor for <see cref="T:Quantum.FieldsMask`1"/>.
            </summary>
        </member>
        <member name="M:Quantum.FieldsMask`1.#ctor(System.Func{Quantum.Mask256})">
            <summary>
            Constructor for <see cref="T:Quantum.FieldsMask"/>.
            </summary>
        </member>
        <member name="T:Quantum.Mask256">
            <summary>
            Mask256 is a 256-bit mask that can be used to store 256 boolean values.
            </summary>
        </member>
        <member name="P:Quantum.Mask256.Item(System.Int32)">
            <summary>
            Returns selected 64-bit value from the mask.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Quantum.Mask256.Clear">
            <summary>
            Sets all bits to 0.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.SetBit(System.Int32,System.Boolean)">
            <summary>
            Sets a specific bit in the mask.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.GetBit(System.Int32)">
            <summary>
            Returns a specific bit from the mask.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new mask with specified initial values.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.op_Implicit(Quantum.Mask256)~System.Int64">
            <summary>
            Equivalent to <code>mask[0]</code>
            </summary>
        </member>
        <member name="M:Quantum.Mask256.op_Implicit(System.Int64)~Quantum.Mask256">
            <summary>
            Converts a long value to a mask.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.op_BitwiseAnd(Quantum.Mask256,Quantum.Mask256)">
            <summary>
            Performs a logical-AND operation.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.op_BitwiseOr(Quantum.Mask256,Quantum.Mask256)">
            <summary>
            Performs a logical-OR operation.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.op_OnesComplement(Quantum.Mask256)">
            <summary>
            Performs a logical-NOT operation.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.Equals(System.Object)">
            <summary>
            Returns <see langword="true"/> if the masks are equal.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.GetHashCode">
            <summary>
            Calculates the hash code of the mask.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.Equals(Quantum.Mask256)">
            <summary>
            Returns <see langword="true"/> if the masks are equal.
            </summary>
        </member>
        <member name="M:Quantum.Mask256.IsNothing">
            <summary>
            Returns <see langword="true"/> if the mask is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.Mask256.ToString">
            <summary>
            Converts the mask to a string in the form of "a:b:c:d".
            </summary>
        </member>
        <member name="T:Quantum.SerializableType">
            <summary>
            A System.Type wrapper that can be serialized.
            </summary>
        </member>
        <member name="F:Quantum.SerializableType.AssemblyQualifiedName">
            <summary>
            Type's assembly qualified name.
            </summary>
        </member>
        <member name="P:Quantum.SerializableType.IsValid">
            <summary>
            Is the type valid.
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.#ctor(System.Type)">
            <summary>
            Create a new instance and stores full <see cref="P:System.Type.AssemblyQualifiedName"/>. To use shorter form, use <see cref="M:Quantum.SerializableType.AsShort"/>.
            </summary>
            <param name="type">Type to store. Can be <see langword="null"/>.</param>
        </member>
        <member name="M:Quantum.SerializableType.#ctor(System.String)">
            <summary>
            Create a new instance and stores <paramref name="type"/> as <see cref="F:Quantum.SerializableType.AssemblyQualifiedName"/>.
            </summary>
            <param name="type">Type name.</param>
        </member>
        <member name="P:Quantum.SerializableType.Value">
            <summary>
            Retrieve the type. The value is obtained using <see cref="M:System.Type.GetType(System.String)"/> and cached in a static
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.AsShort">
            <summary>
            Converts <see cref="F:Quantum.SerializableType.AssemblyQualifiedName"/> and returns a short form, without version, culture etc.
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.op_Implicit(System.Type)~Quantum.SerializableType">
            <summary>
            Implicitly convert a <see cref="T:System.Type"/> to a <see cref="T:Quantum.SerializableType"/>.
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.op_Implicit(Quantum.SerializableType)~System.Type">
            <summary>
            Implicitly convert a <see cref="T:Quantum.SerializableType"/> to a <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.Equals(Quantum.SerializableType)">
            <summary>
            Returns <see langword="true"/> if the <see cref="F:Quantum.SerializableType.AssemblyQualifiedName"/> is the same.
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.Equals(System.Object)">
            <summary>
            Returns <see langword="true"/> if <paramref name="obj"/> is <see cref="T:Quantum.SerializableType"/> and the <see cref="F:Quantum.SerializableType.AssemblyQualifiedName"/> is the same.
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.GetHashCode">
            <summary>
            Returns the hash code of the <see cref="F:Quantum.SerializableType.AssemblyQualifiedName"/>.
            </summary>
        </member>
        <member name="M:Quantum.SerializableType.GetShortAssemblyQualifiedName(System.Type)">
            <summary>
            Converts the <see cref="P:System.Type.AssemblyQualifiedName"/> to a shorter form, without version, culture etc.
            </summary>
        </member>
        <member name="T:Quantum.SerializableType`1">
            <summary>
            A generic version of <see cref="T:Quantum.SerializableType"/> that can be used to store types that inherit from a specific base type.
            </summary>
            <typeparam name="BaseType">The base type of the type stored</typeparam>
        </member>
        <member name="F:Quantum.SerializableType`1.AssemblyQualifiedName">
            <inheritdoc cref="F:Quantum.SerializableType.AssemblyQualifiedName"/>
        </member>
        <member name="P:Quantum.SerializableType`1.IsValid">
            <inheritdoc cref="P:Quantum.SerializableType.IsValid"/>
        </member>
        <member name="M:Quantum.SerializableType`1.#ctor(System.Type)">
            <inheritdoc cref="T:Quantum.SerializableType"/>
        </member>
        <member name="M:Quantum.SerializableType`1.AsShort">
            <inheritdoc cref="M:Quantum.SerializableType.AsShort"/>
        </member>
        <member name="P:Quantum.SerializableType`1.Value">
            <inheritdoc cref="P:Quantum.SerializableType.Value"/>
        </member>
        <member name="M:Quantum.SerializableType`1.op_Implicit(System.Type)~Quantum.SerializableType{`0}">
            <inheritdoc cref="M:Quantum.SerializableType.op_Implicit(System.Type)~Quantum.SerializableType"/>
        </member>
        <member name="M:Quantum.SerializableType`1.op_Implicit(Quantum.SerializableType{`0})~System.Type">
            <inheritdoc cref="M:Quantum.SerializableType.op_Implicit(Quantum.SerializableType)~System.Type"/>
        </member>
        <member name="M:Quantum.SerializableType`1.Equals(Quantum.SerializableType{`0})">
            <inheritdoc cref="M:Quantum.SerializableType.Equals(Quantum.SerializableType)"/>
        </member>
        <member name="M:Quantum.SerializableType`1.Equals(System.Object)">
            <inheritdoc cref="M:Quantum.SerializableType.Equals(System.Object)"/>
        </member>
        <member name="M:Quantum.SerializableType`1.GetHashCode">
            <inheritdoc cref="M:Quantum.SerializableType.GetHashCode"/>
        </member>
        <member name="T:Quantum.Transform2D">
            <summary>
            The Transform2D is an entity component providing position and rotation a 2D object.
            </summary>
        </member>
        <member name="F:Quantum.Transform2D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.Transform2D.Position">
            <summary>
            The world position of the entity.
            </summary>
        </member>
        <member name="F:Quantum.Transform2D.Rotation">
            <summary>
            The rotation in radians.
            </summary>
        </member>
        <member name="M:Quantum.Transform2D.Create(Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Create method to create a new Transform2D. 
            </summary>
            <param name="position">Initial position</param>
            <param name="rotation">Initial rotation</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2)">
            <summary>
            Teleport an entity to a new position.
            <para>Is important to call on large instant movements otherwise it will be interpolated and could create visual glitches.</para>
            </summary>
            <param name="frame">The current frame.</param>
            <param name="position">The world position to teleport to.</param>
        </member>
        <member name="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FP)">
            <summary>
            Teleport an entity to a new rotation.
            <para>Is important to call on large instant rotations otherwise it will be interpolated and could create visual glitches.</para>
            </summary>
            <param name="frame">The current frame.</param>
            <param name="rotation">The rotation to teleport to.</param>
        </member>
        <member name="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Teleport an entity to a new position and rotation.
            <para>Is important to call on large instant movements otherwise it will be interpolated and could create visual glitches.</para>
            </summary>
            <param name="frame">The current frame.</param>
            <param name="position">The world position to teleport to.</param>
            <param name="rotation">The rotation to teleport to.</param>
        </member>
        <member name="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Quantum.Transform2D*)">
            <summary>
            Teleport an entity to a new transform (position and rotation).
            </summary>
            <param name="frame">The current frame.</param>
            <param name="transform">Transform</param>
        </member>
        <member name="P:Quantum.Transform2D.PositionTeleportFrame">
            <summary>
            Last frame when a position teleport was called. Used by view to ignore interpolation.
            </summary>
        </member>
        <member name="P:Quantum.Transform2D.RotationTeleportFrame">
            <summary>
            Last frame when a rotation teleport was called. Used by view to ignore interpolation.
            </summary>
        </member>
        <member name="P:Quantum.Transform2D.Right">
            <summary>
            Calculate the right vector.
            </summary>
        </member>
        <member name="P:Quantum.Transform2D.Left">
            <summary>
            Calculate the left vector.
            </summary>
        </member>
        <member name="P:Quantum.Transform2D.Up">
            <summary>
            Calculate the up vector.
            </summary>
        </member>
        <member name="P:Quantum.Transform2D.Down">
            <summary>
            Calculate the down vector.
            </summary>
        </member>
        <member name="P:Quantum.Transform2D.Forward">
            <summary>
            Calculate the forward vector (same as right).
            </summary>
        </member>
        <member name="P:Quantum.Transform2D.Back">
            <summary>
            Calculate the back vector (same as left).
            </summary>
        </member>
        <member name="M:Quantum.Transform2D.TransformPoint(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="point"/> from local to world space.
            See also: <seealso cref="M:Quantum.Transform2D.InverseTransformPoint(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="point">A point in local space.</param>
            <returns>The transformed point in world space.</returns>
        </member>
        <member name="M:Quantum.Transform2D.InverseTransformPoint(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="point"/> from world to local space.
            See also: <seealso cref="M:Quantum.Transform2D.TransformPoint(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="point">A point in world space.</param>
            <returns>The transformed point in local space.</returns>
        </member>
        <member name="M:Quantum.Transform2D.TransformDirection(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="direction"/> from local to world space.
            See also: <seealso cref="M:Quantum.Transform2D.InverseTransformDirection(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="direction">A direction in local space.</param>
            <returns>The transformed direction in world space.</returns>
        </member>
        <member name="M:Quantum.Transform2D.InverseTransformDirection(Photon.Deterministic.FPVector2)">
            <summary>
            Transforms a <paramref name="direction"/> from world to local space.
            See also: <seealso cref="M:Quantum.Transform2D.TransformDirection(Photon.Deterministic.FPVector2)"/>.
            </summary>
            <param name="direction">A direction in world space.</param>
            <returns>The transformed direction in local space.</returns>
        </member>
        <member name="M:Quantum.Transform2D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Transform2D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Transform2D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Transform2D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.Transform2DVertical">
            <summary>
            The Transform2DVertical is an entity component pseudo-3D height and offset for an entity.
            </summary>
        </member>
        <member name="F:Quantum.Transform2DVertical.SIZE">
            <summary>
            The component size in bytes.
            </summary>
        </member>
        <member name="F:Quantum.Transform2DVertical.Position">
            <summary>
            The position or vertical offset of the transform.
            </summary>
        </member>
        <member name="F:Quantum.Transform2DVertical.Height">
            <summary>
            The height.
            </summary>
        </member>
        <member name="M:Quantum.Transform2DVertical.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Transform2DVertical"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Transform2DVertical"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.Transform3D">
            <summary>
            The Transform3D is an entity component providing position and rotation for a 3D object.
            <para>Always use the factory create method <see cref="M:Quantum.Transform3D.Create(Photon.Deterministic.FPVector3)"/> or <see cref="M:Quantum.Transform3D.Create(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion)"/> 
            or correctly initialize the rotation Quaternion manually.</para>
            </summary>
        </member>
        <member name="F:Quantum.Transform3D.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.Transform3D.Position">
            <summary>
            The world position of the entity.
            </summary>
        </member>
        <member name="F:Quantum.Transform3D.Rotation">
            <summary>
            The rotation of the entity.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.Create(Photon.Deterministic.FPVector3)">
            <summary>
            Factory create a Transform3D component.
            <para>Sets the <see cref="F:Quantum.Transform3D.Rotation"/> to <see cref="P:Photon.Deterministic.FPQuaternion.Identity"/>.</para>
            </summary>
            <param name="position">The initial world position.</param>
            <returns>New initialized Transform3D component.</returns>
        </member>
        <member name="M:Quantum.Transform3D.Create(Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion)">
            <summary>
            Factory create a Transform3D component.
            </summary>
            <param name="position">The initial world position.</param>
            <param name="rotation">The initial rotation.</param>
            <returns>New initialized Transform3D component.</returns>
        </member>
        <member name="M:Quantum.Transform3D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3)">
            <inheritdoc cref="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2)"/>
        </member>
        <member name="M:Quantum.Transform3D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FPQuaternion)">
            <inheritdoc cref="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Transform3D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion)">
            <inheritdoc cref="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)"/>
        </member>
        <member name="M:Quantum.Transform3D.Teleport(Quantum.Core.FrameBase,Quantum.Transform3D*)">
            <inheritdoc cref="M:Quantum.Transform2D.Teleport(Quantum.Core.FrameBase,Quantum.Transform2D*)"/>
        </member>
        <member name="P:Quantum.Transform3D.PositionTeleportFrame">
            <summary>
            Last frame when a position teleport was called. Used by view to ignore interpolation.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.RotationTeleportFrame">
            <summary>
            Last frame when a rotation teleport was called. Used by view to ignore interpolation.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Right">
            <summary>
            A vector pointing to local +X axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Up">
            <summary>
            A vector pointing to local +Y axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Forward">
            <summary>
            A vector pointing to local +Z axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Left">
            <summary>
            A vector pointing to local -X axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Down">
            <summary>
            A vector pointing to local -Y axis.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.Back">
            <summary>
            A vector pointing to local -Z axis.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.Transform3D"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.Transform3D"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.Transform3D.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="P:Quantum.Transform3D.EulerAngles">
            <summary>
            Converts rotation to Euler angles triplet.
            </summary>
            <seealso cref="P:Photon.Deterministic.FPQuaternion.AsEuler"/>.
        </member>
        <member name="P:Quantum.Transform3D.LocalToWorldMatrix">
            <summary>
            Creates local to world transformation. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="P:Quantum.Transform3D.WorldToLocalMatrix">
            <summary>
            Creates world to local transformation. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.InverseTransformDirection(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a direction from world space to local space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.TransformDirection(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a direction from local space to world space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.InverseTransformPoint(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a position from world space to local space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.TransformPoint(Photon.Deterministic.FPVector3)">
            <summary>
            Transforms a position from local space to world space. <see cref="F:Quantum.Transform3D.Rotation"/> is expected to be normalized.
            </summary>
        </member>
        <member name="M:Quantum.Transform3D.LookAt(Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPVector3})">
            <summary>
            Rotates the transform so the forward vector points at <paramref name="position"/>. If <paramref name="up"/> is not set, will use <see cref="P:Photon.Deterministic.FPVector3.Up"/> instead.
            </summary>
            <param name="position"></param>
            <param name="up"></param>
        </member>
        <member name="M:Quantum.Transform3D.Rotate(Photon.Deterministic.FPVector3,System.Boolean)">
            <summary>
            Applies a rotation of <paramref name="angles"/>.z degrees around the z-axis, <paramref name="angles"/>.x degrees around the x-axis, and <paramref name="angles"/>.y degrees around the y-axis (in that order).
            </summary>
            <param name="angles">Euler angles, in degrees.</param>
            <param name="normalize">
            If the resultant quaternion should be normalized before being set to the <see cref="F:Quantum.Transform3D.Rotation"/>.
            This prevents rounding error from accumulating and potentially rounding the quaternion magnitude towards zero over time.
            </param>
        </member>
        <member name="M:Quantum.Transform3D.Rotate(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP,System.Boolean)">
            <summary>
            Applies a rotation of <paramref name="zAngle"/> degrees around the z-axis, <paramref name="xAngle"/> degrees around the x-axis, and <paramref name="yAngle"/> degrees around the y-axis (in that order).
            </summary>
            <param name="xAngle"></param>
            <param name="yAngle"></param>
            <param name="zAngle"></param>
            <param name="normalize">
            If the resultant quaternion should be normalized before being set to the <see cref="F:Quantum.Transform3D.Rotation"/>.
            This prevents rounding error from accumulating and potentially rounding the quaternion magnitude towards zero over time.
            </param>
        </member>
        <member name="M:Quantum.Transform3D.Rotate(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Boolean,Quantum.TransformSpace)">
            <summary>
            Rotates the object around the given axis by the number of degrees defined by the given angle.
            </summary>
            <param name="axis">The axis around which to rotate.</param>
            <param name="angle">The angle of rotation around the axis.</param>
            <param name="normalize">
            If the resultant quaternion should be normalized before being set to the <see cref="F:Quantum.Transform3D.Rotation"/>.
            This prevents rounding error from accumulating and potentially rounding the quaternion magnitude towards zero over time.
            </param>
            <param name="space">If the <paramref name="axis"/> is defined in the Local space of the Transform (default) or in the World space.</param>
        </member>
        <member name="M:Quantum.Transform3D.RotateAround(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Boolean)">
            <summary>
            Rotates around a given pivot point and axis.
            </summary>
            <param name="point">The pivot point around which to rotate.</param>
            <param name="axis">The axis in WORLD space around which to rotate.</param>
            <param name="angle">The angle of rotation around the axis.</param>
            <param name="rotateTransform">
            If the transform Rotation should also be modified.
            If false, only the transform Position is modified.
            </param>
        </member>
        <member name="F:Quantum.TransformSpace.World">
            <summary>
            Applies transformation relative to the world coordinate system.
            </summary>
        </member>
        <member name="F:Quantum.TransformSpace.Local">
            <summary>
            Applies transformation relative to the local coordinate system.
            </summary>
        </member>
        <member name="T:Quantum.ArrayUtils">
            <summary>
            A collection of utility methods for working with arrays.
            </summary>
        </member>
        <member name="M:Quantum.ArrayUtils.CreateGrid``1(System.Int32,System.Int32)">
            <summary>
            Create and initialize a 2-dimensional array.
            Instantiates rows number of arrays, each with cols number of elements.
            </summary>
            <typeparam name="T">The array type</typeparam>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>An array of array object</returns>
        </member>
        <member name="M:Quantum.ArrayUtils.Add``1(``0[]@,``0)">
            <summary>
            Add one item to the array and resize it accordingly.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="array">Array to add to </param>
            <param name="item">Item to add to the array</param>
        </member>
        <member name="M:Quantum.ArrayUtils.Clone``1(``0[])">
            <summary>
            Clone an array.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="array">Array to clone</param>
            <returns>A new array which is a clone of the input array</returns>
        </member>
        <member name="M:Quantum.ArrayUtils.AddAtStart``1(``0[],``0)">
            <summary>
            Copy an array and add an array element to the start of the array.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="array">Array to add to</param>
            <param name="item">Item to add in from of the array</param>
            <returns>A new array with the element added in front.</returns>
        </member>
        <member name="M:Quantum.ArrayUtils.RemoveAtStart``1(``0[])">
            <summary>
            Copy an array and remove an element from the start of the array.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="array">Array to remove from</param>
            <returns>A new array with the element removed in the front.</returns>
        </member>
        <member name="M:Quantum.ArrayUtils.Map``2(``0[],System.Func{``0,``1})">
            <summary>
            Create a new array and map each element of the input array to a new value.
            </summary>
            <typeparam name="A">Input array type</typeparam>
            <typeparam name="B">Output array type</typeparam>
            <param name="array">Array to map</param>
            <param name="map">The mapping method</param>
            <returns>A new array with the same length as the input array and with mapped items</returns>
        </member>
        <member name="M:Quantum.ArrayUtils.Map``2(System.Collections.Generic.List{``0},System.Func{``0,``1})">
            <summary>
            Create a new array and map each element of the input list to a new value.
            </summary>
            <typeparam name="A">Input list type</typeparam>
            <typeparam name="B">Output array type</typeparam>
            <param name="array">List to map</param>
            <param name="map">The mapping method</param>
            <returns>A new array with the same length as the input list and with mapped items</returns>
        </member>
        <member name="M:Quantum.ArrayUtils.Slice``1(``0[],System.Int32)">
            <summary>
            Copy the array but only the first slice elements.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="array">Array to copy</param>
            <param name="slice">The number of elements to copy</param>
            <returns>A new array with a given number of first elements</returns>
        </member>
        <member name="M:Quantum.ArrayUtils.MapRef``2(``0[],System.Func{``0,``1})">
            <summary>
            Create a new array an map each element of the input list to a new value.
            Different to <see cref="M:Quantum.ArrayUtils.Map``2(``0[],System.Func{``0,``1})"/> <see langword="null"/> values are preserved.
            </summary>
            <typeparam name="A">Input list type</typeparam>
            <typeparam name="B">Output array type</typeparam>
            <param name="array">List to map</param>
            <param name="map">The mapping method</param>
            <returns>A new array with the same length as the input list and with mapped items</returns>
        </member>
        <member name="T:Quantum.BitStreamExtensionsCore">
            <summary>
            Bit steam extensions methods to serialize Quantum specific concrete types.
            </summary>
        </member>
        <member name="M:Quantum.BitStreamExtensionsCore.Serialize(Photon.Deterministic.IBitStream,Quantum.EntityRef@)">
            <summary>
            Serialize the <see cref="T:Quantum.EntityRef"/> value.
            </summary>
            <param name="stream">Stream</param>
            <param name="value">Value to serialize or deserialize</param>
        </member>
        <member name="M:Quantum.BitStreamExtensionsCore.Serialize(Photon.Deterministic.IBitStream,Quantum.AssetGuid@)">
            <summary>
            Serialize the <see cref="T:Quantum.AssetGuid"/> value.
            </summary>
            <param name="stream">Stream</param>
            <param name="value">Value to serialize or deserialize</param>
        </member>
        <member name="M:Quantum.BitStreamExtensionsCore.Serialize(Photon.Deterministic.IBitStream,Quantum.PlayerRef@)">
            <summary>
            Serialize the <see cref="T:Quantum.PlayerRef"/> value.
            </summary>
            <param name="stream">Stream</param>
            <param name="value">Value to serialize or deserialize</param>
        </member>
        <member name="M:Quantum.BitStreamExtensionsCore.Serialize(Photon.Deterministic.IBitStream,Quantum.AssetRef@)">
            <summary>
            Serialize the <see cref="T:Quantum.AssetRef"/> value.
            </summary>
            <param name="stream">Stream</param>
            <param name="value">Value to serialize or deserialize</param>
        </member>
        <member name="M:Quantum.BitStreamExtensionsCore.Serialize(Photon.Deterministic.IBitStream,Quantum.ComponentTypeRef@)">
            <summary>
            Serialize the <see cref="T:Quantum.ComponentTypeRef"/> value.
            </summary>
            <param name="stream">Stream</param>
            <param name="value">Value to serialize or deserialize</param>
        </member>
        <member name="M:Quantum.BitStreamExtensionsCore.Serialize``1(Photon.Deterministic.IBitStream,Quantum.AssetRef{``0}@)">
            <summary>
            Serialize the <see cref="T:Quantum.AssetRef"/> value where the asset is of type <see cref="T:Quantum.AssetObject"/>.
            </summary>
            <param name="stream">Stream</param>
            <param name="value">Value to serialize or deserialize</param>
        </member>
        <member name="T:Quantum.ByteStream">
            <summary>
            The byte stream is a class to serialize and deserialize byte-wise data.
            It's mostly used by Quantum asset serialization and deserialization.
            The data is stored inside a byte array internally.
            </summary>
        </member>
        <member name="M:Quantum.ByteStream.#ctor(System.Byte[])">
            <summary>
            Create a byte stream with a given data array.
            </summary>
            <param name="data">Data to read from or write to</param>
        </member>
        <member name="M:Quantum.ByteStream.#ctor(System.Int32)">
            <summary>
            Create a byte stream with a given capacity.
            </summary>
            <param name="capacity">The initial size of the underlying buffer.</param>
        </member>
        <member name="M:Quantum.ByteStream.#ctor">
            <summary>
            Create a byte stream with the default buffer length and default size.
            </summary>
        </member>
        <member name="M:Quantum.ByteStream.Reset">
            <summary>
            Reset the stream and clear 
            </summary>
        </member>
        <member name="M:Quantum.ByteStream.Duplicate">
            <summary>
            Duplicate the stream.
            </summary>
            <returns>A copy of the stream with a copied buffer.</returns>
        </member>
        <member name="M:Quantum.ByteStream.ToArray">
            <summary>
            Create a copy of the underlying data array.
            </summary>
            <returns>A copy of the internal data array</returns>
        </member>
        <member name="P:Quantum.ByteStream.Position">
            <summary>
            Get or set the current position in the stream.
            </summary>
        </member>
        <member name="P:Quantum.ByteStream.Data">
            <summary>
            Get or set the underlying data array.
            </summary>
        </member>
        <member name="M:Quantum.ByteStream.WriteBool(System.Boolean)">
            <summary>
            Write a bool to the byte stream.
            </summary>
            <param name="value">Bool</param>
            <returns>return the input value.</returns>
        </member>
        <member name="M:Quantum.ByteStream.ReadBool">
            <summary>
            Reads and returns a bool from the byte stream.
            </summary>
            <returns>Bool that was read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteSByte(System.SByte)">
            <summary>
            Write a singed byte to the byte stream.
            </summary>
            <param name="value">Singed byte</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadSByte">
            <summary>
            Read a signed byte from the byte stream.
            </summary>
            <returns>Signed by that was read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteByte(System.Byte)">
            <summary>
            Write a byte to the byte stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadByte">
            <summary>
            Read a byte from the byte stream.
            </summary>
            <returns>The byte value that was read from the stream.</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteShort(System.Int16)">
            <summary>
            Write a short to the byte stream.
            </summary>
            <param name="value">The value to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadShort">
            <summary>
            Read a short from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteChar(System.Char)">
            <summary>
            Write a char to the byte stream.
            </summary>
            <param name="value">The value to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadChar">
            <summary>
            Read a char from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteUShort(System.UInt16)">
            <summary>
            Write a unsigned short to the byte stream.
            </summary>
            <param name="value">The value to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadUShort">
            <summary>
            Read an unsigned short from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.Write7BitEncodedInt(System.Int32)">
            <summary>
            Writes an integer in a compressed format to the byte stream.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Quantum.ByteStream.WriteInt(System.Int32)">
            <summary>
            Write an integer to the byte stream.
            </summary>
            <param name="value">The value to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.Read7BitEncodedInt">
            <summary>
            Read an integer in compressed format from the byte stream.
            </summary>
            <returns></returns>
            <exception cref="T:System.FormatException">Is raised when the stream is corrupted</exception>
        </member>
        <member name="M:Quantum.ByteStream.ReadInt">
            <summary>
            Read an integer from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteUInt(System.UInt32)">
            <summary>
            Write an unsigned integer to the byte stream.
            </summary>
            <param name="value">The value to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadUInt">
            <summary>
            Read an unsigned short from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteULong(System.UInt64)">
            <summary>
            Write an unsigned long to the byte stream.
            </summary>
            <param name="value">The value to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadULong">
            <summary>
            Read an unsigned long from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteLong(System.Int64)">
            <summary>
            Write a long to the byte stream.
            </summary>
            <param name="value">The value to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadLong">
            <summary>
            Read a long from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteByteArray(System.Byte[])">
            <summary>
            Write a byte array to the byte stream.
            </summary>
            <param name="bytes">The array to write to the stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.WriteByteArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a byte array to the byte stream.
            </summary>
            <param name="bytes">The input array</param>
            <param name="offset">The offset of the input array</param>
            <param name="count">The length of the input array to write</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadByteArray">
            <summary>
            Read a byte array from the byte stream.
            </summary>
            <returns>A new array that was read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.WriteGuid(System.Guid)">
            <summary>
            Write a Guid to the byte stream.
            </summary>
            <param name="guid">The Guid to write to stream.</param>
        </member>
        <member name="M:Quantum.ByteStream.ReadGuid">
            <summary>
            Read a Guid from the byte stream.
            </summary>
            <returns>Value read from the byte stream</returns>
        </member>
        <member name="M:Quantum.ByteStream.Dispose">
            <summary>
            Dispose the byte stream.
            </summary>
        </member>
        <member name="T:Quantum.ByteStreamExtension">
            <summary>
            Byte stream extension methods.
            </summary>
        </member>
        <member name="M:Quantum.ByteStreamExtension.SerializeArrayLength``1(Quantum.ByteStream,System.Boolean,``0[],System.Boolean)">
            <summary>
            Serialize or deserialize an array from the byte stream.
            </summary>
            <typeparam name="T">Type of array</typeparam>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="array">Source array</param>
            <param name="varInt">Use int compression</param>
            <returns>The input array</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.SerializeString(Quantum.ByteStream,System.Boolean,System.String)">
            <summary>
            Write or read a string to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to serialize or deserialize</param>
            <returns>The value that was read or written</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.SerializeByteArray(Quantum.ByteStream,System.Boolean,System.Byte[])">
            <summary>
            Write or read a byte array to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="array">The array to write or read</param>
            <returns>The value that was read or written</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.SerializeIntArray(Quantum.ByteStream,System.Boolean,System.Int32[],System.Boolean)">
            <summary>
            Write or load an integer array to or from the byte stream
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="array">Source array</param>
            <param name="varInt">Use var int compression</param>
            <returns>The input array</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.Byte*,System.Int32)">
            <summary>
            Write or read a byte array to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="ptr">Pointer to byte array</param>
            <param name="size">Byte array lengh</param>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,Quantum.Button)">
            <summary>
            Write or read a Button value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.Boolean)">
            <summary>
            Write or read a bool value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.Byte)">
            <summary>
            Write or read a byte value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.SByte)">
            <summary>
            Write or read a signed byte value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.Char)">
            <summary>
            Write or read a char value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.UInt16)">
            <summary>
            Write or read an unsigned short value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.Int16)">
            <summary>
            Write or read a short value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.UInt32)">
            <summary>
            Write or read an unsigned integer value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Write or read an integer value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <param name="varInt">Use int compression</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.UInt64)">
            <summary>
            Write or read an unsigned long value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,System.Int64)">
            <summary>
            Write or read a long value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,Photon.Deterministic.FP)">
            <summary>
            Write or read a FP value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.SerializeRaw(Quantum.ByteStream,System.Boolean,Photon.Deterministic.FP)">
            <summary>
            Write or read a FP value as raw to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,Photon.Deterministic.FPVector2)">
            <summary>
            Write or read a FPVector2 value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,Photon.Deterministic.FPVector3)">
            <summary>
            Write or read a FPVector3 value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,Quantum.Physics3D.FPVector3RawInt@)">
            <summary>
            Write or read a FPVector3RawInt value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="M:Quantum.ByteStreamExtension.Serialize(Quantum.ByteStream,System.Boolean,Photon.Deterministic.FPQuaternion)">
            <summary>
            Write or read a FPQuaternion value to or from the byte stream.
            </summary>
            <param name="stream">Target stream</param>
            <param name="write">Stream write or read mode</param>
            <param name="value">The value to write or read</param>
            <returns>The input value or the value read from the stream</returns>
        </member>
        <member name="T:Quantum.ByteSerializerHashMapper`1">
            <summary>
            Maps value hashes to an indexed collection of previous values.
            Can be used in combination with a <see cref="T:Quantum.ByteStream"/> to avoid serializing the same value multiple times.
            </summary>
            <typeparam name="T">
            The type of the value to be serialized/hashed.
            Must have a deterministic <see cref="M:System.ValueType.GetHashCode"/> implementation.
            Ideally should also override <see cref="M:System.ValueType.GetHashCode"/> in order to avoid boxing allocations.
            </typeparam>
        </member>
        <member name="M:Quantum.ByteSerializerHashMapper`1.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="capacity">Default value capacity.</param>
        </member>
        <member name="M:Quantum.ByteSerializerHashMapper`1.Clear">
            <summary>
            Clears internal structures. Must be done once before serializing or de-serializing a sequence of values.
            </summary>
        </member>
        <member name="M:Quantum.CodeDocHelper.Deconstruct(System.Int32@)">
            <summary>
            Tuple-like deconstructor method for this struct.
            </summary>
        </member>
        <member name="F:Quantum.CodeDocHelper.SIZE">
            <summary>
            The size of the type in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="M:Quantum.CodeDocHelper.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified value.
            </summary>
            <param name="obj">A value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>"
        </member>
        <member name="M:Quantum.CodeDocHelper.GetHashCode">
            <summary>
            Overrides the default hash function.
            </summary>
            <returns>A hash code for the current object.</returns>"
        </member>
        <member name="M:Quantum.CodeDocHelper.op_Equality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)">
            <summary>
            Operator override for which checks if two instances of REPLACE are equal.
            </summary>
            <returns><see langword="true"/> if the instances are equal.</returns>"
        </member>
        <member name="M:Quantum.CodeDocHelper.op_Inequality(Quantum.CodeDocHelper,Quantum.CodeDocHelper)">
            <summary>
            Operator override for which checks if two instances of REPLACE are not equal.
            </summary>
            <returns><see langword="true"/> if the instances are not equal.</returns>"
        </member>
        <member name="M:Quantum.CodeDocHelper.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the instance.</param>
            <param name="stream">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="T:Quantum.ColorRGBA">
            <summary>
            Quantum representation of a color with 4 channels (R, G, B, A) each represented by a byte.
            </summary>
        </member>
        <member name="T:Quantum.ColorRGBA.EqualityComparer">
            <summary>
            The equality comparer for <see cref="T:Quantum.ColorRGBA"/> instances.
            </summary>
        </member>
        <member name="F:Quantum.ColorRGBA.EqualityComparer.Instance">
            <summary>
            Singleton instance of the <see cref="T:Quantum.ColorRGBA.EqualityComparer"/> class.
            </summary>
        </member>
        <member name="M:Quantum.ColorRGBA.EqualityComparer.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Red">
            <summary>
            Create the color red.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Blue">
            <summary>
            Create the color blue.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Gray">
            <summary>
            Create the color grey.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Cyan">
            <summary>
            Create the color cyan.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.White">
            <summary>
            Create the color white.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Green">
            <summary>
            Create the color green.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Yellow">
            <summary>
            Create the color yellow.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Magenta">
            <summary>
            Create the color magenta.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Black">
            <summary>
            Create the color black.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.Lightgray">
            <summary>
            Create the color light grey.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.ColliderGreen">
            <summary>
            Create the default collider color green.
            </summary>
        </member>
        <member name="P:Quantum.ColorRGBA.ColliderBlue">
            <summary>
            Create the default collider color blue.
            </summary>
        </member>
        <member name="F:Quantum.ColorRGBA.R">
            <summary>
            The red channel of the color.
            </summary>
        </member>
        <member name="F:Quantum.ColorRGBA.G">
            <summary>
            The green channel of the color.
            </summary>
        </member>
        <member name="F:Quantum.ColorRGBA.B">
            <summary>
            The blue channel of the color.
            </summary>
        </member>
        <member name="F:Quantum.ColorRGBA.A">
            <summary>
            The alpha channel of the color.
            </summary>
        </member>
        <member name="F:Quantum.ColorRGBA.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="M:Quantum.ColorRGBA.#ctor(System.String)">
            <summary>
            Create a color from a string that encode a color with hex values.
            E.g. #FF0000 for red or #FF0000FF for red with full alpha.
            The leading '#' sign is optional.
            </summary>
            <param name="hex">String representing the hex color</param>
        </member>
        <member name="M:Quantum.ColorRGBA.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a color with defining each channel. Alpha is set to 255.
            </summary>
            <param name="r">Byte representing the red color</param>
            <param name="g">Byte representing the green color</param>
            <param name="b">Byte representing the blue color</param>
        </member>
        <member name="M:Quantum.ColorRGBA.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a color with defining each channel. Alpha is set to 255.
            </summary>
            <param name="r">Byte representing the red color</param>
            <param name="g">Byte representing the green color</param>
            <param name="b">Byte representing the blue color</param>
            <param name="a">Byte representing the alpha channel</param>
        </member>
        <member name="M:Quantum.ColorRGBA.Lerp(Quantum.ColorRGBA,Quantum.ColorRGBA,Photon.Deterministic.FP)">
            <summary>
            Linearly interpolates between a and b by t.
            The parameter t is clamped to the range [0, 1].
            </summary>
            <param name="a">Start color</param>
            <param name="b">End color</param>
            <param name="t">The interpolation value between the two floats.</param>
            <returns>Lerped color</returns>
        </member>
        <member name="M:Quantum.ColorRGBA.LerpUnclamped(Quantum.ColorRGBA,Quantum.ColorRGBA,Photon.Deterministic.FP)">
            <summary>
            Linearly interpolates between a and b by t.
            </summary>
            <param name="a">Start color</param>
            <param name="b">End color</param>
            <param name="t">The interpolation value between the two floats.</param>
            <returns>Lerped color</returns>
        </member>
        <member name="M:Quantum.ColorRGBA.GetHashCode">
            <summary>
            Override GetHashCode. 
            </summary>
            <returns>Unique hashcode</returns>
        </member>
        <member name="M:Quantum.ColorRGBA.Equals(System.Object)">
            <summary>
            Override Equals method.
            </summary>
            <param name="obj">Other color</param>
            <returns><see langword="true"/> when both colors are equal</returns>
        </member>
        <member name="M:Quantum.ColorRGBA.ToString">
            <summary>
            Override ToString method to debug output readable class members.
            </summary>
            <returns>Debug string</returns>
        </member>
        <member name="M:Quantum.ColorRGBA.Equals(Quantum.ColorRGBA)">
            <summary>
            Override Equals method.
            </summary>
            <param name="other">Other color</param>
            <returns><see langword="true"/> when both colors are equal</returns>
        </member>
        <member name="M:Quantum.ColorRGBA.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.ColorRGBA"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.ColorRGBA"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.ColorRGBA.SetA(System.Byte)">
            <summary>
            Create a copy of the color and set the alpha channel.
            </summary>
            <param name="a">New alpha value</param>
            <returns>A copy of the color</returns>
        </member>
        <member name="M:Quantum.ColorRGBA.op_Implicit(Quantum.ColorRGBA)~UnityEngine.Color32">
            <summary>
            Cast a UnityEngine.Color into a ColorRGBA.
            </summary>
            <param name="clr"></param>
        </member>
        <member name="P:Quantum.ColorRGBA.AsColor">
            <summary>
            Cast color into a UnityEngine.Color.
            </summary>
        </member>
        <member name="T:Quantum.Draw">
            <summary>
            Issues a debug shape to be drawn in Unity. 
            The shape drawing is based on the DEBUG define which is enabled in UnityEditor and development builds.
            Can be globally toggled of by using DebugDraw.IsEnabled in Unity.
            Different implementation can be attached using <see cref="M:Quantum.Draw.Init(System.Action{Quantum.Draw.DebugRay},System.Action{Quantum.Draw.DebugLine},System.Action{Quantum.Draw.DebugCircle},System.Action{Quantum.Draw.DebugSphere},System.Action{Quantum.Draw.DebugRectangle},System.Action{Quantum.Draw.DebugBox},System.Action{Quantum.Draw.DebugCapsule},System.Action{Quantum.Draw.DebugText},System.Action)"/>.
            </summary>
        </member>
        <member name="T:Quantum.Draw.DebugLine">
            <summary>
            Stores information to draw the debug shape line.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugLine.Start">
            <summary>
            Start point of the line.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugLine.End">
            <summary>
            End point of the line.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugLine.Color">
            <summary>
            Line color
            </summary>
        </member>
        <member name="T:Quantum.Draw.DebugRay">
            <summary>
            Stores information to draw the debug shape ray.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRay.Origin">
            <summary>
            World origin of the ray.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRay.Direction">
            <summary>
            Direction of the ray.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRay.Color">
            <summary>
            Ray color.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.Scaling.Fixed">
            <summary>
            Scale does not change based on distance.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.Scaling.World">
            <summary>
            Scale changes depending on distance from camera.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.Position">
            <summary>
            World position of the text
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.Text">
            <summary>
            The text to display.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.Size">
            <summary>
            The font size
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.Color">
            <summary>
            The primary color of the text.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.BackgroundColor">
            <summary>
            The optional background color of the text.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugText.DrawScaling">
            <summary>
            The scaling mode to use for the text.
            </summary>
        </member>
        <member name="T:Quantum.Draw.DebugCircle">
            <summary>
            Stores information to draw the debug shape circle.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCircle.Radius">
            <summary>
            The circle radius.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCircle.Center">
            <summary>
            The world position of the circle center.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCircle.Rotation">
            <summary>
            The rotation of the circle when drawing in 3D.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCircle.Color">
            <summary>
            The circle color.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCircle.Wire">
            <summary>
            Draw the circle as a wireframe.
            </summary>
        </member>
        <member name="T:Quantum.Draw.DebugSphere">
            <summary>
            Stores information to draw the debug shape sphere.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugSphere.Radius">
            <summary>
            The sphere radius.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugSphere.Center">
            <summary>
            The world position of the sphere center.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugSphere.Color">
            <summary>
            The sphere color.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugSphere.Wire">
            <summary>
            Draw the sphere as a wireframe.
            </summary>
        </member>
        <member name="T:Quantum.Draw.DebugRectangle">
            <summary>
            Stores information to draw the debug shape rectangle.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRectangle.Size">
            <summary>
            The size of the rectangle.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRectangle.Center">
            <summary>
            The world position of the rectangle center.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRectangle.Rotation">
            <summary>
            The rotation of the rectangle.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRectangle.Rotation2D">
            <summary>
            The rotation of the rectangle in 2D.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRectangle.Color">
            <summary>
            The color of the rectangle.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRectangle.Wire">
            <summary>
            Draw the rectangle as a wireframe.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugRectangle.Is2D">
            <summary>
            Indicates that the capsule is 2D.
            </summary>
        </member>
        <member name="T:Quantum.Draw.DebugBox">
            <summary>
            Stores information to draw the debug shape box.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugBox.Size">
            <summary>
            The size of the box.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugBox.Center">
            <summary>
            The world position of the box center.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugBox.Rotation">
            <summary>
            The rotation of the box.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugBox.Color">
            <summary>
            The color of the box.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugBox.Wire">
            <summary>
            Draw the box as a wireframe.
            </summary>
        </member>
        <member name="T:Quantum.Draw.DebugCapsule">
            <summary>
            Stores information to draw the debug shape capsule.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCapsule.Center">
            <summary>
            The world position of the capsule center.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCapsule.Rotation">
            <summary>
            The rotation of the capsule.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCapsule.Extent">
            <summary>
            The extent of the capsule.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCapsule.Radius">
            <summary>
            The radius of the capsule.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCapsule.Color">
            <summary>
            The color of the capsule.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCapsule.Wire">
            <summary>
            Draw the capsule as a wireframe.
            </summary>
        </member>
        <member name="F:Quantum.Draw.DebugCapsule.Is2D">
            <summary>
            Indicates that the capsule is 2D.
            </summary>
        </member>
        <member name="P:Quantum.Draw.DebugCapsule.Height">
            <summary>
            Calculate the height of the capsule.
            </summary>
        </member>
        <member name="P:Quantum.Draw.DebugCapsule.Diameter">
            <summary>
            Calculate the diameter of the capsule.
            </summary>
        </member>
        <member name="M:Quantum.Draw.Init(System.Action{Quantum.Draw.DebugRay},System.Action{Quantum.Draw.DebugLine},System.Action{Quantum.Draw.DebugCircle},System.Action{Quantum.Draw.DebugSphere},System.Action{Quantum.Draw.DebugRectangle},System.Action{Quantum.Draw.DebugBox},System.Action{Quantum.Draw.DebugCapsule},System.Action{Quantum.Draw.DebugText},System.Action)">
            <summary>
            Initializes the debug draw system with the given draw functions.
            </summary>
            <param name="drawRay">Draw ray method</param>
            <param name="drawLine">Draw line method</param>
            <param name="drawCircle">Draw circle method</param>
            <param name="drawSphere">Draw sphere method</param>
            <param name="drawRectangle">Draw rectangle method</param>
            <param name="drawBox">Draw box method</param>
            <param name="drawCapsule">Draw capsule method</param>
            <param name="drawText">Draw text method</param>
            <param name="clear">Clear all queued debug shapes</param>
        </member>
        <member name="M:Quantum.Draw.Init(System.Action{Quantum.Draw.DebugRay},System.Action{Quantum.Draw.DebugLine},System.Action{Quantum.Draw.DebugCircle},System.Action{Quantum.Draw.DebugSphere},System.Action{Quantum.Draw.DebugRectangle},System.Action{Quantum.Draw.DebugBox},System.Action{Quantum.Draw.DebugCapsule},System.Action)">
            <summary>
            Obsolete. Use the Init method with the text drawer.
            </summary>
        </member>
        <member name="M:Quantum.Draw.Init(System.Action{Quantum.Draw.DebugRay},System.Action{Quantum.Draw.DebugLine},System.Action{Quantum.Draw.DebugCircle},System.Action{Quantum.Draw.DebugSphere},System.Action{Quantum.Draw.DebugRectangle},System.Action{Quantum.Draw.DebugBox},System.Action)">
            <summary>
            Obsolete. Use the Init method with the capsule drawer.
            </summary>
        </member>
        <member name="M:Quantum.Draw.Reset">
            <summary>
            Remove all draw actions.
            </summary>
        </member>
        <member name="M:Quantum.Draw.Clear">
            <summary>
            Executes the clear action.
            </summary>
        </member>
        <member name="M:Quantum.Draw.Shape(Quantum.Core.FrameBase,Quantum.Shape2D@,Photon.Deterministic.FPVector2,System.Nullable{Photon.Deterministic.FP},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a shape from a 2D shape config.
            Only included in DEBUG builds.
            </summary>
            <param name="f">The frame</param>
            <param name="shape">Shape reference to draw</param>
            <param name="center">The world position of the shape</param>
            <param name="rotation">The rotation of the shape, can be <see langword="null"/></param>
            <param name="color">The color, can be <see langword="null"/></param>
            <param name="wire">Draw the shape as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Shape(Quantum.Core.FrameBase,Quantum.Shape3D@,Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPQuaternion},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a shape from a 3D shape config.
            Only included in DEBUG builds.
            </summary>
            <param name="f">The frame</param>
            <param name="shape">Shape reference to draw</param>
            <param name="center">The world position of the shape</param>
            <param name="rotation">The rotation of the shape, can be <see langword="null"/></param>
            <param name="color">The color, can be <see langword="null"/></param>
            <param name="wire">Draw the shape as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Text(System.String,Photon.Deterministic.FPVector3,System.Int32,System.Nullable{Quantum.ColorRGBA},System.Nullable{Quantum.ColorRGBA},Quantum.Draw.DebugText.Scaling)">
            <summary>
            Draw a text box at the given position
            </summary>
            <param name="text"></param>
            <param name="position"></param>
            <param name="fontSize"></param>
            <param name="color"></param>
            <param name="backgroundColor"></param>
            <param name="drawScaling"></param>
        </member>
        <member name="M:Quantum.Draw.Ray(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Nullable{Quantum.ColorRGBA})">
            <summary>
            Draw a 2D debug ray in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="origin">World origin of the ray.</param>
            <param name="direction">Direction of the ray.</param>
            <param name="color">Ray color</param>
        </member>
        <member name="M:Quantum.Draw.Ray(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Nullable{Quantum.ColorRGBA})">
            <summary>
            Draw a 3D debug ray in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="origin">World origin of the ray.</param>
            <param name="direction">Direction of the ray.</param>
            <param name="color">Ray color</param>
        </member>
        <member name="M:Quantum.Draw.Line(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,System.Nullable{Quantum.ColorRGBA})">
            <summary>
            Draw a 2D debug line in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="start">World start position</param>
            <param name="end">World end position</param>
            <param name="color">Line color</param>
        </member>
        <member name="M:Quantum.Draw.Line(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Nullable{Quantum.ColorRGBA})">
            <summary>
            Draw a 3D debug line in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="start">World start position</param>
            <param name="end">World end position</param>
            <param name="color">Line color</param>
        </member>
        <member name="M:Quantum.Draw.Circle(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 2D debug circle in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">World position of the circle center</param>
            <param name="radius">Radius of the circle</param>
            <param name="color">Circle color</param>
            <param name="wire">Draw the circle as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Circle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Nullable{Photon.Deterministic.FPQuaternion},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 3D debug circle in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">World position of the circle center</param>
            <param name="radius">Radius of the circle</param>
            <param name="rotation">Rotation of the circle</param>
            <param name="color">Circle color</param>
            <param name="wire">Draw the circle as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Sphere(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 3D debug sphere in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">World position of the sphere center</param>
            <param name="radius">Sphere radius</param>
            <param name="color">Sphere color</param>
            <param name="wire">Draw the sphere as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Rectangle(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 2D debug rectangle in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">World position of the rectangle center</param>
            <param name="size">Rectangle size</param>
            <param name="rotation">Rectangle rotation</param>
            <param name="color">Rectangle color</param>
            <param name="wire">Draw the rectangle as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Rectangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector2,Photon.Deterministic.FPQuaternion,System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 3D debug rectangle in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">World position of the rectangle center</param>
            <param name="size">Rectangle size</param>
            <param name="rotation">Rectangle rotation</param>
            <param name="color">Rectangle color</param>
            <param name="wire">Draw the rectangle as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Quad(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FPQuaternion,System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 3D debug quad in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">The world position of the quad center</param>
            <param name="extents">The extents of the quad</param>
            <param name="rotation">The rotation of the quad</param>
            <param name="color">The quad color</param>
            <param name="wire">Draw the quad as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Capsule(Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Photon.Deterministic.FP,System.Nullable{Photon.Deterministic.FP},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 2DD debug capsule in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">The center of the capsule</param>
            <param name="extent">The extents of the capsule</param>
            <param name="radius">The radius of the capsule</param>
            <param name="rotation">The rotation of the capsule</param>
            <param name="color">The capsule color</param>
            <param name="wire">Draw the capsule as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Capsule(Photon.Deterministic.FPVector2,Quantum.Shape2D.CapsuleShape,System.Nullable{Photon.Deterministic.FP},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 2D debug capsule in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">The center of the capsule</param>
            <param name="capsule">The capsule shape</param>
            <param name="rotation">The rotation of the capsule</param>
            <param name="color">The capsule color</param>
            <param name="wire">Draw the capsule as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Capsule(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,Photon.Deterministic.FP,System.Nullable{Photon.Deterministic.FPQuaternion},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 3D debug capsule in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">The center of the capsule</param>
            <param name="extent">The extents of the capsule</param>
            <param name="radius">The radius of the capsule</param>
            <param name="rotation">The rotation of the capsule</param>
            <param name="color">The capsule color</param>
            <param name="wire">Draw the capsule as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.Capsule(Photon.Deterministic.FPVector3,Quantum.Shape3D.CapsuleShape,System.Nullable{Photon.Deterministic.FPQuaternion},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Draw a 3D debug capsule in the view.
            Only included in DEBUG builds.
            </summary>
            <param name="center">The center of the capsule</param>
            <param name="capsule">Capsule shape</param>
            <param name="rotation">The rotation of the capsule</param>
            <param name="color">The capsule color</param>
            <param name="wire">Draw the capsule as wireframe</param>
        </member>
        <member name="M:Quantum.Draw.WireBox(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPQuaternion},System.Nullable{Quantum.ColorRGBA})">
            <summary>
            Obsolete: use Quad
            </summary>
        </member>
        <member name="M:Quantum.Draw.Box(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,System.Nullable{Photon.Deterministic.FPQuaternion},System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Obsolete: use Quad
            </summary>
        </member>
        <member name="M:Quantum.Draw.Rectangle(Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Obsolete: use Rectangle(FPVector3 center, FPVector2 size, FPQuaternion rotation) or Rectangle(FPVector2 center, FPVector2 size, FP rotation)
            </summary>
        </member>
        <member name="M:Quantum.Draw.Circle(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Nullable{Quantum.ColorRGBA},System.Boolean)">
            <summary>
            Obsolete: use Circle(FPVector3 center, FP radius, FPQuaternion rotation)
            </summary>
        </member>
        <member name="T:Quantum.EnumEqualityComparer">
            <summary>
            Enum utility methods.
            </summary>
        </member>
        <member name="T:Quantum.EnumEqualityComparer.Tag">
            <summary>
            An empty struct to mark the type as a tag.
            </summary>
        </member>
        <member name="M:Quantum.EnumEqualityComparer.Equals``1(``0,``0)">
            <summary>
            Compares two enums for equality. Supports differently sized enum backing fields.
            </summary>
            <typeparam name="T">Enum type</typeparam>
            <param name="x">Enum A</param>
            <param name="y">Enum B</param>
            <returns><see langword="true"/> if enum values are equal</returns>
        </member>
        <member name="M:Quantum.EnumEqualityComparer.GetHashCode``1(``0)">
            <summary>
            Get hashcode for an enum. Supports differently sized enum backing fields.
            </summary>
            <typeparam name="T">Enum type</typeparam>
            <param name="obj">Enum value</param>
            <returns>Hashcode</returns>
        </member>
        <member name="T:Quantum.FPAnimationCurve">
            <summary>
            A deterministic discretized animation curve.
            Values between keyframes are interpolated linearly.
            </summary>
        </member>
        <member name="T:Quantum.FPAnimationCurve.WrapMode">
            <summary>
            The warp mode describes how the curve behaves outside of the defined time range.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.WrapMode.Clamp">
            <summary>
            Clamp values to the first or last keyframe.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.WrapMode.Loop">
            <summary>
            Loop the curve.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.WrapMode.PingPong">
            <summary>
            Loop the curve back and forth.
            </summary>
        </member>
        <member name="T:Quantum.FPAnimationCurve.Keyframe">
            <summary>
            Only used to recreate the curve in the Unity Editor.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.Time">
            <summary>
            Time stamp of the keyframe.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.Value">
            <summary>
            The value of the curve at keyframe.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.InTangent">
            <summary>
            Sets the incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.OutTangent">
            <summary>
            Sets the outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.TangentMode">
            <summary>
            Deprecated
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.TangentModeLeft">
            <summary>
            Deprecated
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.TangentModeRight">
            <summary>
            Deprecated
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keyframe.WeightedMode">
            <summary>
            Weighted mode for the keyframe.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Samples">
            <summary>
            The discrete samples.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.PreWrapMode">
            <summary>
            The wrap mode left of the first keyframe.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.PostWrapMode">
            <summary>
            The wrap mode right of the last keyframe.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.StartTime">
            <summary>
            The start time.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.EndTime">
            <summary>
            The end time.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Resolution">
            <summary>
            The number of discrete curve samples.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.OriginalPreWrapMode">
            <summary>
            The original PreWrapMode, used to migrate Unity versions.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.OriginalPostWrapMode">
            <summary>
            The original PostWrapMode, used to migrate Unity versions.
            </summary>
        </member>
        <member name="F:Quantum.FPAnimationCurve.Keys">
            <summary>
            
            </summary>
        </member>
        <member name="M:Quantum.FPAnimationCurve.Evaluate(Photon.Deterministic.FP)">
            <summary>
            Return the curve value at a given time.
            </summary>
            <param name="time">Time to query</param>
            <returns>The curve value at requested time</returns>
        </member>
        <member name="T:Quantum.FrameTimer">
            <summary>
            Built-in timer struct for game logic.
            </summary>
        </member>
        <member name="F:Quantum.FrameTimer.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.FrameTimer.None">
            <summary>
            Empty timer.
            </summary>
        </member>
        <member name="F:Quantum.FrameTimer.TargetFrame">
            <summary>
            The frame number at which the timer will run out.
            </summary>
        </member>
        <member name="F:Quantum.FrameTimer.StartFrame">
            <summary>
            The frame number at which the timer has started.
            </summary>
        </member>
        <member name="P:Quantum.FrameTimer.IsSet">
            <summary>
            If the timer is has been set.
            A valid timer has a <see cref="F:Quantum.FrameTimer.StartFrame"/> greater than 0
            and the target frame <see cref="F:Quantum.FrameTimer.TargetFrame"/> greater than or equal to the <see cref="F:Quantum.FrameTimer.StartFrame"/>.
            </summary>
        </member>
        <member name="M:Quantum.FrameTimer.IsRunning(Quantum.Core.FrameBase)">
            <summary>
            Is the timer set and still running.
            </summary>
            <param name="frame">The current Frame instance.</param>
            <returns>
            <see langword="true"/> if the timer is <see cref="P:Quantum.FrameTimer.IsSet">valid</see> and the current <paramref name="frame"/>> number is smaller than <see cref="F:Quantum.FrameTimer.TargetFrame"/>.
            <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:Quantum.FrameTimer.HasStoppedThisFrame(Quantum.Core.FrameBase)">
            <summary>
            Has the timer expired during this frame.
            </summary>
            <param name="frame">The current Frame instance.</param>
            <returns>
            <see langword="true"/> if the timer is not <see cref="M:Quantum.FrameTimer.IsRunning(Quantum.Core.FrameBase)">expired</see> and the current <paramref name="frame"/> number is equal to <see cref="F:Quantum.FrameTimer.TargetFrame"/>.
            <see langword="false"/> otherwise.
            </returns>
            <remarks>Useful for one time operations that happen only at timer expiry.</remarks>
        </member>
        <member name="M:Quantum.FrameTimer.RemainingFrames(Quantum.Core.FrameBase)">
            <summary>
            How many frames are remaining until the timer expires.
            </summary>
            <param name="frame">The current Frame instance.</param>
            <returns>
            <see cref="F:Quantum.FrameTimer.TargetFrame"/> - current Frame number. Never returns a negative value.
            </returns>
        </member>
        <member name="M:Quantum.FrameTimer.RemainingSeconds(Quantum.Core.FrameBase)">
            <summary>
            How much time is remaining until the timer expires in seconds.
            </summary>
            <param name="frame">The current Frame instance.</param>
            <returns>
            Multiplies the remaining frame count by the frame delta time.
            </returns>
        </member>
        <member name="M:Quantum.FrameTimer.ElapsedFrames(Quantum.Core.FrameBase)">
            <summary>
            How many frames or ticks since the timer was started.
            </summary>
            <param name="frame">The current Frame instance.</param>
            <returns>
            Returns current frame number - the start frame number. Never returns a negative value.
            </returns>
        </member>
        <member name="M:Quantum.FrameTimer.ElapsedSeconds(Quantum.Core.FrameBase)">
            <summary>
            How long since the timer has started in seconds.
            </summary>
            <param name="frame">The current Frame instance.</param>
            <returns>
            Returns the timer since the timer start. Never returns a negative value.
            </returns>
        </member>
        <member name="M:Quantum.FrameTimer.Restart(Quantum.Core.FrameBase)">
            <summary>
            Restarts the timer.
            </summary>
            <param name="frame">The current Frame instance.</param>
        </member>
        <member name="M:Quantum.FrameTimer.FromSeconds(Quantum.Core.FrameBase,Photon.Deterministic.FP)">
            <summary>
            Create a new timer from a delay in seconds.
            </summary>
            <param name="frame"></param>
            <param name="durationInSeconds"></param>
            <returns>A new <see cref="T:Quantum.FrameTimer"/> instance with the specified duration.</returns>
        </member>
        <member name="M:Quantum.FrameTimer.FromFrames(Quantum.Core.FrameBase,System.Int32)">
            <summary>
            Create a new timer from a delay in frames.
            </summary>
            <param name="frame">The current Frame instance.</param>
            <param name="durationInFrames">The number of frames to wait before the timer expires.</param>
            <returns>A new <see cref="T:Quantum.FrameTimer"/> instance with the specified duration.</returns>
        </member>
        <member name="M:Quantum.FrameTimer.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.FrameTimer"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.FrameTimer"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.FrameTimer.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.HashCodeUtils">
            <summary>
            Hashcode generation utilities.
            </summary>
        </member>
        <member name="M:Quantum.HashCodeUtils.CombineHashCodes(System.Int32,System.Int32)">
            <summary>
            Create a hashcode from two integers.
            </summary>
            <param name="a">Integer One</param>
            <param name="b">Integer Two</param>
            <returns>Hashcode of two ints</returns>
        </member>
        <member name="M:Quantum.HashCodeUtils.CombineHashCodes(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a hashcode from three integers.
            </summary>
            <param name="a">Integer One</param>
            <param name="b">Integer Two</param>
            <param name="c">Integer Three</param>
            <returns>Hashcode of three ints</returns>
        </member>
        <member name="M:Quantum.HashCodeUtils.Int64HashCode(System.Int64)">
            <summary>
            Create a hashcode from a long.
            </summary>
            <param name="value">Input value</param>
            <returns>Hashcode</returns>
        </member>
        <member name="M:Quantum.HashCodeUtils.UInt64HashCode(System.UInt64)">
            <summary>
            Create a hashcode from an unsigned long.
            </summary>
            <param name="value">Input value</param>
            <returns>Hashcode</returns>
        </member>
        <member name="M:Quantum.HashCodeUtils.GetArrayHashCode``1(``0*,System.Int32,System.Int32)">
            <summary>
            Create a hashcode from an array.
            </summary>
            <typeparam name="T">Type of array</typeparam>
            <param name="ptr">Pointer to array</param>
            <param name="length">Length of the array</param>
            <param name="initialHash">Initial hashcode value</param>
            <returns>Hashcode</returns>
        </member>
        <member name="M:Quantum.HashCodeUtils.GetArrayHashCode``1(Quantum.FixedArray{``0}@,System.Int32)">
            <summary>
            Create a hashcode from a fixed array.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <param name="arr">Input array</param>
            <param name="initialHash">Initial hash value</param>
            <returns>Hashcode</returns>
        </member>
        <member name="T:Quantum.InputDirection">
            <summary>
            Compressed direction (always normalized) to be used as part of input to optimize bandwidth, encoded as an angle using a single byte (2 degrees of accuracy).
            </summary>
        </member>
        <member name="F:Quantum.InputDirection.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.InputDirection._encodedAngle">
            <summary>
            The angle encoded as a byte (0 means default/zeroed vector).
            </summary>
        </member>
        <member name="M:Quantum.InputDirection.op_Implicit(Quantum.InputDirection)~Photon.Deterministic.FPVector2">
            <summary>
            Casts to normalized FPVector2. Defaults to zero-vector.
            </summary>
        </member>
        <member name="M:Quantum.InputDirection.op_Implicit(Photon.Deterministic.FPVector2)~Quantum.InputDirection">
            <summary>
            Casts from normalized FPVector2 into encoded angle.
            </summary>
        </member>
        <member name="M:Quantum.InputDirection.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes an <see cref="T:Quantum.InputDirection"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.InputDirection"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.InputDirection.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.InputDirectionMagnitude">
            <summary>
            Compressed direction with magnitude (range 0 to 1) to be used as part of input to optimize bandwidth, encoded as an angle and magnitude using two bytes.
            </summary>
        </member>
        <member name="F:Quantum.InputDirectionMagnitude.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.InputDirectionMagnitude._encodedAngle">
            <summary>
            The angle encoded as a byte (0 means default/zeroed vector).
            </summary>
        </member>
        <member name="F:Quantum.InputDirectionMagnitude._encodedMagnitude">
            <summary>
            The magnitude encoded as a byte (range 0 - 1).
            </summary>
        </member>
        <member name="M:Quantum.InputDirectionMagnitude.op_Implicit(Quantum.InputDirectionMagnitude)~Photon.Deterministic.FPVector2">
            <summary>
            Casts to FPVector2 with magnitude (range 0 to 1). Defaults to zero-vector.
            </summary>
        </member>
        <member name="M:Quantum.InputDirectionMagnitude.op_Implicit(Photon.Deterministic.FPVector2)~Quantum.InputDirectionMagnitude">
            <summary>
            Casts from FPVector2 into encoded angle and magnitude (must be in the range 0 to 1).
            </summary>
        </member>
        <member name="M:Quantum.InputDirectionMagnitude.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes an <see cref="T:Quantum.InputDirectionMagnitude"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.InputDirectionMagnitude"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.InputDirectionMagnitude.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.InputPitchYaw">
            <summary>
            Compressed pitch + yaw angles (ranges -89 to 89 and -+ 180)) to be used as part of input to optimize bandwidth, encoded as two shorts.
            </summary>
        </member>
        <member name="F:Quantum.InputPitchYaw.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="P:Quantum.InputPitchYaw.Pitch">
            <summary>
            Mouse-look pitch (Euler X, clamped to -90, 90).
            </summary>
        </member>
        <member name="P:Quantum.InputPitchYaw.Yaw">
            <summary>
            Mouse-look Yaw (Euler Y, clamped to -90, 90).
            </summary>
        </member>
        <member name="P:Quantum.InputPitchYaw.LookRotation">
            <summary>
            Generates an FPQuaternion using Pitch and Yaw as Euler X and Y respectively.
            </summary>
        </member>
        <member name="M:Quantum.InputPitchYaw.Serialize(System.Void*,Photon.Deterministic.IDeterministicFrameSerializer)">
            <summary>
            Serializes an <see cref="T:Quantum.InputPitchYaw"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.InputPitchYaw"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.InputPitchYaw.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.LayerInfo">
            <summary>
            Physics layer information.
            </summary>
        </member>
        <member name="P:Quantum.LayerInfo.DefaultLayerMatrix">
            <summary>
            Returns the default layer matrix.
            </summary>
        </member>
        <member name="M:Quantum.LayerInfo.#ctor(System.String[],System.Int32[])">
            <summary>
            Creates a new LayerInfo instance.
            </summary>
            <param name="layers">Available names layers</param>
            <param name="defaultMatrix">The default matrix</param>
        </member>
        <member name="M:Quantum.LayerInfo.LayerExists(System.String)">
            <summary>
            Checks if the layer name exists.
            </summary>
            <param name="name">Layer name</param>
            <returns><see langword="true"/> if the layer name exists</returns>
        </member>
        <member name="M:Quantum.LayerInfo.GetLayerIndex(System.String)">
            <summary>
            Converts a layer name to the layer index.
            </summary>
            <param name="name">Layer name</param>
            <returns>Layer index or -1 if layer name was not found</returns>
        </member>
        <member name="M:Quantum.LayerInfo.GetLayerMask(System.String)">
            <summary>
            Get the layer mask for a layer name.
            </summary>
            <param name="layer">Layer name</param>
            <returns>Layer mask for a given layer</returns>
        </member>
        <member name="M:Quantum.LayerInfo.GetLayerMask(System.String,System.String)">
            <summary>
            Get the combined layer mask for two layer names.
            </summary>
            <param name="layer0">Layer name one</param>
            <param name="layer1">Layer name two</param>
            <returns>A mask combined of two layers</returns>
        </member>
        <member name="M:Quantum.LayerInfo.GetLayerMask(System.String,System.String,System.String)">
            <summary>
            Get the combined layer mask for three layer names.
            </summary>
            <param name="layer0">Layer name one</param>
            <param name="layer1">Layer name two</param>
            <param name="layer2">Layer name three</param>
            <returns>A mask combined of three layers</returns>
        </member>
        <member name="M:Quantum.LayerInfo.GetLayerMask(System.String[])">
            <summary>
            Get the combined layer mask for multiple layer names.
            </summary>
            <param name="layers">Multiple layer names</param>
            <returns>A layer mask combined of input layer names</returns>
        </member>
        <member name="M:Quantum.LayerInfo.GetLayerName(System.Int32)">
            <summary>
            Convert the layer index to a layer name.
            </summary>
            <param name="index">Layer index</param>
            <returns>Layer name or "" if the index could not be mapped to name</returns>
        </member>
        <member name="T:Quantum.LayerMask">
            <summary>
            The Quantum physics layer mask used with <see cref="T:Quantum.LayerValue"/>.
            </summary>
        </member>
        <member name="F:Quantum.LayerMask.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.LayerMask.BitMask">
            <summary>
            The bit mask of the layer saved on the frame.
            </summary>
        </member>
        <member name="M:Quantum.LayerMask.op_Implicit(Quantum.LayerMask)~System.Int32">
            <summary>
            Cast a LayerMask struct to an integer.
            </summary>
            <param name="mask">Input layer mask</param>
        </member>
        <member name="M:Quantum.LayerMask.op_Implicit(System.Int32)~Quantum.LayerMask">
            <summary>
            Case an integer to a LayerMask struct.
            </summary>
            <param name="mask">Input integer</param>
        </member>
        <member name="M:Quantum.LayerMask.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.LayerMask"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.LayerMask"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.LayerMask.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.LayerValue">
            <summary>
            The Quantum physics layer value used with <see cref="T:Quantum.LayerMask"/>.
            </summary>
        </member>
        <member name="F:Quantum.LayerValue.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.LayerValue.Layer">
            <summary>
            The layer stored on the frame.
            </summary>
        </member>
        <member name="M:Quantum.LayerValue.op_Implicit(Quantum.LayerValue)~System.Int32">
            <summary>
            Cast a layer value to an integer.
            </summary>
            <param name="value">Input layer value</param>
        </member>
        <member name="M:Quantum.LayerValue.op_Implicit(System.Int32)~Quantum.LayerValue">
            <summary>
            Cast a integer to a layer value.
            </summary>
            <param name="value">Input int</param>
        </member>
        <member name="M:Quantum.LayerValue.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.LayerValue"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.LayerValue"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.LayerValue.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.MailboxSet8">
            <summary>
            A utility class to optimize periodic checks by saving a iteration value for each index of the initial capacity.
            </summary>
        </member>
        <member name="P:Quantum.MailboxSet8.Capacity">
            <summary>
            The size of the mailbox buffer.
            </summary>
        </member>
        <member name="M:Quantum.MailboxSet8.#ctor(System.Int32,Photon.Deterministic.Native.Allocator)">
            <summary>
            Create a mailbox buffer with a given capacity.
            Allocates one byte per Capacity.
            </summary>
            <param name="capacity">Capacity</param>
            <param name="allocator">Memory allocator.</param>
        </member>
        <member name="M:Quantum.MailboxSet8.Dispose(Photon.Deterministic.Native.Allocator)">
            <summary>
            Dispose and free memory.
            </summary>
            <param name="allocator">Allocator</param>
        </member>
        <member name="M:Quantum.MailboxSet8.SetCapacity(System.Int32,Photon.Deterministic.Native.Allocator)">
            <summary>
            Set the capacity of the mailbox buffer.
            </summary>
            <param name="capacity">New Capacity</param>
            <param name="allocator">Allocator</param>
        </member>
        <member name="M:Quantum.MailboxSet8.StartSearch">
            <summary>
            Start a new search by incrementing the key.
            Will reset the mailbox buffer and restart at 0 when overflowing the byte (255).
            </summary>
        </member>
        <member name="M:Quantum.MailboxSet8.AlreadyChecked(System.Int32)">
            <summary>
            Check if a certain index has already been checked this pass.
            Will set the index to the current key if it was not checked yet.
            </summary>
            <param name="index">Index to check, must be <see cref="P:Quantum.MailboxSet8.Capacity"/></param>
            <returns><see langword="true"/> if the index was already processed this key</returns>
        </member>
        <member name="M:Quantum.MailboxSet8.ShouldCheck(System.Int32)">
            <summary>
            Check if a certain index has already not been checked this pass.
            Will set the index to the current key if it was not checked yet.
            </summary>
            <param name="index">Index to check, must be <see cref="P:Quantum.MailboxSet8.Capacity"/></param>
            <returns><see langword="true"/> if the index was not already processed this key</returns>
        </member>
        <member name="T:Quantum.MemoryLayoutVerifier">
            <summary>
            Verifies the memory layout of types and detects any potential issues.
            </summary>
        </member>
        <member name="F:Quantum.MemoryLayoutVerifier.Platform">
            <summary>
            The current platform used to resolve memory layout.
            </summary>
        </member>
        <member name="T:Quantum.MemoryLayoutVerifier.IPlatform">
            <summary>
            Represents a platform that can resolve the memory layout of types and detect any potential issues.
            </summary>
        </member>
        <member name="T:Quantum.MemoryLayoutVerifier.DefaultPlatform">
            <summary>
            The default platform implementation.
            </summary>
        </member>
        <member name="M:Quantum.MemoryLayoutVerifier.#ctor(Quantum.MemoryLayoutVerifier.IPlatform)">
            <summary>
            Creates a new instance of the <see cref="T:Quantum.MemoryLayoutVerifier"/> class.
            </summary>
        </member>
        <member name="M:Quantum.MemoryLayoutVerifier.IsFixedBuffer(System.Reflection.FieldInfo)">
            <summary>
            Checks if a field is a fixed buffer.
            </summary>
            <param name="field">The field to inspect.</param>
            <returns><see langword="true"/> if the field is a fixed buffer; <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Quantum.MemoryLayoutVerifier.GetFieldOffset(System.Reflection.FieldInfo)">
            <summary>
            Returns the offset of a field in memory.
            </summary>
            <param name="field">The field for which to retrieve the offset.</param>
            <returns>The offset of the field in memory.</returns>
            <exception cref="T:System.Exception">Thrown if the field does not have the [FieldOffset] attribute.</exception>
        </member>
        <member name="M:Quantum.MemoryLayoutVerifier.GetFieldOverlap(System.Reflection.FieldInfo)">
            <summary>
            Gets the overlap offset of a field.
            </summary>
            <param name="field">The field for which to get the overlap offset.</param>
            <returns>The overlap offset of the field, or <see langword="null"/> if no overlap is specified.</returns>
        </member>
        <member name="T:Quantum.PathUtils">
            <summary>
            Utility methods to work with folder and file paths.
            </summary>
        </member>
        <member name="M:Quantum.PathUtils.Combine(System.Char,System.String[])">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.PathUtils.Combine(System.String[])">
            <summary>
            Combine multiple paths. Internally calls <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>.
            </summary>
            <param name="paths">Path to combine.</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.PathUtils.MakeRelativeToFolder(System.String,System.String,System.String@)">
            <summary>
            Tries to make an input path relative to a folder.
            </summary>
            <param name="path">Input path to make relative</param>
            <param name="folder">Folder to make the input path relative against</param>
            <param name="result">Resulting relative path</param>
            <returns><see langword="true"/> if a relative path could be constructed</returns>
        </member>
        <member name="M:Quantum.PathUtils.MakeRelativeToFolderFast(System.String,System.String,System.String@)">
            <summary>
            Tries to make an input path relative to a folder.
            </summary>
            <param name="path">Input path to make relative</param>
            <param name="folderWithSlashes">Folder to make the input path relative against, is correctly formatted with forward slashes</param>
            <param name="result">Resulting relative path</param>
            <returns><see langword="true"/> if a relative path could be constructed</returns>
        </member>
        <member name="M:Quantum.PathUtils.GetPathWithoutExtension(System.String)">
            <summary>
            Return the path without the file extension.
            </summary>
            <param name="path">Path</param>
            <returns>New path string</returns>
        </member>
        <member name="M:Quantum.PathUtils.IsRelativeToFolder(System.String,System.String)">
            <summary>
            Check if a path is relative to a folder.
            </summary>
            <param name="path">Path to check</param>
            <param name="folder">Path to folder</param>
            <returns><see langword="true"/> if the path is relative to the folder</returns>
        </member>
        <member name="M:Quantum.PathUtils.MakeSane(System.String)">
            <summary>
            Unify path separators and replacing all different amounts of slashes to one forward slash.
            </summary>
            <param name="path">Path to normalize</param>
            <returns>Normalized path</returns>
        </member>
        <member name="T:Quantum.QBoolean">
            <summary>
            Quantum boolean type that is stored on components.
            </summary>
        </member>
        <member name="F:Quantum.QBoolean.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.QBoolean.Value">
            <summary>
            The bool value stored as an int.
            </summary>
        </member>
        <member name="M:Quantum.QBoolean.op_Implicit(Quantum.QBoolean)~System.Boolean">
            <summary>
            Case the QBoolean type to a bool.
            </summary>
            <param name="b">Bool</param>
        </member>
        <member name="M:Quantum.QBoolean.op_Implicit(System.Boolean)~Quantum.QBoolean">
            <summary>
            Case a bool to QBoolean type.
            </summary>
            <param name="b">input bool</param>
        </member>
        <member name="M:Quantum.QBoolean.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.QBoolean"/> into a <see cref="T:Quantum.FrameSerializer"/> to write or read from a frame snapshot.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.QBoolean"/>.</param>
            <param name="serializer">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
        <member name="M:Quantum.QBoolean.Print(Quantum.QBoolean*,Quantum.FramePrinter)">
            <summary>
            Prints the QBoolean using a <see cref="T:Quantum.FramePrinter"/>.
            </summary>
            <param name="ptr">Pointer to QBoolean instance</param>
            <param name="printer">Printer object</param>
        </member>
        <member name="M:Quantum.QBoolean.ToString">
            <summary>
            Converts the numeric value of this instance to its equivalent string representation.
            </summary>
            <returns>The string representation of the value of this instance</returns>
        </member>
        <member name="M:Quantum.QBoolean.Equals(Quantum.QBoolean)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified QBoolean value.
            </summary>
            <param name="other">A QBoolean value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.QBoolean.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.QBoolean.GetHashCode">
            <summary>
            Overrides the hash code generation of this type.
            </summary>
            <returns>A hash code of the current state of this instance.</returns>
        </member>
        <member name="T:Quantum.RNGExtensions">
            <summary>
            Extension methods for the RNGSession struct to provide additional random number generation functionality
            for quaternions, colors, and vectors in various geometric distributions.
            </summary>
        </member>
        <member name="M:Quantum.RNGExtensions.Rotation(Photon.Deterministic.RNGSession@)">
            <summary>
            Generates a random quaternion with each component in the range [0,1].
            </summary>
            <param name="rng">The random number generator session.</param>
            <returns>A randomly generated quaternion.</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.ColorHSV(Photon.Deterministic.RNGSession@)">
            <summary>
            Generates a random color using HSV values, converted to RGB.
            </summary>
            <param name="rng">The random number generator session.</param>
            <returns>A randomly generated color in RGBA format.</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.InUnitCircle(Photon.Deterministic.RNGSession@,System.Boolean)">
            <summary>
            Returns a random 2D vector inside the unit circle.
            </summary>
            <param name="rng">The random number generator session.</param>
            <param name="uniform">If true, distribution is uniform over the area. Note: This requires an additional
            square root operation which has a minor performance cost but provides better distribution.</param>
            <returns>A random 2D vector inside the unit circle.</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.OnUnitCircle(Photon.Deterministic.RNGSession@)">
            <summary>
            Returns a random point on the perimeter of the unit circle.
            </summary>
            <param name="rng">The random number generator session.</param>
            <returns>A random point on the unit circle perimeter.</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.InUnitSphere(Photon.Deterministic.RNGSession@,System.Boolean)">
            <summary>
            Returns a random point inside the unit sphere.
            </summary>
            <param name="rng">The random number generator session.</param>
            <param name="uniform">If true, distribution is uniform over the volume. Note: This requires
            an additional cube root calculation which has a higher performance cost but provides a statistically
            correct distribution of points throughout the volume.</param>
            <returns>A random point inside the unit sphere.</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.OnUnitSphere(Photon.Deterministic.RNGSession@,System.Boolean)">
            <summary>
            Returns a random point on the surface of the unit sphere.
            </summary>
            <param name="rng">The random number generator session.</param>
            <param name="uniform">If true, points are uniformly distributed over the surface. Note: The uniform
            distribution uses a different algorithm which has a minor performance impact but ensures points
            are not clustered at the poles of the sphere.</param>
            <returns>A random point on the unit sphere surface.</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.ConvertToByte(Photon.Deterministic.FP)">
            <summary>
            Converts a floating-point value in range [0,1] to a byte value in range [0,255].
            </summary>
            <param name="value">The floating-point value to convert.</param>
            <returns>The value converted to a byte in range [0,255].</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.HSV2RGB(Photon.Deterministic.FP,Photon.Deterministic.FP,Photon.Deterministic.FP)">
            <summary>
            Converts HSV color values to an RGB color.
            </summary>
            <param name="hue">The hue component [0,1].</param>
            <param name="saturation">The saturation component [0,1].</param>
            <param name="value">The value component [0,1].</param>
            <returns>A color in RGBA format.</returns>
        </member>
        <member name="M:Quantum.RNGExtensions.CubeRootRaw(Photon.Deterministic.FP)">
            <summary>
            Calculates the cube root of a value using Newton's method.
            </summary>
            <param name="value">The value to calculate the cube root of.</param>
            <returns>The approximate cube root of the input value.</returns>
        </member>
        <member name="T:Quantum.TypeRegistry">
            <summary>
            The Quantum type registry.
            </summary>
        </member>
        <member name="P:Quantum.TypeRegistry.Types">
            <summary>
            Creates a list of all types.
            </summary>
        </member>
        <member name="M:Quantum.TypeRegistry.#ctor">
            <summary>
            Creates a new instance of the type registry and adds built-in types.
            </summary>
        </member>
        <member name="M:Quantum.TypeRegistry.Register(System.Type,System.Int32)">
            <summary>
            Registers a type and its size.
            </summary>
            <param name="type">Type</param>
            <param name="size">Size</param>
        </member>
        <member name="T:Quantum.TypeUtils">
            <summary>
            Type reflection utility methods. Is generally slow.
            </summary>
        </member>
        <member name="M:Quantum.TypeUtils.GetSubClasses(System.Type,System.String[])">
            <summary>
            Get all types that are subclasses to the given type found inside the given assembly names.
            </summary>
            <param name="type">Input type</param>
            <param name="assemblies">Assembly names to search</param>
            <returns>A list of types that derive from the input type</returns>
        </member>
        <member name="M:Quantum.TypeUtils.GetSubClasses(System.Type,System.Reflection.Assembly[])">
            <summary>
            Get all types that are subclasses to the given type found inside the given assemblies.
            </summary>
            <param name="type">Input type</param>
            <param name="assemblies">Assemblies to search</param>
            <returns>A list of types that derive from the input type</returns>
        </member>
        <member name="M:Quantum.TypeUtils.GetSubClasses(System.Type,System.Reflection.Assembly)">
            <summary>
            Get all types that are subclasses to the given type found inside the assembly.
            </summary>
            <param name="type">Input type</param>
            <param name="asm">Assembly to search</param>
            <returns>A list of types that derive from the input type</returns>
        </member>
        <member name="M:Quantum.TypeUtils.GetTypesImplementingInterface(System.Type,System.Reflection.Assembly)">
            <summary>
            Get all types that are implementing the given interface found inside the assembly.
            </summary>
            <param name="type">Interface type</param>
            <param name="asm">Assembly to search</param>
            <returns>A list of types that derive from the input interface</returns>
        </member>
        <member name="M:Quantum.TypeUtils.GetTypesWithAttribute``1(System.String[])">
            <summary>
            Get all types annotated with the given attribute found inside the given assembly names.
            </summary>
            <typeparam name="T">Attribute type</typeparam>
            <param name="assemblies">Assemblies to search</param>
            <returns>A list of types with the given attribute</returns>
        </member>
        <member name="M:Quantum.TypeUtils.GetTypesWithAttribute``1(System.Reflection.Assembly)">
            <summary>
            Get all types annotated with the given attribute found inside the given assembly.
            </summary>
            <typeparam name="T">Attribute type</typeparam>
            <param name="asm">Assembly to search</param>
            <returns>A list of types with the given attribute</returns>
        </member>
        <member name="M:Quantum.TypeUtils.GetAttribute``1(System.Type)">
            <summary>
            Get an attribute from the type.
            </summary>
            <typeparam name="T">Attribute type</typeparam>
            <param name="t">Type to check for the attribute</param>
            <returns>The attribute or <see langword="null"/></returns>
        </member>
        <member name="M:Quantum.TypeUtils.FindType(System.String)">
            <summary>
            Find a type by a given name inside all loaded assemblies.
            </summary>
            <param name="typeName">Type name</param>
            <returns>The type or <see langword="null"/> when not found</returns>
        </member>
        <member name="M:Quantum.TypeUtils.GetLoadableTypes(System.Reflection.Assembly)">
            <summary>
            Get a list of all types inside a given assembly.
            </summary>
            <param name="assembly">Assembly to search</param>
            <returns>A list of all types from that assembly</returns>
            <exception cref="T:System.ArgumentNullException">Is raised if the assembly is <see langword="null"/></exception>
        </member>
        <member name="M:Quantum.TypeUtils.ImplementsInterface(System.Type,System.Type)">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.UnmanagedUtils.ByteToHex(System.Byte)">
            <summary>
            Converts a byte value to its hexadecimal representation.
            </summary>
            <param name="value">The byte value to convert.</param>
            <returns>The hexadecimal representation of the byte value.</returns>
        </member>
        <member name="M:Quantum.UnmanagedUtils.VerifySize``1(System.Int32)">
            <summary>
            Verifies the size of a type to ensure it matches the specified size.
            </summary>
            <typeparam name="T">The type to verify the size for.</typeparam>
            <param name="size">The expected size of the type in bytes.</param>
            <returns><see langword="true"/> if the size of the type matches the specified size; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.UnmanagedUtils.PrintBuffer``1(``0*,System.Int32,Quantum.FramePrinter)">
            <summary>
            Prints the buffer of type T to a printer.
            </summary>
            <typeparam name="T">The type of the buffer elements. Must be unmanaged.</typeparam>
            <param name="buffer">The buffer to print.</param>
            <param name="length">The length of the buffer.</param>
            <param name="printer">The FramePrinter instance to print the buffer.</param>
        </member>
        <member name="M:Quantum.UnmanagedUtils.PrintBytesBits(System.Byte*,System.Int32,System.Int32,Quantum.FramePrinter)">
            <summary>
            Prints the bits of a byte buffer in a specified block size using a provided frame printer.
            </summary>
            <param name="buffer">The pointer to the byte buffer.</param>
            <param name="bitsLength">The length in bits of the buffer.</param>
            <param name="blockSize">The size of each block for printing.</param>
            <param name="printer">The frame printer to use for printing.</param>
        </member>
        <member name="M:Quantum.UnmanagedUtils.PrintBytesHex(System.Byte*,System.Int32)">
            <summary>
            Converts a pointer to a buffer of bytes to its hexadecimal representation.
            </summary>
            <param name="buffer">A pointer to the buffer of bytes.</param>
            <param name="length">The length of the buffer.</param>
            <returns>The hexadecimal representation of the buffer of bytes.</returns>
        </member>
        <member name="M:Quantum.UnmanagedUtils.PrintBytesHex(System.Byte*,System.Int32,System.Int32,Quantum.FramePrinter)">
            <summary>
            Prints a sequence of bytes in hexadecimal format.
            </summary>
            <param name="buffer">The pointer to the sequence of bytes.</param>
            <param name="length">The length of the sequence of bytes.</param>
            <param name="blockSize">The number of bytes per line.</param>
            <param name="printer">The frame printer object used for printing.</param>
        </member>
        <member name="M:Quantum.UnmanagedUtils.ToManagedArray``1(``0*,System.Int32)">
            <summary>
            Converts a pointer to an unmanaged array to a managed array.
            </summary>
            <typeparam name="T">The type of elements in the array.</typeparam>
            <param name="ptr">Pointer to the unmanaged array.</param>
            <param name="length">Length of the unmanaged array.</param>
            <returns>A managed array containing the elements from the unmanaged array.</returns>
        </member>
        <member name="M:Quantum.UnmanagedUtils.ToNativeBuffer``1(``0[],Photon.Deterministic.Native.Allocator)">
            <summary>
            Converts a managed array to a native buffer and returns a pointer to the buffer.
            </summary>
            <typeparam name="T">The type of the elements in the array. Must be an unmanaged type.</typeparam>
            <param name="array">The managed array to convert.</param>
            <param name="allocator">The allocator to use for allocating the native buffer.</param>
            <returns>A pointer to the native buffer.</returns>
        </member>
        <member name="T:Quantum.View">
            <summary>
            Quantum component used to reference an EntityView asset which represents the view object that is created and updated in runtime, usually used for displaying entity graphics.
            </summary>
        </member>
        <member name="F:Quantum.View.SIZE">
            <summary>
            The size of the component (or struct/type) in-memory inside the Frame data-buffers or stack (when passed as value parameter).
            Not related to the snapshot payload this occupies, which is bit-packed and compressed.
            </summary>
        </member>
        <member name="F:Quantum.View.Current">
            <summary>
            The EntityView asset that is currently referenced.
            </summary>
        </member>
        <member name="M:Quantum.View.Create(Quantum.EntityView)">
            <summary>
            Creates and initializes an instance of this component type.
            </summary>
            <param name="viewAsset">The initial view asset</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.View.Create(Quantum.Core.FrameBase,System.String,Quantum.DatabaseType)">
            <summary>
            Creates a new View instance and uses a path to find the EntityView asset that should be referenced by the component.
            </summary>
            <param name="f"></param>
            <param name="path"></param>
            <param name="dbType"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.View.Serialize(System.Void*,Quantum.FrameSerializer)">
            <summary>
            Serializes a <see cref="T:Quantum.View"/> into a <see cref="T:Quantum.FrameSerializer"/>.
            </summary>
            <param name="ptr">The pointer to the <see cref="T:Quantum.View"/>.</param>
            <param name="stream">The <see cref="T:Quantum.FrameSerializer"/> instance into which the struct will be serialized.</param>
        </member>
    </members>
</doc>
