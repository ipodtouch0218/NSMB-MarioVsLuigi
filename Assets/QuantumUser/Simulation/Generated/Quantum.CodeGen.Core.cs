// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum GameState : byte {
    PreGameRoom,
    WaitingForPlayers,
    Starting,
    Playing,
    Ended,
  }
  public enum JumpState : byte {
    None,
    SingleJump,
    DoubleJump,
    TripleJump,
  }
  public enum PowerupReserveResult : byte {
    None,
    NoneButPlaySound,
    ReserveOldPowerup,
    ReserveNewPowerup,
  }
  public enum PowerupState : byte {
    NoPowerup,
    MiniMushroom,
    Mushroom,
    FireFlower,
    IceFlower,
    PropellerMushroom,
    BlueShell,
    MegaMushroom,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    Up = 1 << 0,
    Down = 1 << 1,
    Left = 1 << 2,
    Right = 1 << 3,
    Jump = 1 << 4,
    Sprint = 1 << 5,
    PowerupAction = 1 << 6,
    FireballPowerupAction = 1 << 7,
    PropellerPowerupAction = 1 << 8,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet10 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 10;
    public Int32 Length {
      get {
        return 10;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet10*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 10, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet10 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet10 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 10);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 10);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5483;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet10*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet64 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 64;
    public Int32 Length {
      get {
        return 64;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet64*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 64, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet64 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet64 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 64);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 64);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6869;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet64*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GameRules {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public AssetRef<Map> Level;
    [FieldOffset(2)]
    public Byte StarsToWin;
    [FieldOffset(0)]
    public Byte CoinsForPowerup;
    [FieldOffset(1)]
    public Byte Lives;
    [FieldOffset(4)]
    public UInt16 TimerSeconds;
    [FieldOffset(16)]
    public QBoolean TeamsEnabled;
    [FieldOffset(8)]
    public QBoolean CustomPowerupsEnabled;
    [FieldOffset(12)]
    public QBoolean DrawOnTimeUp;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 443;
        hash = hash * 31 + Level.GetHashCode();
        hash = hash * 31 + StarsToWin.GetHashCode();
        hash = hash * 31 + CoinsForPowerup.GetHashCode();
        hash = hash * 31 + Lives.GetHashCode();
        hash = hash * 31 + TimerSeconds.GetHashCode();
        hash = hash * 31 + TeamsEnabled.GetHashCode();
        hash = hash * 31 + CustomPowerupsEnabled.GetHashCode();
        hash = hash * 31 + DrawOnTimeUp.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GameRules*)ptr;
        serializer.Stream.Serialize(&p->CoinsForPowerup);
        serializer.Stream.Serialize(&p->Lives);
        serializer.Stream.Serialize(&p->StarsToWin);
        serializer.Stream.Serialize(&p->TimerSeconds);
        QBoolean.Serialize(&p->CustomPowerupsEnabled, serializer);
        QBoolean.Serialize(&p->DrawOnTimeUp, serializer);
        QBoolean.Serialize(&p->TeamsEnabled, serializer);
        AssetRef.Serialize(&p->Level, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 108;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(96)]
    public Button Up;
    [FieldOffset(0)]
    public Button Down;
    [FieldOffset(36)]
    public Button Left;
    [FieldOffset(72)]
    public Button Right;
    [FieldOffset(24)]
    public Button Jump;
    [FieldOffset(84)]
    public Button Sprint;
    [FieldOffset(48)]
    public Button PowerupAction;
    [FieldOffset(12)]
    public Button FireballPowerupAction;
    [FieldOffset(60)]
    public Button PropellerPowerupAction;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + Up.GetHashCode();
        hash = hash * 31 + Down.GetHashCode();
        hash = hash * 31 + Left.GetHashCode();
        hash = hash * 31 + Right.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Sprint.GetHashCode();
        hash = hash * 31 + PowerupAction.GetHashCode();
        hash = hash * 31 + FireballPowerupAction.GetHashCode();
        hash = hash * 31 + PropellerPowerupAction.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 10;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.Up: return Up.IsDown;
        case InputButtons.Down: return Down.IsDown;
        case InputButtons.Left: return Left.IsDown;
        case InputButtons.Right: return Right.IsDown;
        case InputButtons.Jump: return Jump.IsDown;
        case InputButtons.Sprint: return Sprint.IsDown;
        case InputButtons.PowerupAction: return PowerupAction.IsDown;
        case InputButtons.FireballPowerupAction: return FireballPowerupAction.IsDown;
        case InputButtons.PropellerPowerupAction: return PropellerPowerupAction.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.Up: return Up.WasPressed;
        case InputButtons.Down: return Down.WasPressed;
        case InputButtons.Left: return Left.WasPressed;
        case InputButtons.Right: return Right.WasPressed;
        case InputButtons.Jump: return Jump.WasPressed;
        case InputButtons.Sprint: return Sprint.WasPressed;
        case InputButtons.PowerupAction: return PowerupAction.WasPressed;
        case InputButtons.FireballPowerupAction: return FireballPowerupAction.WasPressed;
        case InputButtons.PropellerPowerupAction: return PropellerPowerupAction.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        Button.Serialize(&p->Down, serializer);
        Button.Serialize(&p->FireballPowerupAction, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->Left, serializer);
        Button.Serialize(&p->PowerupAction, serializer);
        Button.Serialize(&p->PropellerPowerupAction, serializer);
        Button.Serialize(&p->Right, serializer);
        Button.Serialize(&p->Sprint, serializer);
        Button.Serialize(&p->Up, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PhysicsContact {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(48)]
    public FPVector2 Position;
    [FieldOffset(32)]
    public FPVector2 Normal;
    [FieldOffset(24)]
    public FP Distance;
    [FieldOffset(0)]
    public Int32 Frame;
    [FieldOffset(4)]
    public Int32 TileX;
    [FieldOffset(8)]
    public Int32 TileY;
    [FieldOffset(16)]
    public EntityRef Entity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3581;
        hash = hash * 31 + Position.GetHashCode();
        hash = hash * 31 + Normal.GetHashCode();
        hash = hash * 31 + Distance.GetHashCode();
        hash = hash * 31 + Frame.GetHashCode();
        hash = hash * 31 + TileX.GetHashCode();
        hash = hash * 31 + TileY.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PhysicsContact*)ptr;
        serializer.Stream.Serialize(&p->Frame);
        serializer.Stream.Serialize(&p->TileX);
        serializer.Stream.Serialize(&p->TileY);
        EntityRef.Serialize(&p->Entity, serializer);
        FP.Serialize(&p->Distance, serializer);
        FPVector2.Serialize(&p->Normal, serializer);
        FPVector2.Serialize(&p->Position, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct StageTileInstance {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<StageTile> Tile;
    [FieldOffset(8)]
    public FP Rotation;
    [FieldOffset(16)]
    public FPVector2 Scale;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 18131;
        hash = hash * 31 + Tile.GetHashCode();
        hash = hash * 31 + Rotation.GetHashCode();
        hash = hash * 31 + Scale.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (StageTileInstance*)ptr;
        AssetRef.Serialize(&p->Tile, serializer);
        FP.Serialize(&p->Rotation, serializer);
        FPVector2.Serialize(&p->Scale, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1728;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(32)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(48)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(120)]
    public BitSet1024 Systems;
    [FieldOffset(248)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(544)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(548)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 10)]
    private fixed Byte _input_[1080];
    [FieldOffset(1632)]
    public BitSet10 PlayerLastConnectionState;
    [FieldOffset(1644)]
    public UInt16 BigStarSpawnTimer;
    [FieldOffset(1680)]
    public EntityRef MainBigStar;
    [FieldOffset(1672)]
    public BitSet64 UsedStarSpawns;
    [FieldOffset(1660)]
    public Int32 UsedStarSpawnCount;
    [FieldOffset(1696)]
    public GameRules Rules;
    [FieldOffset(1642)]
    public GameState GameState;
    [FieldOffset(1652)]
    public Int32 StartFrame;
    [FieldOffset(1656)]
    public Int32 TotalGamesPlayed;
    [FieldOffset(1646)]
    public UInt16 GameStartFrames;
    [FieldOffset(1648)]
    public UInt16 PlayerLoadFrames;
    [FieldOffset(1664)]
    [AllocateOnComponentAdded()]
    public QDictionaryPtr<PlayerRef, EntityRef> PlayerDatas;
    [FieldOffset(1640)]
    public Byte RealPlayers;
    [FieldOffset(1641)]
    public Byte TotalMarios;
    [FieldOffset(1688)]
    public FP Timer;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 108, 10); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + BigStarSpawnTimer.GetHashCode();
        hash = hash * 31 + MainBigStar.GetHashCode();
        hash = hash * 31 + UsedStarSpawns.GetHashCode();
        hash = hash * 31 + UsedStarSpawnCount.GetHashCode();
        hash = hash * 31 + Rules.GetHashCode();
        hash = hash * 31 + (Byte)GameState;
        hash = hash * 31 + StartFrame.GetHashCode();
        hash = hash * 31 + TotalGamesPlayed.GetHashCode();
        hash = hash * 31 + GameStartFrames.GetHashCode();
        hash = hash * 31 + PlayerLoadFrames.GetHashCode();
        hash = hash * 31 + PlayerDatas.GetHashCode();
        hash = hash * 31 + RealPlayers.GetHashCode();
        hash = hash * 31 + TotalMarios.GetHashCode();
        hash = hash * 31 + Timer.GetHashCode();
        return hash;
      }
    }
    partial void ClearPointersPartial(FrameBase f, EntityRef entity) {
      PlayerDatas = default;
    }
    partial void AllocatePointersPartial(FrameBase f, EntityRef entity) {
      f.TryAllocateDictionary(ref PlayerDatas);
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet10.Serialize(&p->PlayerLastConnectionState, serializer);
        serializer.Stream.Serialize(&p->RealPlayers);
        serializer.Stream.Serialize(&p->TotalMarios);
        serializer.Stream.Serialize((Byte*)&p->GameState);
        serializer.Stream.Serialize(&p->BigStarSpawnTimer);
        serializer.Stream.Serialize(&p->GameStartFrames);
        serializer.Stream.Serialize(&p->PlayerLoadFrames);
        serializer.Stream.Serialize(&p->StartFrame);
        serializer.Stream.Serialize(&p->TotalGamesPlayed);
        serializer.Stream.Serialize(&p->UsedStarSpawnCount);
        QDictionary.Serialize(&p->PlayerDatas, serializer, Statics.SerializePlayerRef, Statics.SerializeEntityRef);
        Quantum.BitSet64.Serialize(&p->UsedStarSpawns, serializer);
        EntityRef.Serialize(&p->MainBigStar, serializer);
        FP.Serialize(&p->Timer, serializer);
        Quantum.GameRules.Serialize(&p->Rules, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BigStar : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public QBoolean IsStationary;
    [FieldOffset(2)]
    public UInt16 Lifetime;
    [FieldOffset(0)]
    public Byte PassthroughFrames;
    [FieldOffset(1)]
    public Byte UncollectableFrames;
    [FieldOffset(24)]
    public FP Speed;
    [FieldOffset(16)]
    public FP BounceForce;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean FacingRight;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20641;
        hash = hash * 31 + IsStationary.GetHashCode();
        hash = hash * 31 + Lifetime.GetHashCode();
        hash = hash * 31 + PassthroughFrames.GetHashCode();
        hash = hash * 31 + UncollectableFrames.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + BounceForce.GetHashCode();
        hash = hash * 31 + FacingRight.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BigStar*)ptr;
        serializer.Stream.Serialize(&p->PassthroughFrames);
        serializer.Stream.Serialize(&p->UncollectableFrames);
        serializer.Stream.Serialize(&p->Lifetime);
        QBoolean.Serialize(&p->FacingRight, serializer);
        QBoolean.Serialize(&p->IsStationary, serializer);
        FP.Serialize(&p->BounceForce, serializer);
        FP.Serialize(&p->Speed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BlockBump : Quantum.IComponent {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Byte Lifetime;
    [FieldOffset(32)]
    public AssetRef<StageTile> StartTile;
    [FieldOffset(64)]
    public StageTileInstance ResultTile;
    [FieldOffset(24)]
    public AssetRef<EntityPrototype> Powerup;
    [FieldOffset(20)]
    [ExcludeFromPrototype()]
    public QBoolean IsDownwards;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FPVector2 Origin;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public Int32 TileX;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public Int32 TileY;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public EntityRef Owner;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QBoolean AllowSelfDamage;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean HasBumped;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21089;
        hash = hash * 31 + Lifetime.GetHashCode();
        hash = hash * 31 + StartTile.GetHashCode();
        hash = hash * 31 + ResultTile.GetHashCode();
        hash = hash * 31 + Powerup.GetHashCode();
        hash = hash * 31 + IsDownwards.GetHashCode();
        hash = hash * 31 + Origin.GetHashCode();
        hash = hash * 31 + TileX.GetHashCode();
        hash = hash * 31 + TileY.GetHashCode();
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + AllowSelfDamage.GetHashCode();
        hash = hash * 31 + HasBumped.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BlockBump*)ptr;
        serializer.Stream.Serialize(&p->Lifetime);
        serializer.Stream.Serialize(&p->TileX);
        serializer.Stream.Serialize(&p->TileY);
        QBoolean.Serialize(&p->AllowSelfDamage, serializer);
        QBoolean.Serialize(&p->HasBumped, serializer);
        QBoolean.Serialize(&p->IsDownwards, serializer);
        AssetRef.Serialize(&p->Powerup, serializer);
        AssetRef.Serialize(&p->StartTile, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        FPVector2.Serialize(&p->Origin, serializer);
        Quantum.StageTileInstance.Serialize(&p->ResultTile, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Bobomb : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP ExplosionRadius;
    [FieldOffset(16)]
    public FP Speed;
    [FieldOffset(2)]
    public UInt16 DetonationFrames;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public UInt16 CurrentDetonationFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3929;
        hash = hash * 31 + ExplosionRadius.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + DetonationFrames.GetHashCode();
        hash = hash * 31 + CurrentDetonationFrames.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Bobomb*)ptr;
        serializer.Stream.Serialize(&p->CurrentDetonationFrames);
        serializer.Stream.Serialize(&p->DetonationFrames);
        FP.Serialize(&p->ExplosionRadius, serializer);
        FP.Serialize(&p->Speed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Boo : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP MaxRange;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public EntityRef CurrentTarget;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte UnscaredFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 383;
        hash = hash * 31 + MaxRange.GetHashCode();
        hash = hash * 31 + CurrentTarget.GetHashCode();
        hash = hash * 31 + UnscaredFrames.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Boo*)ptr;
        serializer.Stream.Serialize(&p->UnscaredFrames);
        EntityRef.Serialize(&p->CurrentTarget, serializer);
        FP.Serialize(&p->MaxRange, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BreakableObject : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(32)]
    public FP OriginalHeight;
    [FieldOffset(24)]
    public FP MinimumHeight;
    [FieldOffset(8)]
    public QBoolean IsStompable;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP CurrentHeight;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean IsBroken;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean IsDestroyed;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20347;
        hash = hash * 31 + OriginalHeight.GetHashCode();
        hash = hash * 31 + MinimumHeight.GetHashCode();
        hash = hash * 31 + IsStompable.GetHashCode();
        hash = hash * 31 + CurrentHeight.GetHashCode();
        hash = hash * 31 + IsBroken.GetHashCode();
        hash = hash * 31 + IsDestroyed.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BreakableObject*)ptr;
        QBoolean.Serialize(&p->IsBroken, serializer);
        QBoolean.Serialize(&p->IsDestroyed, serializer);
        QBoolean.Serialize(&p->IsStompable, serializer);
        FP.Serialize(&p->CurrentHeight, serializer);
        FP.Serialize(&p->MinimumHeight, serializer);
        FP.Serialize(&p->OriginalHeight, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BulletBill : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FP Speed;
    [FieldOffset(16)]
    public FP DespawnRadius;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte DespawnFrames;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public EntityRef Owner;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6047;
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + DespawnRadius.GetHashCode();
        hash = hash * 31 + DespawnFrames.GetHashCode();
        hash = hash * 31 + Owner.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BulletBill*)ptr;
        serializer.Stream.Serialize(&p->DespawnFrames);
        EntityRef.Serialize(&p->Owner, serializer);
        FP.Serialize(&p->DespawnRadius, serializer);
        FP.Serialize(&p->Speed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BulletBillLauncher : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<EntityPrototype> BulletBillPrototype;
    [FieldOffset(2)]
    public UInt16 TimeToShoot;
    [FieldOffset(24)]
    public FP MinimumShootRadius;
    [FieldOffset(16)]
    public FP MaximumShootRadius;
    [FieldOffset(0)]
    public Byte BulletBillCount;
    [FieldOffset(4)]
    public UInt16 TimeToShootFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14549;
        hash = hash * 31 + BulletBillPrototype.GetHashCode();
        hash = hash * 31 + TimeToShoot.GetHashCode();
        hash = hash * 31 + MinimumShootRadius.GetHashCode();
        hash = hash * 31 + MaximumShootRadius.GetHashCode();
        hash = hash * 31 + BulletBillCount.GetHashCode();
        hash = hash * 31 + TimeToShootFrames.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BulletBillLauncher*)ptr;
        serializer.Stream.Serialize(&p->BulletBillCount);
        serializer.Stream.Serialize(&p->TimeToShoot);
        serializer.Stream.Serialize(&p->TimeToShootFrames);
        AssetRef.Serialize(&p->BulletBillPrototype, serializer);
        FP.Serialize(&p->MaximumShootRadius, serializer);
        FP.Serialize(&p->MinimumShootRadius, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CameraController : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FPVector2 CurrentPosition;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public FP LastFloorHeight;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FPVector2 LastPlayerPosition;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FPVector2 SmoothDampVelocity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14401;
        hash = hash * 31 + CurrentPosition.GetHashCode();
        hash = hash * 31 + LastFloorHeight.GetHashCode();
        hash = hash * 31 + LastPlayerPosition.GetHashCode();
        hash = hash * 31 + SmoothDampVelocity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CameraController*)ptr;
        FP.Serialize(&p->LastFloorHeight, serializer);
        FPVector2.Serialize(&p->CurrentPosition, serializer);
        FPVector2.Serialize(&p->LastPlayerPosition, serializer);
        FPVector2.Serialize(&p->SmoothDampVelocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Coin : Quantum.IComponent {
    public const Int32 SIZE = 20;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(16)]
    public QBoolean IsFloating;
    [FieldOffset(12)]
    public QBoolean IsDotted;
    [FieldOffset(2)]
    public UInt16 Lifetime;
    [FieldOffset(1)]
    public Byte UncollectableFrames;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean IsCollected;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean IsCurrentlyDotted;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte DottedChangeFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3767;
        hash = hash * 31 + IsFloating.GetHashCode();
        hash = hash * 31 + IsDotted.GetHashCode();
        hash = hash * 31 + Lifetime.GetHashCode();
        hash = hash * 31 + UncollectableFrames.GetHashCode();
        hash = hash * 31 + IsCollected.GetHashCode();
        hash = hash * 31 + IsCurrentlyDotted.GetHashCode();
        hash = hash * 31 + DottedChangeFrames.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Coin*)ptr;
        serializer.Stream.Serialize(&p->DottedChangeFrames);
        serializer.Stream.Serialize(&p->UncollectableFrames);
        serializer.Stream.Serialize(&p->Lifetime);
        QBoolean.Serialize(&p->IsCollected, serializer);
        QBoolean.Serialize(&p->IsCurrentlyDotted, serializer);
        QBoolean.Serialize(&p->IsDotted, serializer);
        QBoolean.Serialize(&p->IsFloating, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Cullable : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector2 Offset;
    [FieldOffset(0)]
    public FP BroadRadius;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7759;
        hash = hash * 31 + Offset.GetHashCode();
        hash = hash * 31 + BroadRadius.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Cullable*)ptr;
        FP.Serialize(&p->BroadRadius, serializer);
        FPVector2.Serialize(&p->Offset, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Enemy : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FPVector2 Spawnpoint;
    [FieldOffset(8)]
    public QBoolean IgnorePlayerWhenRespawning;
    [FieldOffset(0)]
    public QBoolean DisableRespawning;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QBoolean IsActive;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean IsDead;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean FacingRight;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11071;
        hash = hash * 31 + Spawnpoint.GetHashCode();
        hash = hash * 31 + IgnorePlayerWhenRespawning.GetHashCode();
        hash = hash * 31 + DisableRespawning.GetHashCode();
        hash = hash * 31 + IsActive.GetHashCode();
        hash = hash * 31 + IsDead.GetHashCode();
        hash = hash * 31 + FacingRight.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Enemy*)ptr;
        QBoolean.Serialize(&p->DisableRespawning, serializer);
        QBoolean.Serialize(&p->FacingRight, serializer);
        QBoolean.Serialize(&p->IgnorePlayerWhenRespawning, serializer);
        QBoolean.Serialize(&p->IsActive, serializer);
        QBoolean.Serialize(&p->IsDead, serializer);
        FPVector2.Serialize(&p->Spawnpoint, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EnterablePipe : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public EntityRef OtherPipe;
    [FieldOffset(4)]
    public QBoolean IsEnterable;
    [FieldOffset(0)]
    public QBoolean IsCeilingPipe;
    [FieldOffset(8)]
    public QBoolean IsMiniOnly;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 47;
        hash = hash * 31 + OtherPipe.GetHashCode();
        hash = hash * 31 + IsEnterable.GetHashCode();
        hash = hash * 31 + IsCeilingPipe.GetHashCode();
        hash = hash * 31 + IsMiniOnly.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EnterablePipe*)ptr;
        QBoolean.Serialize(&p->IsCeilingPipe, serializer);
        QBoolean.Serialize(&p->IsEnterable, serializer);
        QBoolean.Serialize(&p->IsMiniOnly, serializer);
        EntityRef.Serialize(&p->OtherPipe, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Freezable : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FPVector2 IceBlockSize;
    [FieldOffset(0)]
    public Byte AutoBreakFrames;
    [FieldOffset(1)]
    public Byte AutoBreakGrabAdditionalFrames;
    [FieldOffset(4)]
    public QBoolean AutoBreakWhileHeld;
    [FieldOffset(40)]
    public FPVector2 Offset;
    [FieldOffset(8)]
    public QBoolean IsCarryable;
    [FieldOffset(12)]
    public QBoolean IsFlying;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public EntityRef FrozenCubeEntity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15227;
        hash = hash * 31 + IceBlockSize.GetHashCode();
        hash = hash * 31 + AutoBreakFrames.GetHashCode();
        hash = hash * 31 + AutoBreakGrabAdditionalFrames.GetHashCode();
        hash = hash * 31 + AutoBreakWhileHeld.GetHashCode();
        hash = hash * 31 + Offset.GetHashCode();
        hash = hash * 31 + IsCarryable.GetHashCode();
        hash = hash * 31 + IsFlying.GetHashCode();
        hash = hash * 31 + FrozenCubeEntity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Freezable*)ptr;
        serializer.Stream.Serialize(&p->AutoBreakFrames);
        serializer.Stream.Serialize(&p->AutoBreakGrabAdditionalFrames);
        QBoolean.Serialize(&p->AutoBreakWhileHeld, serializer);
        QBoolean.Serialize(&p->IsCarryable, serializer);
        QBoolean.Serialize(&p->IsFlying, serializer);
        EntityRef.Serialize(&p->FrozenCubeEntity, serializer);
        FPVector2.Serialize(&p->IceBlockSize, serializer);
        FPVector2.Serialize(&p->Offset, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GenericMover : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<GenericMoverAsset> MoverAsset;
    [FieldOffset(8)]
    public FP StartOffset;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1901;
        hash = hash * 31 + MoverAsset.GetHashCode();
        hash = hash * 31 + StartOffset.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GenericMover*)ptr;
        AssetRef.Serialize(&p->MoverAsset, serializer);
        FP.Serialize(&p->StartOffset, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Goomba : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP Speed;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte DeathAnimationFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20731;
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + DeathAnimationFrames.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Goomba*)ptr;
        serializer.Stream.Serialize(&p->DeathAnimationFrames);
        FP.Serialize(&p->Speed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Holdable : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean HoldAboveHead;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public EntityRef Holder;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public EntityRef PreviousHolder;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte IgnoreOwnerFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6131;
        hash = hash * 31 + HoldAboveHead.GetHashCode();
        hash = hash * 31 + Holder.GetHashCode();
        hash = hash * 31 + PreviousHolder.GetHashCode();
        hash = hash * 31 + IgnoreOwnerFrames.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Holdable*)ptr;
        serializer.Stream.Serialize(&p->IgnoreOwnerFrames);
        QBoolean.Serialize(&p->HoldAboveHead, serializer);
        EntityRef.Serialize(&p->Holder, serializer);
        EntityRef.Serialize(&p->PreviousHolder, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct IceBlock : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(32)]
    public FP SlidingSpeed;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef Entity;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FPVector2 Size;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FPVector2 ChildOffset;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QBoolean IsFlying;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean IsSliding;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean FacingRight;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte AutoBreakFrames;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public LiquidType InLiquidType;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15017;
        hash = hash * 31 + SlidingSpeed.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + ChildOffset.GetHashCode();
        hash = hash * 31 + IsFlying.GetHashCode();
        hash = hash * 31 + IsSliding.GetHashCode();
        hash = hash * 31 + FacingRight.GetHashCode();
        hash = hash * 31 + AutoBreakFrames.GetHashCode();
        hash = hash * 31 + (byte)InLiquidType;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (IceBlock*)ptr;
        serializer.Stream.Serialize(&p->AutoBreakFrames);
        serializer.Stream.Serialize((byte*)&p->InLiquidType);
        QBoolean.Serialize(&p->FacingRight, serializer);
        QBoolean.Serialize(&p->IsFlying, serializer);
        QBoolean.Serialize(&p->IsSliding, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
        FP.Serialize(&p->SlidingSpeed, serializer);
        FPVector2.Serialize(&p->ChildOffset, serializer);
        FPVector2.Serialize(&p->Size, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Interactable : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public QBoolean ColliderDisabled;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public PhysicsQueryRef OverlapQueryRef;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public PhysicsQueryRef OverlapLevelSeamQueryRef;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2039;
        hash = hash * 31 + ColliderDisabled.GetHashCode();
        hash = hash * 31 + OverlapQueryRef.GetHashCode();
        hash = hash * 31 + OverlapLevelSeamQueryRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Interactable*)ptr;
        QBoolean.Serialize(&p->ColliderDisabled, serializer);
        PhysicsQueryRef.Serialize(&p->OverlapLevelSeamQueryRef, serializer);
        PhysicsQueryRef.Serialize(&p->OverlapQueryRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InvisibleBlock : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<StageTile> BumpTile;
    [FieldOffset(8)]
    public AssetRef<StageTile> Tile;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17449;
        hash = hash * 31 + BumpTile.GetHashCode();
        hash = hash * 31 + Tile.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InvisibleBlock*)ptr;
        AssetRef.Serialize(&p->BumpTile, serializer);
        AssetRef.Serialize(&p->Tile, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Koopa : Quantum.IComponent {
    public const Int32 SIZE = 88;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public AssetRef<PowerupAsset> SpawnPowerupWhenStomped;
    [FieldOffset(4)]
    public QBoolean DontWalkOfLedges;
    [FieldOffset(20)]
    public QBoolean IsSpiny;
    [FieldOffset(48)]
    public FP Speed;
    [FieldOffset(40)]
    public FP KickSpeed;
    [FieldOffset(56)]
    public FPVector2 IceBlockInShellSize;
    [FieldOffset(72)]
    public FPVector2 IceBlockOutShellSize;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte Combo;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FP CurrentSpeed;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QBoolean IsInShell;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean IsFlipped;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean IsKicked;
    [FieldOffset(2)]
    [ExcludeFromPrototype()]
    public UInt16 WakeupFrames;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public Byte TurnaroundWaitFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16001;
        hash = hash * 31 + SpawnPowerupWhenStomped.GetHashCode();
        hash = hash * 31 + DontWalkOfLedges.GetHashCode();
        hash = hash * 31 + IsSpiny.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + KickSpeed.GetHashCode();
        hash = hash * 31 + IceBlockInShellSize.GetHashCode();
        hash = hash * 31 + IceBlockOutShellSize.GetHashCode();
        hash = hash * 31 + Combo.GetHashCode();
        hash = hash * 31 + CurrentSpeed.GetHashCode();
        hash = hash * 31 + IsInShell.GetHashCode();
        hash = hash * 31 + IsFlipped.GetHashCode();
        hash = hash * 31 + IsKicked.GetHashCode();
        hash = hash * 31 + WakeupFrames.GetHashCode();
        hash = hash * 31 + TurnaroundWaitFrames.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Koopa*)ptr;
        serializer.Stream.Serialize(&p->Combo);
        serializer.Stream.Serialize(&p->TurnaroundWaitFrames);
        serializer.Stream.Serialize(&p->WakeupFrames);
        QBoolean.Serialize(&p->DontWalkOfLedges, serializer);
        QBoolean.Serialize(&p->IsFlipped, serializer);
        QBoolean.Serialize(&p->IsInShell, serializer);
        QBoolean.Serialize(&p->IsKicked, serializer);
        QBoolean.Serialize(&p->IsSpiny, serializer);
        AssetRef.Serialize(&p->SpawnPowerupWhenStomped, serializer);
        FP.Serialize(&p->CurrentSpeed, serializer);
        FP.Serialize(&p->KickSpeed, serializer);
        FP.Serialize(&p->Speed, serializer);
        FPVector2.Serialize(&p->IceBlockInShellSize, serializer);
        FPVector2.Serialize(&p->IceBlockOutShellSize, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Liquid : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public LiquidType LiquidType;
    [FieldOffset(4)]
    public Int32 WidthTiles;
    [FieldOffset(16)]
    public FP HeightTiles;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QHashSetPtr<EntityRef> SplashedEntities;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QHashSetPtr<EntityRef> UnderwaterEntities;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4787;
        hash = hash * 31 + (byte)LiquidType;
        hash = hash * 31 + WidthTiles.GetHashCode();
        hash = hash * 31 + HeightTiles.GetHashCode();
        hash = hash * 31 + SplashedEntities.GetHashCode();
        hash = hash * 31 + UnderwaterEntities.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (SplashedEntities != default) f.FreeHashSet(ref SplashedEntities);
      if (UnderwaterEntities != default) f.FreeHashSet(ref UnderwaterEntities);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Liquid*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateHashSet(ref SplashedEntities);
      f.TryAllocateHashSet(ref UnderwaterEntities);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Liquid*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Liquid*)ptr;
        serializer.Stream.Serialize((byte*)&p->LiquidType);
        serializer.Stream.Serialize(&p->WidthTiles);
        QHashSet.Serialize(&p->SplashedEntities, serializer, Statics.SerializeEntityRef);
        QHashSet.Serialize(&p->UnderwaterEntities, serializer, Statics.SerializeEntityRef);
        FP.Serialize(&p->HeightTiles, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MarioBrosPlatform : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9103;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MarioBrosPlatform*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MarioPlayer : Quantum.IComponent {
    public const Int32 SIZE = 240;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(184)]
    public AssetRef<MarioPlayerPhysicsInfo> PhysicsAsset;
    [FieldOffset(176)]
    public AssetRef<CharacterAsset> CharacterAsset;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public PlayerRef PlayerRef;
    [FieldOffset(30)]
    [ExcludeFromPrototype()]
    public Byte SpawnpointIndex;
    [FieldOffset(34)]
    [ExcludeFromPrototype()]
    public Byte Team;
    [FieldOffset(39)]
    [ExcludeFromPrototype()]
    public PowerupState CurrentPowerupState;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public PowerupState PreviousPowerupState;
    [FieldOffset(192)]
    [ExcludeFromPrototype()]
    public AssetRef<PowerupAsset> ReserveItem;
    [FieldOffset(31)]
    [ExcludeFromPrototype()]
    public Byte Stars;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte Coins;
    [FieldOffset(14)]
    [ExcludeFromPrototype()]
    public Byte Lives;
    [FieldOffset(68)]
    [ExcludeFromPrototype()]
    public QBoolean Disconnected;
    [FieldOffset(88)]
    [ExcludeFromPrototype()]
    public QBoolean IsDead;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public QBoolean FireDeath;
    [FieldOffset(120)]
    [ExcludeFromPrototype()]
    public QBoolean IsRespawning;
    [FieldOffset(6)]
    [ExcludeFromPrototype()]
    public Byte DeathAnimationFrames;
    [FieldOffset(20)]
    [ExcludeFromPrototype()]
    public Byte PreRespawnFrames;
    [FieldOffset(27)]
    [ExcludeFromPrototype()]
    public Byte RespawnFrames;
    [FieldOffset(17)]
    [ExcludeFromPrototype()]
    public Byte NoLivesStarDirection;
    [FieldOffset(76)]
    [ExcludeFromPrototype()]
    public QBoolean FacingRight;
    [FieldOffset(124)]
    [ExcludeFromPrototype()]
    public QBoolean IsSkidding;
    [FieldOffset(140)]
    [ExcludeFromPrototype()]
    public QBoolean IsTurnaround;
    [FieldOffset(7)]
    [ExcludeFromPrototype()]
    public Byte FastTurnaroundFrames;
    [FieldOffset(29)]
    [ExcludeFromPrototype()]
    public Byte SlowTurnaroundFrames;
    [FieldOffset(60)]
    [ExcludeFromPrototype()]
    public Int32 LastPushingFrame;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public Byte StationaryFrames;
    [FieldOffset(37)]
    [ExcludeFromPrototype()]
    public JumpState JumpState;
    [FieldOffset(38)]
    [ExcludeFromPrototype()]
    public JumpState PreviousJumpState;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public Byte JumpLandingFrames;
    [FieldOffset(11)]
    [ExcludeFromPrototype()]
    public Byte JumpBufferFrames;
    [FieldOffset(2)]
    [ExcludeFromPrototype()]
    public Byte CoyoteTimeFrames;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public Int32 LandedFrame;
    [FieldOffset(168)]
    [ExcludeFromPrototype()]
    public QBoolean WasTouchingGroundLastFrame;
    [FieldOffset(72)]
    [ExcludeFromPrototype()]
    public QBoolean DoEntityBounce;
    [FieldOffset(160)]
    [ExcludeFromPrototype()]
    public QBoolean WallslideLeft;
    [FieldOffset(164)]
    [ExcludeFromPrototype()]
    public QBoolean WallslideRight;
    [FieldOffset(36)]
    [ExcludeFromPrototype()]
    public Byte WallslideEndFrames;
    [FieldOffset(35)]
    [ExcludeFromPrototype()]
    public Byte WalljumpFrames;
    [FieldOffset(100)]
    [ExcludeFromPrototype()]
    public QBoolean IsGroundpounding;
    [FieldOffset(96)]
    [ExcludeFromPrototype()]
    public QBoolean IsGroundpoundActive;
    [FieldOffset(10)]
    [ExcludeFromPrototype()]
    public Byte GroundpoundStartFrames;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public Byte GroundpoundCooldownFrames;
    [FieldOffset(9)]
    [ExcludeFromPrototype()]
    public Byte GroundpoundStandFrames;
    [FieldOffset(33)]
    [ExcludeFromPrototype()]
    public Byte SwimForceJumpTimer;
    [FieldOffset(104)]
    [ExcludeFromPrototype()]
    public QBoolean IsInKnockback;
    [FieldOffset(112)]
    [ExcludeFromPrototype()]
    public QBoolean IsInWeakKnockback;
    [FieldOffset(144)]
    [ExcludeFromPrototype()]
    public QBoolean KnockbackWasOriginallyFacingRight;
    [FieldOffset(52)]
    [ExcludeFromPrototype()]
    public Int32 KnockbackTick;
    [FieldOffset(5)]
    [ExcludeFromPrototype()]
    public Byte DamageInvincibilityFrames;
    [FieldOffset(13)]
    [ExcludeFromPrototype()]
    public Byte KnockbackGetupFrames;
    [FieldOffset(84)]
    [ExcludeFromPrototype()]
    public QBoolean IsCrouching;
    [FieldOffset(128)]
    [ExcludeFromPrototype()]
    public QBoolean IsSliding;
    [FieldOffset(132)]
    [ExcludeFromPrototype()]
    public QBoolean IsSpinnerFlying;
    [FieldOffset(92)]
    [ExcludeFromPrototype()]
    public QBoolean IsDrilling;
    [FieldOffset(136)]
    [ExcludeFromPrototype()]
    public QBoolean IsStuckInBlock;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public Byte Combo;
    [FieldOffset(42)]
    [ExcludeFromPrototype()]
    public UInt16 InvincibilityFrames;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public Byte MegaMushroomStartFrames;
    [FieldOffset(44)]
    [ExcludeFromPrototype()]
    public UInt16 MegaMushroomFrames;
    [FieldOffset(15)]
    [ExcludeFromPrototype()]
    public Byte MegaMushroomEndFrames;
    [FieldOffset(148)]
    [ExcludeFromPrototype()]
    public QBoolean MegaMushroomStationaryEnd;
    [FieldOffset(21)]
    [ExcludeFromPrototype()]
    public Byte ProjectileDelayFrames;
    [FieldOffset(22)]
    [ExcludeFromPrototype()]
    public Byte ProjectileVolleyFrames;
    [FieldOffset(3)]
    [ExcludeFromPrototype()]
    public Byte CurrentProjectiles;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public Byte CurrentVolley;
    [FieldOffset(108)]
    [ExcludeFromPrototype()]
    public QBoolean IsInShell;
    [FieldOffset(28)]
    [ExcludeFromPrototype()]
    public Byte ShellSlowdownFrames;
    [FieldOffset(116)]
    [ExcludeFromPrototype()]
    public QBoolean IsPropellerFlying;
    [FieldOffset(25)]
    [ExcludeFromPrototype()]
    public Byte PropellerLaunchFrames;
    [FieldOffset(26)]
    [ExcludeFromPrototype()]
    public Byte PropellerSpinFrames;
    [FieldOffset(156)]
    [ExcludeFromPrototype()]
    public QBoolean UsedPropellerThisJump;
    [FieldOffset(23)]
    [ExcludeFromPrototype()]
    public Byte PropellerDrillCooldown;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public Byte PropellerDrillHoldFrames;
    [FieldOffset(216)]
    [ExcludeFromPrototype()]
    public EntityRef HeldEntity;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public Int32 HoldStartFrame;
    [FieldOffset(200)]
    [ExcludeFromPrototype()]
    public EntityRef CurrentPipe;
    [FieldOffset(224)]
    [ExcludeFromPrototype()]
    public FPVector2 PipeDirection;
    [FieldOffset(152)]
    [ExcludeFromPrototype()]
    public QBoolean PipeEntering;
    [FieldOffset(19)]
    [ExcludeFromPrototype()]
    public Byte PipeFrames;
    [FieldOffset(18)]
    [ExcludeFromPrototype()]
    public Byte PipeCooldownFrames;
    [FieldOffset(208)]
    [ExcludeFromPrototype()]
    public EntityRef CurrentSpinner;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5503;
        hash = hash * 31 + PhysicsAsset.GetHashCode();
        hash = hash * 31 + CharacterAsset.GetHashCode();
        hash = hash * 31 + PlayerRef.GetHashCode();
        hash = hash * 31 + SpawnpointIndex.GetHashCode();
        hash = hash * 31 + Team.GetHashCode();
        hash = hash * 31 + (Byte)CurrentPowerupState;
        hash = hash * 31 + (Byte)PreviousPowerupState;
        hash = hash * 31 + ReserveItem.GetHashCode();
        hash = hash * 31 + Stars.GetHashCode();
        hash = hash * 31 + Coins.GetHashCode();
        hash = hash * 31 + Lives.GetHashCode();
        hash = hash * 31 + Disconnected.GetHashCode();
        hash = hash * 31 + IsDead.GetHashCode();
        hash = hash * 31 + FireDeath.GetHashCode();
        hash = hash * 31 + IsRespawning.GetHashCode();
        hash = hash * 31 + DeathAnimationFrames.GetHashCode();
        hash = hash * 31 + PreRespawnFrames.GetHashCode();
        hash = hash * 31 + RespawnFrames.GetHashCode();
        hash = hash * 31 + NoLivesStarDirection.GetHashCode();
        hash = hash * 31 + FacingRight.GetHashCode();
        hash = hash * 31 + IsSkidding.GetHashCode();
        hash = hash * 31 + IsTurnaround.GetHashCode();
        hash = hash * 31 + FastTurnaroundFrames.GetHashCode();
        hash = hash * 31 + SlowTurnaroundFrames.GetHashCode();
        hash = hash * 31 + LastPushingFrame.GetHashCode();
        hash = hash * 31 + StationaryFrames.GetHashCode();
        hash = hash * 31 + (Byte)JumpState;
        hash = hash * 31 + (Byte)PreviousJumpState;
        hash = hash * 31 + JumpLandingFrames.GetHashCode();
        hash = hash * 31 + JumpBufferFrames.GetHashCode();
        hash = hash * 31 + CoyoteTimeFrames.GetHashCode();
        hash = hash * 31 + LandedFrame.GetHashCode();
        hash = hash * 31 + WasTouchingGroundLastFrame.GetHashCode();
        hash = hash * 31 + DoEntityBounce.GetHashCode();
        hash = hash * 31 + WallslideLeft.GetHashCode();
        hash = hash * 31 + WallslideRight.GetHashCode();
        hash = hash * 31 + WallslideEndFrames.GetHashCode();
        hash = hash * 31 + WalljumpFrames.GetHashCode();
        hash = hash * 31 + IsGroundpounding.GetHashCode();
        hash = hash * 31 + IsGroundpoundActive.GetHashCode();
        hash = hash * 31 + GroundpoundStartFrames.GetHashCode();
        hash = hash * 31 + GroundpoundCooldownFrames.GetHashCode();
        hash = hash * 31 + GroundpoundStandFrames.GetHashCode();
        hash = hash * 31 + SwimForceJumpTimer.GetHashCode();
        hash = hash * 31 + IsInKnockback.GetHashCode();
        hash = hash * 31 + IsInWeakKnockback.GetHashCode();
        hash = hash * 31 + KnockbackWasOriginallyFacingRight.GetHashCode();
        hash = hash * 31 + KnockbackTick.GetHashCode();
        hash = hash * 31 + DamageInvincibilityFrames.GetHashCode();
        hash = hash * 31 + KnockbackGetupFrames.GetHashCode();
        hash = hash * 31 + IsCrouching.GetHashCode();
        hash = hash * 31 + IsSliding.GetHashCode();
        hash = hash * 31 + IsSpinnerFlying.GetHashCode();
        hash = hash * 31 + IsDrilling.GetHashCode();
        hash = hash * 31 + IsStuckInBlock.GetHashCode();
        hash = hash * 31 + Combo.GetHashCode();
        hash = hash * 31 + InvincibilityFrames.GetHashCode();
        hash = hash * 31 + MegaMushroomStartFrames.GetHashCode();
        hash = hash * 31 + MegaMushroomFrames.GetHashCode();
        hash = hash * 31 + MegaMushroomEndFrames.GetHashCode();
        hash = hash * 31 + MegaMushroomStationaryEnd.GetHashCode();
        hash = hash * 31 + ProjectileDelayFrames.GetHashCode();
        hash = hash * 31 + ProjectileVolleyFrames.GetHashCode();
        hash = hash * 31 + CurrentProjectiles.GetHashCode();
        hash = hash * 31 + CurrentVolley.GetHashCode();
        hash = hash * 31 + IsInShell.GetHashCode();
        hash = hash * 31 + ShellSlowdownFrames.GetHashCode();
        hash = hash * 31 + IsPropellerFlying.GetHashCode();
        hash = hash * 31 + PropellerLaunchFrames.GetHashCode();
        hash = hash * 31 + PropellerSpinFrames.GetHashCode();
        hash = hash * 31 + UsedPropellerThisJump.GetHashCode();
        hash = hash * 31 + PropellerDrillCooldown.GetHashCode();
        hash = hash * 31 + PropellerDrillHoldFrames.GetHashCode();
        hash = hash * 31 + HeldEntity.GetHashCode();
        hash = hash * 31 + HoldStartFrame.GetHashCode();
        hash = hash * 31 + CurrentPipe.GetHashCode();
        hash = hash * 31 + PipeDirection.GetHashCode();
        hash = hash * 31 + PipeEntering.GetHashCode();
        hash = hash * 31 + PipeFrames.GetHashCode();
        hash = hash * 31 + PipeCooldownFrames.GetHashCode();
        hash = hash * 31 + CurrentSpinner.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MarioPlayer*)ptr;
        serializer.Stream.Serialize(&p->Coins);
        serializer.Stream.Serialize(&p->Combo);
        serializer.Stream.Serialize(&p->CoyoteTimeFrames);
        serializer.Stream.Serialize(&p->CurrentProjectiles);
        serializer.Stream.Serialize(&p->CurrentVolley);
        serializer.Stream.Serialize(&p->DamageInvincibilityFrames);
        serializer.Stream.Serialize(&p->DeathAnimationFrames);
        serializer.Stream.Serialize(&p->FastTurnaroundFrames);
        serializer.Stream.Serialize(&p->GroundpoundCooldownFrames);
        serializer.Stream.Serialize(&p->GroundpoundStandFrames);
        serializer.Stream.Serialize(&p->GroundpoundStartFrames);
        serializer.Stream.Serialize(&p->JumpBufferFrames);
        serializer.Stream.Serialize(&p->JumpLandingFrames);
        serializer.Stream.Serialize(&p->KnockbackGetupFrames);
        serializer.Stream.Serialize(&p->Lives);
        serializer.Stream.Serialize(&p->MegaMushroomEndFrames);
        serializer.Stream.Serialize(&p->MegaMushroomStartFrames);
        serializer.Stream.Serialize(&p->NoLivesStarDirection);
        serializer.Stream.Serialize(&p->PipeCooldownFrames);
        serializer.Stream.Serialize(&p->PipeFrames);
        serializer.Stream.Serialize(&p->PreRespawnFrames);
        serializer.Stream.Serialize(&p->ProjectileDelayFrames);
        serializer.Stream.Serialize(&p->ProjectileVolleyFrames);
        serializer.Stream.Serialize(&p->PropellerDrillCooldown);
        serializer.Stream.Serialize(&p->PropellerDrillHoldFrames);
        serializer.Stream.Serialize(&p->PropellerLaunchFrames);
        serializer.Stream.Serialize(&p->PropellerSpinFrames);
        serializer.Stream.Serialize(&p->RespawnFrames);
        serializer.Stream.Serialize(&p->ShellSlowdownFrames);
        serializer.Stream.Serialize(&p->SlowTurnaroundFrames);
        serializer.Stream.Serialize(&p->SpawnpointIndex);
        serializer.Stream.Serialize(&p->Stars);
        serializer.Stream.Serialize(&p->StationaryFrames);
        serializer.Stream.Serialize(&p->SwimForceJumpTimer);
        serializer.Stream.Serialize(&p->Team);
        serializer.Stream.Serialize(&p->WalljumpFrames);
        serializer.Stream.Serialize(&p->WallslideEndFrames);
        serializer.Stream.Serialize((Byte*)&p->JumpState);
        serializer.Stream.Serialize((Byte*)&p->PreviousJumpState);
        serializer.Stream.Serialize((Byte*)&p->CurrentPowerupState);
        serializer.Stream.Serialize((Byte*)&p->PreviousPowerupState);
        serializer.Stream.Serialize(&p->InvincibilityFrames);
        serializer.Stream.Serialize(&p->MegaMushroomFrames);
        serializer.Stream.Serialize(&p->HoldStartFrame);
        serializer.Stream.Serialize(&p->KnockbackTick);
        serializer.Stream.Serialize(&p->LandedFrame);
        serializer.Stream.Serialize(&p->LastPushingFrame);
        PlayerRef.Serialize(&p->PlayerRef, serializer);
        QBoolean.Serialize(&p->Disconnected, serializer);
        QBoolean.Serialize(&p->DoEntityBounce, serializer);
        QBoolean.Serialize(&p->FacingRight, serializer);
        QBoolean.Serialize(&p->FireDeath, serializer);
        QBoolean.Serialize(&p->IsCrouching, serializer);
        QBoolean.Serialize(&p->IsDead, serializer);
        QBoolean.Serialize(&p->IsDrilling, serializer);
        QBoolean.Serialize(&p->IsGroundpoundActive, serializer);
        QBoolean.Serialize(&p->IsGroundpounding, serializer);
        QBoolean.Serialize(&p->IsInKnockback, serializer);
        QBoolean.Serialize(&p->IsInShell, serializer);
        QBoolean.Serialize(&p->IsInWeakKnockback, serializer);
        QBoolean.Serialize(&p->IsPropellerFlying, serializer);
        QBoolean.Serialize(&p->IsRespawning, serializer);
        QBoolean.Serialize(&p->IsSkidding, serializer);
        QBoolean.Serialize(&p->IsSliding, serializer);
        QBoolean.Serialize(&p->IsSpinnerFlying, serializer);
        QBoolean.Serialize(&p->IsStuckInBlock, serializer);
        QBoolean.Serialize(&p->IsTurnaround, serializer);
        QBoolean.Serialize(&p->KnockbackWasOriginallyFacingRight, serializer);
        QBoolean.Serialize(&p->MegaMushroomStationaryEnd, serializer);
        QBoolean.Serialize(&p->PipeEntering, serializer);
        QBoolean.Serialize(&p->UsedPropellerThisJump, serializer);
        QBoolean.Serialize(&p->WallslideLeft, serializer);
        QBoolean.Serialize(&p->WallslideRight, serializer);
        QBoolean.Serialize(&p->WasTouchingGroundLastFrame, serializer);
        AssetRef.Serialize(&p->CharacterAsset, serializer);
        AssetRef.Serialize(&p->PhysicsAsset, serializer);
        AssetRef.Serialize(&p->ReserveItem, serializer);
        EntityRef.Serialize(&p->CurrentPipe, serializer);
        EntityRef.Serialize(&p->CurrentSpinner, serializer);
        EntityRef.Serialize(&p->HeldEntity, serializer);
        FPVector2.Serialize(&p->PipeDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MovingPlatform : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector2 Velocity;
    [FieldOffset(0)]
    public QBoolean IgnoreMovement;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<PhysicsQueryRef> Queries;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19727;
        hash = hash * 31 + Velocity.GetHashCode();
        hash = hash * 31 + IgnoreMovement.GetHashCode();
        hash = hash * 31 + Queries.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (Queries != default) f.FreeList(ref Queries);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.MovingPlatform*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref Queries);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.MovingPlatform*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MovingPlatform*)ptr;
        QBoolean.Serialize(&p->IgnoreMovement, serializer);
        QList.Serialize(&p->Queries, serializer, Statics.SerializePhysicsQueryRef);
        FPVector2.Serialize(&p->Velocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PhysicsObject : Quantum.IComponent {
    public const Int32 SIZE = 144;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(80)]
    public FPVector2 Gravity;
    [FieldOffset(72)]
    public FP TerminalVelocity;
    [FieldOffset(12)]
    public QBoolean IsFrozen;
    [FieldOffset(8)]
    public QBoolean DisableCollision;
    [FieldOffset(44)]
    public QBoolean SlowInLiquids;
    [FieldOffset(40)]
    public QBoolean IsWaterSolid;
    [FieldOffset(4)]
    public QBoolean BreakMegaObjects;
    [FieldOffset(128)]
    [ExcludeFromPrototype()]
    public FPVector2 Velocity;
    [FieldOffset(96)]
    [ExcludeFromPrototype()]
    public FPVector2 ParentVelocity;
    [FieldOffset(112)]
    [ExcludeFromPrototype()]
    public FPVector2 PreviousFrameVelocity;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte HoverFrames;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public QBoolean IsTouchingLeftWall;
    [FieldOffset(36)]
    [ExcludeFromPrototype()]
    public QBoolean IsTouchingRightWall;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public QBoolean IsTouchingCeiling;
    [FieldOffset(28)]
    [ExcludeFromPrototype()]
    public QBoolean IsTouchingGround;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public QBoolean WasTouchingGround;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public FP FloorAngle;
    [FieldOffset(20)]
    [ExcludeFromPrototype()]
    public QBoolean IsOnSlipperyGround;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean IsOnSlideableGround;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<PhysicsContact> Contacts;
    [FieldOffset(52)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QHashSetPtr<EntityRef> LiquidContacts;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public Byte UnderwaterCounter;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8311;
        hash = hash * 31 + Gravity.GetHashCode();
        hash = hash * 31 + TerminalVelocity.GetHashCode();
        hash = hash * 31 + IsFrozen.GetHashCode();
        hash = hash * 31 + DisableCollision.GetHashCode();
        hash = hash * 31 + SlowInLiquids.GetHashCode();
        hash = hash * 31 + IsWaterSolid.GetHashCode();
        hash = hash * 31 + BreakMegaObjects.GetHashCode();
        hash = hash * 31 + Velocity.GetHashCode();
        hash = hash * 31 + ParentVelocity.GetHashCode();
        hash = hash * 31 + PreviousFrameVelocity.GetHashCode();
        hash = hash * 31 + HoverFrames.GetHashCode();
        hash = hash * 31 + IsTouchingLeftWall.GetHashCode();
        hash = hash * 31 + IsTouchingRightWall.GetHashCode();
        hash = hash * 31 + IsTouchingCeiling.GetHashCode();
        hash = hash * 31 + IsTouchingGround.GetHashCode();
        hash = hash * 31 + WasTouchingGround.GetHashCode();
        hash = hash * 31 + FloorAngle.GetHashCode();
        hash = hash * 31 + IsOnSlipperyGround.GetHashCode();
        hash = hash * 31 + IsOnSlideableGround.GetHashCode();
        hash = hash * 31 + Contacts.GetHashCode();
        hash = hash * 31 + LiquidContacts.GetHashCode();
        hash = hash * 31 + UnderwaterCounter.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (Contacts != default) f.FreeList(ref Contacts);
      if (LiquidContacts != default) f.FreeHashSet(ref LiquidContacts);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PhysicsObject*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref Contacts);
      f.TryAllocateHashSet(ref LiquidContacts);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PhysicsObject*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PhysicsObject*)ptr;
        serializer.Stream.Serialize(&p->HoverFrames);
        serializer.Stream.Serialize(&p->UnderwaterCounter);
        QBoolean.Serialize(&p->BreakMegaObjects, serializer);
        QBoolean.Serialize(&p->DisableCollision, serializer);
        QBoolean.Serialize(&p->IsFrozen, serializer);
        QBoolean.Serialize(&p->IsOnSlideableGround, serializer);
        QBoolean.Serialize(&p->IsOnSlipperyGround, serializer);
        QBoolean.Serialize(&p->IsTouchingCeiling, serializer);
        QBoolean.Serialize(&p->IsTouchingGround, serializer);
        QBoolean.Serialize(&p->IsTouchingLeftWall, serializer);
        QBoolean.Serialize(&p->IsTouchingRightWall, serializer);
        QBoolean.Serialize(&p->IsWaterSolid, serializer);
        QBoolean.Serialize(&p->SlowInLiquids, serializer);
        QBoolean.Serialize(&p->WasTouchingGround, serializer);
        QHashSet.Serialize(&p->LiquidContacts, serializer, Statics.SerializeEntityRef);
        QList.Serialize(&p->Contacts, serializer, Statics.SerializePhysicsContact);
        FP.Serialize(&p->FloorAngle, serializer);
        FP.Serialize(&p->TerminalVelocity, serializer);
        FPVector2.Serialize(&p->Gravity, serializer);
        FPVector2.Serialize(&p->ParentVelocity, serializer);
        FPVector2.Serialize(&p->PreviousFrameVelocity, serializer);
        FPVector2.Serialize(&p->Velocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PiranhaPlant : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef Pipe;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public Byte WaitingFrames;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte ChompFrames;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP PopupAnimationTime;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19889;
        hash = hash * 31 + Pipe.GetHashCode();
        hash = hash * 31 + WaitingFrames.GetHashCode();
        hash = hash * 31 + ChompFrames.GetHashCode();
        hash = hash * 31 + PopupAnimationTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PiranhaPlant*)ptr;
        serializer.Stream.Serialize(&p->ChompFrames);
        serializer.Stream.Serialize(&p->WaitingFrames);
        EntityRef.Serialize(&p->Pipe, serializer);
        FP.Serialize(&p->PopupAnimationTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerData : Quantum.IComponent {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(20)]
    public PlayerRef PlayerRef;
    [FieldOffset(36)]
    public QBoolean IsRoomHost;
    [FieldOffset(28)]
    public QBoolean IsLoaded;
    [FieldOffset(0)]
    public Byte Character;
    [FieldOffset(1)]
    public Byte Palette;
    [FieldOffset(2)]
    public Byte Team;
    [FieldOffset(40)]
    public QBoolean IsSpectator;
    [FieldOffset(44)]
    public QBoolean ManualSpectator;
    [FieldOffset(16)]
    public Int32 Wins;
    [FieldOffset(8)]
    public Int32 LastChatMessage;
    [FieldOffset(32)]
    public QBoolean IsReady;
    [FieldOffset(24)]
    public QBoolean IsInSettings;
    [FieldOffset(4)]
    public Int32 JoinTick;
    [FieldOffset(12)]
    public Int32 Ping;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10271;
        hash = hash * 31 + PlayerRef.GetHashCode();
        hash = hash * 31 + IsRoomHost.GetHashCode();
        hash = hash * 31 + IsLoaded.GetHashCode();
        hash = hash * 31 + Character.GetHashCode();
        hash = hash * 31 + Palette.GetHashCode();
        hash = hash * 31 + Team.GetHashCode();
        hash = hash * 31 + IsSpectator.GetHashCode();
        hash = hash * 31 + ManualSpectator.GetHashCode();
        hash = hash * 31 + Wins.GetHashCode();
        hash = hash * 31 + LastChatMessage.GetHashCode();
        hash = hash * 31 + IsReady.GetHashCode();
        hash = hash * 31 + IsInSettings.GetHashCode();
        hash = hash * 31 + JoinTick.GetHashCode();
        hash = hash * 31 + Ping.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerData*)ptr;
        serializer.Stream.Serialize(&p->Character);
        serializer.Stream.Serialize(&p->Palette);
        serializer.Stream.Serialize(&p->Team);
        serializer.Stream.Serialize(&p->JoinTick);
        serializer.Stream.Serialize(&p->LastChatMessage);
        serializer.Stream.Serialize(&p->Ping);
        serializer.Stream.Serialize(&p->Wins);
        PlayerRef.Serialize(&p->PlayerRef, serializer);
        QBoolean.Serialize(&p->IsInSettings, serializer);
        QBoolean.Serialize(&p->IsLoaded, serializer);
        QBoolean.Serialize(&p->IsReady, serializer);
        QBoolean.Serialize(&p->IsRoomHost, serializer);
        QBoolean.Serialize(&p->IsSpectator, serializer);
        QBoolean.Serialize(&p->ManualSpectator, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Powerup : Quantum.IComponent {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public AssetRef<PowerupAsset> Scriptable;
    [FieldOffset(12)]
    public QBoolean FacingRight;
    [FieldOffset(4)]
    public Int32 Lifetime;
    [FieldOffset(48)]
    public FPVector2 AnimationCurveOrigin;
    [FieldOffset(40)]
    public FP AnimationCurveTimer;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean BlockSpawn;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean LaunchSpawn;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public FPVector2 BlockSpawnOrigin;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public FPVector2 BlockSpawnDestination;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte BlockSpawnAnimationLength;
    [FieldOffset(2)]
    [ExcludeFromPrototype()]
    public Byte SpawnAnimationFrames;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public Byte IgnorePlayerFrames;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public EntityRef ParentMarioPlayer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17891;
        hash = hash * 31 + Scriptable.GetHashCode();
        hash = hash * 31 + FacingRight.GetHashCode();
        hash = hash * 31 + Lifetime.GetHashCode();
        hash = hash * 31 + AnimationCurveOrigin.GetHashCode();
        hash = hash * 31 + AnimationCurveTimer.GetHashCode();
        hash = hash * 31 + BlockSpawn.GetHashCode();
        hash = hash * 31 + LaunchSpawn.GetHashCode();
        hash = hash * 31 + BlockSpawnOrigin.GetHashCode();
        hash = hash * 31 + BlockSpawnDestination.GetHashCode();
        hash = hash * 31 + BlockSpawnAnimationLength.GetHashCode();
        hash = hash * 31 + SpawnAnimationFrames.GetHashCode();
        hash = hash * 31 + IgnorePlayerFrames.GetHashCode();
        hash = hash * 31 + ParentMarioPlayer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Powerup*)ptr;
        serializer.Stream.Serialize(&p->BlockSpawnAnimationLength);
        serializer.Stream.Serialize(&p->IgnorePlayerFrames);
        serializer.Stream.Serialize(&p->SpawnAnimationFrames);
        serializer.Stream.Serialize(&p->Lifetime);
        QBoolean.Serialize(&p->BlockSpawn, serializer);
        QBoolean.Serialize(&p->FacingRight, serializer);
        QBoolean.Serialize(&p->LaunchSpawn, serializer);
        AssetRef.Serialize(&p->Scriptable, serializer);
        EntityRef.Serialize(&p->ParentMarioPlayer, serializer);
        FP.Serialize(&p->AnimationCurveTimer, serializer);
        FPVector2.Serialize(&p->AnimationCurveOrigin, serializer);
        FPVector2.Serialize(&p->BlockSpawnDestination, serializer);
        FPVector2.Serialize(&p->BlockSpawnOrigin, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Projectile : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public AssetRef<ProjectileAsset> Asset;
    [FieldOffset(32)]
    public FP Speed;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef Owner;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean FacingRight;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean HasBounced;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean CheckedCollision;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16141;
        hash = hash * 31 + Asset.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + FacingRight.GetHashCode();
        hash = hash * 31 + HasBounced.GetHashCode();
        hash = hash * 31 + CheckedCollision.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Projectile*)ptr;
        QBoolean.Serialize(&p->CheckedCollision, serializer);
        QBoolean.Serialize(&p->FacingRight, serializer);
        QBoolean.Serialize(&p->HasBounced, serializer);
        AssetRef.Serialize(&p->Asset, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        FP.Serialize(&p->Speed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Spinner : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FP ArmMoveSpeed;
    [FieldOffset(16)]
    public FP ArmMoveDistance;
    [FieldOffset(32)]
    public FP ArmPosition;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FP PlatformHeight;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte PlatformWaitFrames;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QHashSetPtr<EntityRef> MariosOnPlatform;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FP Rotation;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP AngularVelocity;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public Byte RotationWaitFrames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2999;
        hash = hash * 31 + ArmMoveSpeed.GetHashCode();
        hash = hash * 31 + ArmMoveDistance.GetHashCode();
        hash = hash * 31 + ArmPosition.GetHashCode();
        hash = hash * 31 + PlatformHeight.GetHashCode();
        hash = hash * 31 + PlatformWaitFrames.GetHashCode();
        hash = hash * 31 + MariosOnPlatform.GetHashCode();
        hash = hash * 31 + Rotation.GetHashCode();
        hash = hash * 31 + AngularVelocity.GetHashCode();
        hash = hash * 31 + RotationWaitFrames.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (MariosOnPlatform != default) f.FreeHashSet(ref MariosOnPlatform);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Spinner*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateHashSet(ref MariosOnPlatform);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Spinner*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Spinner*)ptr;
        serializer.Stream.Serialize(&p->PlatformWaitFrames);
        serializer.Stream.Serialize(&p->RotationWaitFrames);
        QHashSet.Serialize(&p->MariosOnPlatform, serializer, Statics.SerializeEntityRef);
        FP.Serialize(&p->AngularVelocity, serializer);
        FP.Serialize(&p->ArmMoveDistance, serializer);
        FP.Serialize(&p->ArmMoveSpeed, serializer);
        FP.Serialize(&p->ArmPosition, serializer);
        FP.Serialize(&p->PlatformHeight, serializer);
        FP.Serialize(&p->Rotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct WrappingObject : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2731;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WrappingObject*)ptr;
    }
  }
  public unsafe partial interface ISignalOnMarioPlayerCollectedStar : ISignal {
    void OnMarioPlayerCollectedStar(Frame f, EntityRef entity);
  }
  public unsafe partial interface ISignalOnEntityBumped : ISignal {
    void OnEntityBumped(Frame f, EntityRef entity, FPVector2 tileWorldPosition, EntityRef blockBump);
  }
  public unsafe partial interface ISignalOnBobombExplodeEntity : ISignal {
    void OnBobombExplodeEntity(Frame f, EntityRef bobomb, EntityRef entity);
  }
  public unsafe partial interface ISignalOnBreakableObjectChangedHeight : ISignal {
    void OnBreakableObjectChangedHeight(Frame f, EntityRef breakable, FP newHeight);
  }
  public unsafe partial interface ISignalOnMarioPlayerCollectedCoin : ISignal {
    void OnMarioPlayerCollectedCoin(Frame f, EntityRef marioEntity, MarioPlayer* mario, FPVector2 worldLocation, QBoolean fromBlock, QBoolean downwards);
  }
  public unsafe partial interface ISignalOnEnemyDespawned : ISignal {
    void OnEnemyDespawned(Frame f, EntityRef entity);
  }
  public unsafe partial interface ISignalOnEnemyRespawned : ISignal {
    void OnEnemyRespawned(Frame f, EntityRef entity);
  }
  public unsafe partial interface ISignalOnEnemyEnemyCollision : ISignal {
    void OnEnemyEnemyCollision(Frame f, EntityRef a, EntityRef b);
  }
  public unsafe partial interface ISignalOnEnemyKilledByStageReset : ISignal {
    void OnEnemyKilledByStageReset(Frame f, EntityRef entity);
  }
  public unsafe partial interface ISignalOnEnemyTurnaround : ISignal {
    void OnEnemyTurnaround(Frame f, EntityRef entity);
  }
  public unsafe partial interface ISignalOnEntityFreeze : ISignal {
    void OnEntityFreeze(Frame f, EntityRef entity, EntityRef iceBlock);
  }
  public unsafe partial interface ISignalOnLoadingComplete : ISignal {
    void OnLoadingComplete(Frame f);
  }
  public unsafe partial interface ISignalOnGameStarting : ISignal {
    void OnGameStarting(Frame f);
  }
  public unsafe partial interface ISignalOnGameEnding : ISignal {
    void OnGameEnding(Frame f, Int32 winningTeam, QBoolean hasWinner);
  }
  public unsafe partial interface ISignalOnReturnToRoom : ISignal {
    void OnReturnToRoom(Frame f);
  }
  public unsafe partial interface ISignalOnThrowHoldable : ISignal {
    void OnThrowHoldable(Frame f, EntityRef entity, EntityRef mario, QBoolean crouching, QBoolean dropped);
  }
  public unsafe partial interface ISignalOnIceBlockBroken : ISignal {
    void OnIceBlockBroken(Frame f, EntityRef brokenIceBlock, IceBlockBreakReason breakReason);
  }
  public unsafe partial interface ISignalOnBeforeInteraction : ISignal {
    void OnBeforeInteraction(Frame f, EntityRef entity, bool* allowInteraction);
  }
  public unsafe partial interface ISignalOnTryLiquidSplash : ISignal {
    void OnTryLiquidSplash(Frame f, EntityRef entity, EntityRef liquid, QBoolean exit, bool* doSplash);
  }
  public unsafe partial interface ISignalOnEntityEnterExitLiquid : ISignal {
    void OnEntityEnterExitLiquid(Frame f, EntityRef entity, EntityRef liquid, QBoolean underwater);
  }
  public unsafe partial interface ISignalOnMarioPlayerDied : ISignal {
    void OnMarioPlayerDied(Frame f, EntityRef entity);
  }
  public unsafe partial interface ISignalOnEntityChangeUnderwaterState : ISignal {
    void OnEntityChangeUnderwaterState(Frame f, EntityRef entity, EntityRef liquid, QBoolean underwater);
  }
  public unsafe partial interface ISignalOnStageReset : ISignal {
    void OnStageReset(Frame f, QBoolean full);
  }
  public unsafe partial interface ISignalOnTileChanged : ISignal {
    void OnTileChanged(Frame f, Int32 tileX, Int32 tileY, StageTileInstance newTile);
  }
  public static unsafe partial class Constants {
    /// <summary>8.5</summary>
    public static FP _8_50 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 557056;
        return result;
      }
    }
    /// <summary>0.95</summary>
    public static FP _0_95 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 62259;
        return result;
      }
    }
    /// <summary>4.5</summary>
    public static FP _4_50 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 294912;
        return result;
      }
    }
    /// <summary>5.5</summary>
    public static FP _5_50 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 360448;
        return result;
      }
    }
    /// <summary>14.75</summary>
    public static FP _14_75 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 966656;
        return result;
      }
    }
    /// <summary>3.5</summary>
    public static FP _3_50 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 229376;
        return result;
      }
    }
    /// <summary>1.77777</summary>
    public static FP SixteenOverNine {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 116508;
        return result;
      }
    }
    /// <summary>2.5</summary>
    public static FP _2_50 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 163840;
        return result;
      }
    }
    /// <summary>1.18</summary>
    public static FP _1_18 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 77332;
        return result;
      }
    }
    /// <summary>0.85</summary>
    public static FP _0_85 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 55706;
        return result;
      }
    }
    /// <summary>-0.03047</summary>
    public static FP WeirdSlopeConstant {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = -1997;
        return result;
      }
    }
    /// <summary>0.9</summary>
    public static FP _0_90 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 58982;
        return result;
      }
    }
    /// <summary>0.1875</summary>
    public static FP _0_1875 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 12288;
        return result;
      }
    }
    /// <summary>0.4</summary>
    public static FP _0_40 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 26214;
        return result;
      }
    }
    /// <summary>0.35</summary>
    public static FP _0_35 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 22938;
        return result;
      }
    }
    /// <summary>0.09</summary>
    public static FP _0_09 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 5898;
        return result;
      }
    }
    /// <summary>0.66666</summary>
    public static FP _0_66 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 43690;
        return result;
      }
    }
    /// <summary>1.875</summary>
    public static FP OnePixelPerFrame {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 122880;
        return result;
      }
    }
    /// <summary>1.1</summary>
    public static FP _1_10 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 72090;
        return result;
      }
    }
    /// <summary>0.0001</summary>
    public static FP _0_0001 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 7;
        return result;
      }
    }
    /// <summary>0.48</summary>
    public static FP _0_48 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 31457;
        return result;
      }
    }
    /// <summary>0.235</summary>
    public static FP _0_235 {
      [MethodImpl(MethodImplOptions.AggressiveInlining)] get { 
        FP result;
        result.RawValue = 15401;
        return result;
      }
    }

    public static unsafe partial class Raw {
      /// <summary>8.5</summary>
      public const Int64 _8_50 = 557056;
      /// <summary>0.95</summary>
      public const Int64 _0_95 = 62259;
      /// <summary>4.5</summary>
      public const Int64 _4_50 = 294912;
      /// <summary>5.5</summary>
      public const Int64 _5_50 = 360448;
      /// <summary>14.75</summary>
      public const Int64 _14_75 = 966656;
      /// <summary>3.5</summary>
      public const Int64 _3_50 = 229376;
      /// <summary>1.77777</summary>
      public const Int64 SixteenOverNine = 116508;
      /// <summary>2.5</summary>
      public const Int64 _2_50 = 163840;
      /// <summary>1.18</summary>
      public const Int64 _1_18 = 77332;
      /// <summary>0.85</summary>
      public const Int64 _0_85 = 55706;
      /// <summary>-0.03047</summary>
      public const Int64 WeirdSlopeConstant = -1997;
      /// <summary>0.9</summary>
      public const Int64 _0_90 = 58982;
      /// <summary>0.1875</summary>
      public const Int64 _0_1875 = 12288;
      /// <summary>0.4</summary>
      public const Int64 _0_40 = 26214;
      /// <summary>0.35</summary>
      public const Int64 _0_35 = 22938;
      /// <summary>0.09</summary>
      public const Int64 _0_09 = 5898;
      /// <summary>0.66666</summary>
      public const Int64 _0_66 = 43690;
      /// <summary>1.875</summary>
      public const Int64 OnePixelPerFrame = 122880;
      /// <summary>1.1</summary>
      public const Int64 _1_10 = 72090;
      /// <summary>0.0001</summary>
      public const Int64 _0_0001 = 7;
      /// <summary>0.48</summary>
      public const Int64 _0_48 = 31457;
      /// <summary>0.235</summary>
      public const Int64 _0_235 = 15401;
    }
  }
  public unsafe partial class Frame {
    private ISignalOnMarioPlayerCollectedStar[] _ISignalOnMarioPlayerCollectedStarSystems;
    private ISignalOnEntityBumped[] _ISignalOnEntityBumpedSystems;
    private ISignalOnBobombExplodeEntity[] _ISignalOnBobombExplodeEntitySystems;
    private ISignalOnBreakableObjectChangedHeight[] _ISignalOnBreakableObjectChangedHeightSystems;
    private ISignalOnMarioPlayerCollectedCoin[] _ISignalOnMarioPlayerCollectedCoinSystems;
    private ISignalOnEnemyDespawned[] _ISignalOnEnemyDespawnedSystems;
    private ISignalOnEnemyRespawned[] _ISignalOnEnemyRespawnedSystems;
    private ISignalOnEnemyEnemyCollision[] _ISignalOnEnemyEnemyCollisionSystems;
    private ISignalOnEnemyKilledByStageReset[] _ISignalOnEnemyKilledByStageResetSystems;
    private ISignalOnEnemyTurnaround[] _ISignalOnEnemyTurnaroundSystems;
    private ISignalOnEntityFreeze[] _ISignalOnEntityFreezeSystems;
    private ISignalOnLoadingComplete[] _ISignalOnLoadingCompleteSystems;
    private ISignalOnGameStarting[] _ISignalOnGameStartingSystems;
    private ISignalOnGameEnding[] _ISignalOnGameEndingSystems;
    private ISignalOnReturnToRoom[] _ISignalOnReturnToRoomSystems;
    private ISignalOnThrowHoldable[] _ISignalOnThrowHoldableSystems;
    private ISignalOnIceBlockBroken[] _ISignalOnIceBlockBrokenSystems;
    private ISignalOnBeforeInteraction[] _ISignalOnBeforeInteractionSystems;
    private ISignalOnTryLiquidSplash[] _ISignalOnTryLiquidSplashSystems;
    private ISignalOnEntityEnterExitLiquid[] _ISignalOnEntityEnterExitLiquidSystems;
    private ISignalOnMarioPlayerDied[] _ISignalOnMarioPlayerDiedSystems;
    private ISignalOnEntityChangeUnderwaterState[] _ISignalOnEntityChangeUnderwaterStateSystems;
    private ISignalOnStageReset[] _ISignalOnStageResetSystems;
    private ISignalOnTileChanged[] _ISignalOnTileChangedSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnMarioPlayerCollectedStarSystems = BuildSignalsArray<ISignalOnMarioPlayerCollectedStar>();
      _ISignalOnEntityBumpedSystems = BuildSignalsArray<ISignalOnEntityBumped>();
      _ISignalOnBobombExplodeEntitySystems = BuildSignalsArray<ISignalOnBobombExplodeEntity>();
      _ISignalOnBreakableObjectChangedHeightSystems = BuildSignalsArray<ISignalOnBreakableObjectChangedHeight>();
      _ISignalOnMarioPlayerCollectedCoinSystems = BuildSignalsArray<ISignalOnMarioPlayerCollectedCoin>();
      _ISignalOnEnemyDespawnedSystems = BuildSignalsArray<ISignalOnEnemyDespawned>();
      _ISignalOnEnemyRespawnedSystems = BuildSignalsArray<ISignalOnEnemyRespawned>();
      _ISignalOnEnemyEnemyCollisionSystems = BuildSignalsArray<ISignalOnEnemyEnemyCollision>();
      _ISignalOnEnemyKilledByStageResetSystems = BuildSignalsArray<ISignalOnEnemyKilledByStageReset>();
      _ISignalOnEnemyTurnaroundSystems = BuildSignalsArray<ISignalOnEnemyTurnaround>();
      _ISignalOnEntityFreezeSystems = BuildSignalsArray<ISignalOnEntityFreeze>();
      _ISignalOnLoadingCompleteSystems = BuildSignalsArray<ISignalOnLoadingComplete>();
      _ISignalOnGameStartingSystems = BuildSignalsArray<ISignalOnGameStarting>();
      _ISignalOnGameEndingSystems = BuildSignalsArray<ISignalOnGameEnding>();
      _ISignalOnReturnToRoomSystems = BuildSignalsArray<ISignalOnReturnToRoom>();
      _ISignalOnThrowHoldableSystems = BuildSignalsArray<ISignalOnThrowHoldable>();
      _ISignalOnIceBlockBrokenSystems = BuildSignalsArray<ISignalOnIceBlockBroken>();
      _ISignalOnBeforeInteractionSystems = BuildSignalsArray<ISignalOnBeforeInteraction>();
      _ISignalOnTryLiquidSplashSystems = BuildSignalsArray<ISignalOnTryLiquidSplash>();
      _ISignalOnEntityEnterExitLiquidSystems = BuildSignalsArray<ISignalOnEntityEnterExitLiquid>();
      _ISignalOnMarioPlayerDiedSystems = BuildSignalsArray<ISignalOnMarioPlayerDied>();
      _ISignalOnEntityChangeUnderwaterStateSystems = BuildSignalsArray<ISignalOnEntityChangeUnderwaterState>();
      _ISignalOnStageResetSystems = BuildSignalsArray<ISignalOnStageReset>();
      _ISignalOnTileChangedSystems = BuildSignalsArray<ISignalOnTileChanged>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.BigStar>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BigStar>();
      BuildSignalsArrayOnComponentAdded<Quantum.BlockBump>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BlockBump>();
      BuildSignalsArrayOnComponentAdded<Quantum.Bobomb>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Bobomb>();
      BuildSignalsArrayOnComponentAdded<Quantum.Boo>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Boo>();
      BuildSignalsArrayOnComponentAdded<Quantum.BreakableObject>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BreakableObject>();
      BuildSignalsArrayOnComponentAdded<Quantum.BulletBill>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BulletBill>();
      BuildSignalsArrayOnComponentAdded<Quantum.BulletBillLauncher>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BulletBillLauncher>();
      BuildSignalsArrayOnComponentAdded<Quantum.CameraController>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CameraController>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.Coin>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Coin>();
      BuildSignalsArrayOnComponentAdded<Quantum.Cullable>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Cullable>();
      BuildSignalsArrayOnComponentAdded<Quantum.Enemy>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Enemy>();
      BuildSignalsArrayOnComponentAdded<Quantum.EnterablePipe>();
      BuildSignalsArrayOnComponentRemoved<Quantum.EnterablePipe>();
      BuildSignalsArrayOnComponentAdded<Quantum.Freezable>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Freezable>();
      BuildSignalsArrayOnComponentAdded<Quantum.GenericMover>();
      BuildSignalsArrayOnComponentRemoved<Quantum.GenericMover>();
      BuildSignalsArrayOnComponentAdded<Quantum.Goomba>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Goomba>();
      BuildSignalsArrayOnComponentAdded<Quantum.Holdable>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Holdable>();
      BuildSignalsArrayOnComponentAdded<Quantum.IceBlock>();
      BuildSignalsArrayOnComponentRemoved<Quantum.IceBlock>();
      BuildSignalsArrayOnComponentAdded<Quantum.Interactable>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Interactable>();
      BuildSignalsArrayOnComponentAdded<Quantum.InvisibleBlock>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InvisibleBlock>();
      BuildSignalsArrayOnComponentAdded<Quantum.Koopa>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Koopa>();
      BuildSignalsArrayOnComponentAdded<Quantum.Liquid>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Liquid>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.MarioBrosPlatform>();
      BuildSignalsArrayOnComponentRemoved<Quantum.MarioBrosPlatform>();
      BuildSignalsArrayOnComponentAdded<Quantum.MarioPlayer>();
      BuildSignalsArrayOnComponentRemoved<Quantum.MarioPlayer>();
      BuildSignalsArrayOnComponentAdded<Quantum.MovingPlatform>();
      BuildSignalsArrayOnComponentRemoved<Quantum.MovingPlatform>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PhysicsObject>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PhysicsObject>();
      BuildSignalsArrayOnComponentAdded<Quantum.PiranhaPlant>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PiranhaPlant>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerData>();
      BuildSignalsArrayOnComponentAdded<Quantum.Powerup>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Powerup>();
      BuildSignalsArrayOnComponentAdded<Quantum.Projectile>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Projectile>();
      BuildSignalsArrayOnComponentAdded<Quantum.Spinner>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Spinner>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
      BuildSignalsArrayOnComponentAdded<Quantum.WrappingObject>();
      BuildSignalsArrayOnComponentRemoved<Quantum.WrappingObject>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->Up = i->Up.Update(this.Number, input.Up);
      i->Down = i->Down.Update(this.Number, input.Down);
      i->Left = i->Left.Update(this.Number, input.Left);
      i->Right = i->Right.Update(this.Number, input.Right);
      i->Jump = i->Jump.Update(this.Number, input.Jump);
      i->Sprint = i->Sprint.Update(this.Number, input.Sprint);
      i->PowerupAction = i->PowerupAction.Update(this.Number, input.PowerupAction);
      i->FireballPowerupAction = i->FireballPowerupAction.Update(this.Number, input.FireballPowerupAction);
      i->PropellerPowerupAction = i->PropellerPowerupAction.Update(this.Number, input.PropellerPowerupAction);
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnMarioPlayerCollectedStar(EntityRef entity) {
        var array = _f._ISignalOnMarioPlayerCollectedStarSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMarioPlayerCollectedStar(_f, entity);
          }
        }
      }
      public void OnEntityBumped(EntityRef entity, FPVector2 tileWorldPosition, EntityRef blockBump) {
        var array = _f._ISignalOnEntityBumpedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEntityBumped(_f, entity, tileWorldPosition, blockBump);
          }
        }
      }
      public void OnBobombExplodeEntity(EntityRef bobomb, EntityRef entity) {
        var array = _f._ISignalOnBobombExplodeEntitySystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBobombExplodeEntity(_f, bobomb, entity);
          }
        }
      }
      public void OnBreakableObjectChangedHeight(EntityRef breakable, FP newHeight) {
        var array = _f._ISignalOnBreakableObjectChangedHeightSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBreakableObjectChangedHeight(_f, breakable, newHeight);
          }
        }
      }
      public void OnMarioPlayerCollectedCoin(EntityRef marioEntity, MarioPlayer* mario, FPVector2 worldLocation, QBoolean fromBlock, QBoolean downwards) {
        var array = _f._ISignalOnMarioPlayerCollectedCoinSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMarioPlayerCollectedCoin(_f, marioEntity, mario, worldLocation, fromBlock, downwards);
          }
        }
      }
      public void OnEnemyDespawned(EntityRef entity) {
        var array = _f._ISignalOnEnemyDespawnedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEnemyDespawned(_f, entity);
          }
        }
      }
      public void OnEnemyRespawned(EntityRef entity) {
        var array = _f._ISignalOnEnemyRespawnedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEnemyRespawned(_f, entity);
          }
        }
      }
      public void OnEnemyEnemyCollision(EntityRef a, EntityRef b) {
        var array = _f._ISignalOnEnemyEnemyCollisionSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEnemyEnemyCollision(_f, a, b);
          }
        }
      }
      public void OnEnemyKilledByStageReset(EntityRef entity) {
        var array = _f._ISignalOnEnemyKilledByStageResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEnemyKilledByStageReset(_f, entity);
          }
        }
      }
      public void OnEnemyTurnaround(EntityRef entity) {
        var array = _f._ISignalOnEnemyTurnaroundSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEnemyTurnaround(_f, entity);
          }
        }
      }
      public void OnEntityFreeze(EntityRef entity, EntityRef iceBlock) {
        var array = _f._ISignalOnEntityFreezeSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEntityFreeze(_f, entity, iceBlock);
          }
        }
      }
      public void OnLoadingComplete() {
        var array = _f._ISignalOnLoadingCompleteSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnLoadingComplete(_f);
          }
        }
      }
      public void OnGameStarting() {
        var array = _f._ISignalOnGameStartingSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameStarting(_f);
          }
        }
      }
      public void OnGameEnding(Int32 winningTeam, QBoolean hasWinner) {
        var array = _f._ISignalOnGameEndingSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameEnding(_f, winningTeam, hasWinner);
          }
        }
      }
      public void OnReturnToRoom() {
        var array = _f._ISignalOnReturnToRoomSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnReturnToRoom(_f);
          }
        }
      }
      public void OnThrowHoldable(EntityRef entity, EntityRef mario, QBoolean crouching, QBoolean dropped) {
        var array = _f._ISignalOnThrowHoldableSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnThrowHoldable(_f, entity, mario, crouching, dropped);
          }
        }
      }
      public void OnIceBlockBroken(EntityRef brokenIceBlock, IceBlockBreakReason breakReason) {
        var array = _f._ISignalOnIceBlockBrokenSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnIceBlockBroken(_f, brokenIceBlock, breakReason);
          }
        }
      }
      public void OnBeforeInteraction(EntityRef entity, bool* allowInteraction) {
        var array = _f._ISignalOnBeforeInteractionSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBeforeInteraction(_f, entity, allowInteraction);
          }
        }
      }
      public void OnTryLiquidSplash(EntityRef entity, EntityRef liquid, QBoolean exit, bool* doSplash) {
        var array = _f._ISignalOnTryLiquidSplashSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTryLiquidSplash(_f, entity, liquid, exit, doSplash);
          }
        }
      }
      public void OnEntityEnterExitLiquid(EntityRef entity, EntityRef liquid, QBoolean underwater) {
        var array = _f._ISignalOnEntityEnterExitLiquidSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEntityEnterExitLiquid(_f, entity, liquid, underwater);
          }
        }
      }
      public void OnMarioPlayerDied(EntityRef entity) {
        var array = _f._ISignalOnMarioPlayerDiedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMarioPlayerDied(_f, entity);
          }
        }
      }
      public void OnEntityChangeUnderwaterState(EntityRef entity, EntityRef liquid, QBoolean underwater) {
        var array = _f._ISignalOnEntityChangeUnderwaterStateSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEntityChangeUnderwaterState(_f, entity, liquid, underwater);
          }
        }
      }
      public void OnStageReset(QBoolean full) {
        var array = _f._ISignalOnStageResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnStageReset(_f, full);
          }
        }
      }
      public void OnTileChanged(Int32 tileX, Int32 tileY, StageTileInstance newTile) {
        var array = _f._ISignalOnTileChangedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTileChanged(_f, tileX, tileY, newTile);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializePhysicsQueryRef;
    public static FrameSerializer.Delegate SerializePhysicsContact;
    public static FrameSerializer.Delegate SerializePlayerRef;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeEntityRef = EntityRef.Serialize;
      SerializePhysicsQueryRef = PhysicsQueryRef.Serialize;
      SerializePhysicsContact = Quantum.PhysicsContact.Serialize;
      SerializePlayerRef = PlayerRef.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BigStar), Quantum.BigStar.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet10), Quantum.BitSet10.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet64), Quantum.BitSet64.SIZE);
      typeRegistry.Register(typeof(Quantum.BlockBump), Quantum.BlockBump.SIZE);
      typeRegistry.Register(typeof(Quantum.Bobomb), Quantum.Bobomb.SIZE);
      typeRegistry.Register(typeof(Quantum.Boo), Quantum.Boo.SIZE);
      typeRegistry.Register(typeof(Quantum.BreakableObject), Quantum.BreakableObject.SIZE);
      typeRegistry.Register(typeof(Quantum.BulletBill), Quantum.BulletBill.SIZE);
      typeRegistry.Register(typeof(Quantum.BulletBillLauncher), Quantum.BulletBillLauncher.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(Quantum.CameraController), Quantum.CameraController.SIZE);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Coin), Quantum.Coin.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.Cullable), Quantum.Cullable.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Enemy), Quantum.Enemy.SIZE);
      typeRegistry.Register(typeof(Quantum.EnterablePipe), Quantum.EnterablePipe.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.Freezable), Quantum.Freezable.SIZE);
      typeRegistry.Register(typeof(Quantum.GameRules), Quantum.GameRules.SIZE);
      typeRegistry.Register(typeof(Quantum.GameState), 1);
      typeRegistry.Register(typeof(Quantum.GenericMover), Quantum.GenericMover.SIZE);
      typeRegistry.Register(typeof(Quantum.Goomba), Quantum.Goomba.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Holdable), Quantum.Holdable.SIZE);
      typeRegistry.Register(typeof(Quantum.IceBlock), Quantum.IceBlock.SIZE);
      typeRegistry.Register(typeof(IceBlockBreakReason), 1);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(Quantum.Interactable), Quantum.Interactable.SIZE);
      typeRegistry.Register(typeof(Quantum.InvisibleBlock), Quantum.InvisibleBlock.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.JumpState), 1);
      typeRegistry.Register(typeof(Quantum.Koopa), Quantum.Koopa.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(Quantum.Liquid), Quantum.Liquid.SIZE);
      typeRegistry.Register(typeof(LiquidType), 1);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(Quantum.MarioBrosPlatform), Quantum.MarioBrosPlatform.SIZE);
      typeRegistry.Register(typeof(Quantum.MarioPlayer), Quantum.MarioPlayer.SIZE);
      typeRegistry.Register(typeof(Quantum.MovingPlatform), Quantum.MovingPlatform.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(ParticleEffect), 1);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(Quantum.PhysicsContact), Quantum.PhysicsContact.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(Quantum.PhysicsObject), Quantum.PhysicsObject.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PiranhaPlant), Quantum.PiranhaPlant.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerData), Quantum.PlayerData.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Quantum.Powerup), Quantum.Powerup.SIZE);
      typeRegistry.Register(typeof(Quantum.PowerupReserveResult), 1);
      typeRegistry.Register(typeof(Quantum.PowerupState), 1);
      typeRegistry.Register(typeof(Quantum.Projectile), Quantum.Projectile.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Spinner), Quantum.Spinner.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.StageTileInstance), Quantum.StageTileInstance.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum.WrappingObject), Quantum.WrappingObject.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 31)
        .AddBuiltInComponents()
        .Add<Quantum.BigStar>(Quantum.BigStar.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BlockBump>(Quantum.BlockBump.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Bobomb>(Quantum.Bobomb.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Boo>(Quantum.Boo.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BreakableObject>(Quantum.BreakableObject.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BulletBill>(Quantum.BulletBill.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BulletBillLauncher>(Quantum.BulletBillLauncher.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CameraController>(Quantum.CameraController.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Coin>(Quantum.Coin.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Cullable>(Quantum.Cullable.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Enemy>(Quantum.Enemy.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.EnterablePipe>(Quantum.EnterablePipe.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Freezable>(Quantum.Freezable.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.GenericMover>(Quantum.GenericMover.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Goomba>(Quantum.Goomba.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Holdable>(Quantum.Holdable.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.IceBlock>(Quantum.IceBlock.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Interactable>(Quantum.Interactable.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InvisibleBlock>(Quantum.InvisibleBlock.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Koopa>(Quantum.Koopa.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Liquid>(Quantum.Liquid.Serialize, Quantum.Liquid.OnAdded, Quantum.Liquid.OnRemoved, ComponentFlags.None)
        .Add<Quantum.MarioBrosPlatform>(Quantum.MarioBrosPlatform.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.MarioPlayer>(Quantum.MarioPlayer.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.MovingPlatform>(Quantum.MovingPlatform.Serialize, Quantum.MovingPlatform.OnAdded, Quantum.MovingPlatform.OnRemoved, ComponentFlags.None)
        .Add<Quantum.PhysicsObject>(Quantum.PhysicsObject.Serialize, Quantum.PhysicsObject.OnAdded, Quantum.PhysicsObject.OnRemoved, ComponentFlags.None)
        .Add<Quantum.PiranhaPlant>(Quantum.PiranhaPlant.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerData>(Quantum.PlayerData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Powerup>(Quantum.Powerup.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Projectile>(Quantum.Projectile.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Spinner>(Quantum.Spinner.Serialize, Quantum.Spinner.OnAdded, Quantum.Spinner.OnRemoved, ComponentFlags.None)
        .Add<Quantum.WrappingObject>(Quantum.WrappingObject.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameState>();
      FramePrinter.EnsurePrimitiveNotStripped<IceBlockBreakReason>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.JumpState>();
      FramePrinter.EnsurePrimitiveNotStripped<LiquidType>();
      FramePrinter.EnsurePrimitiveNotStripped<ParticleEffect>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PowerupReserveResult>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PowerupState>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
